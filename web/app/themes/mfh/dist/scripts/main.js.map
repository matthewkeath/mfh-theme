{"version":3,"sources":["../bower_components/bootstrap/js/transition.js","../bower_components/bootstrap/js/alert.js","../bower_components/bootstrap/js/button.js","../bower_components/bootstrap/js/carousel.js","../bower_components/bootstrap/js/collapse.js","../bower_components/bootstrap/js/dropdown.js","../bower_components/bootstrap/js/modal.js","../bower_components/bootstrap/js/tooltip.js","../bower_components/bootstrap/js/popover.js","../bower_components/bootstrap/js/scrollspy.js","../bower_components/bootstrap/js/tab.js","../bower_components/bootstrap/js/affix.js","../bower_components/angular/angular.js","../bower_components/angular-natural-language/build/angular-natural-language.min.js","../assets/scripts/main.js"],"names":["$","transitionEnd","el","document","createElement","transEndEventNames","WebkitTransition","MozTransition","OTransition","transition","name","undefined","style","end","fn","emulateTransitionEnd","duration","called","$el","this","one","callback","trigger","support","setTimeout","event","special","bsTransitionEnd","bindType","delegateType","handle","e","target","is","handleObj","handler","apply","arguments","jQuery","Plugin","option","each","$this","data","Alert","call","dismiss","on","close","VERSION","TRANSITION_DURATION","prototype","removeElement","$parent","detach","remove","selector","attr","replace","preventDefault","length","closest","Event","isDefaultPrevented","removeClass","hasClass","old","alert","Constructor","noConflict","options","Button","toggle","setState","element","$element","extend","DEFAULTS","isLoading","loadingText","state","d","val","resetText","proxy","addClass","removeAttr","changed","$input","find","prop","toggleClass","button","$btn","test","type","Carousel","action","slide","to","interval","pause","cycle","$indicators","paused","sliding","$active","$items","keyboard","keydown","documentElement","wrap","tagName","which","prev","next","clearInterval","setInterval","getItemIndex","item","parent","children","index","getItemForDirection","direction","active","activeIndex","willWrap","delta","itemIndex","eq","pos","that","$next","isCycling","relatedTarget","slideEvent","$nextIndicator","slidEvent","offsetWidth","join","carousel","clickHandler","href","$target","slideIndex","window","$carousel","getTargetFromTrigger","$trigger","Collapse","id","transitioning","getParent","addAriaAndCollapsedClass","dimension","hasWidth","show","activesData","actives","startEvent","complete","scrollSize","camelCase","hide","offsetHeight","i","isOpen","collapse","clearMenus","backdrop","Dropdown","isActive","insertAfter","stopPropagation","desc","dropdown","_relatedTarget","Modal","$body","body","$dialog","$backdrop","isShown","originalBodyPad","scrollbarWidth","ignoreBackdropClick","remote","load","BACKDROP_TRANSITION_DURATION","checkScrollbar","setScrollbar","escape","resize","appendTo","scrollTop","adjustDialog","enforceFocus","off","hideModal","has","handleUpdate","resetAdjustments","resetScrollbar","removeBackdrop","animate","doAnimate","currentTarget","focus","callbackRemove","modalIsOverflowing","scrollHeight","clientHeight","css","paddingLeft","bodyIsOverflowing","paddingRight","fullWindowWidth","innerWidth","documentElementRect","getBoundingClientRect","right","Math","abs","left","clientWidth","measureScrollbar","bodyPad","parseInt","scrollDiv","className","append","removeChild","modal","showEvent","Tooltip","enabled","timeout","hoverState","init","animation","placement","template","title","delay","html","container","viewport","padding","getOptions","$viewport","constructor","Error","triggers","split","eventIn","eventOut","enter","leave","_options","fixTitle","getDefaults","getDelegateOptions","defaults","key","value","obj","self","$tip","clearTimeout","hasContent","inDom","contains","ownerDocument","tip","tipId","getUID","setContent","autoToken","autoPlace","top","display","getPosition","actualWidth","actualHeight","orgPlacement","$container","containerDim","bottom","width","calculatedOffset","getCalculatedOffset","applyPlacement","prevHoverState","offset","height","marginTop","marginLeft","isNaN","setOffset","using","props","round","getViewportAdjustedDelta","isVertical","arrowDelta","arrowOffsetPosition","replaceArrow","arrow","getTitle","$e","isBody","elRect","elOffset","scroll","outerDims","viewportPadding","viewportDimensions","topEdgeOffset","bottomEdgeOffset","leftEdgeOffset","rightEdgeOffset","o","prefix","random","getElementById","$arrow","enable","disable","toggleEnabled","destroy","removeData","tooltip","Popover","content","getContent","popover","ScrollSpy","$scrollElement","offsets","targets","activeTarget","process","refresh","getScrollHeight","max","offsetMethod","offsetBase","isWindow","map","$href","sort","a","b","push","maxScroll","activate","clear","parents","parentsUntil","scrollspy","$spy","Tab","$ul","$previous","hideEvent","tab","Affix","checkPosition","checkPositionWithEventLoop","affixed","unpin","pinnedOffset","RESET","getState","offsetTop","offsetBottom","position","targetHeight","initializing","colliderTop","colliderHeight","getPinnedOffset","affix","affixType","isArrayLike","hasOwnProperty","JQLite","toString","callee","forEach","iterator","context","isFunction","sortedKeys","keys","forEachSorted","reverseParams","iteratorFn","nextUid","digit","uid","charCodeAt","String","fromCharCode","unshift","setHashKey","h","$$hashKey","dst","int","str","inherit","extra","noop","identity","valueFn","isUndefined","isDefined","isObject","isString","isNumber","isDate","isArray","isRegExp","location","isScope","$evalAsync","$watch","isFile","isElement","node","nodeName","bind","results","list","includes","array","indexOf","arrayRemove","splice","copy","source","destination","Date","getTime","RegExp","shallowCopy","src","substr","equals","o1","o2","keySet","t1","t2","charAt","concat","array1","array2","slice","sliceArgs","args","startIndex","curryArgs","toJsonReplacer","toJson","pretty","JSON","stringify","fromJson","json","parse","toBoolean","v","lowercase","startingTag","jqLite","clone","TEXT_NODE","elemHtml","nodeType","match","tryDecodeURIComponent","decodeURIComponent","parseKeyValue","keyValue","key_value","toKeyValue","parts","encodeUriQuery","encodeUriSegment","pctEncodeSpaces","encodeURIComponent","angularInit","bootstrap","elements","appElement","module","names","NG_APP_CLASS_REGEXP","querySelectorAll","exec","attributes","modules","doBootstrap","$provide","injector","createInjector","invoke","scope","compile","$apply","NG_DEFER_BOOTSTRAP","angular","resumeBootstrap","extraModules","snake_case","separator","SNAKE_CASE_REGEXP","letter","toLowerCase","bindJQuery","JQLitePrototype","controller","inheritedData","JQLitePatchJQueryRemove","assertArg","arg","reason","assertArgFn","acceptArrayAnnotation","getter","path","bindFnToScope","lastInstance","len","setupModuleLoader","ensure","factory","Object","requires","configFn","invokeLater","provider","method","insertMethod","invokeQueue","moduleInstance","runBlocks","config","_invokeQueue","_runBlocks","service","constant","filter","directive","run","block","publishExternalAPI","version","uppercase","callbacks","counter","angularModule","$LocaleProvider","$CompileProvider","htmlAnchorDirective","input","inputDirective","textarea","form","formDirective","script","scriptDirective","select","selectDirective","styleDirective","optionDirective","ngBind","ngBindDirective","ngBindHtmlUnsafe","ngBindHtmlUnsafeDirective","ngBindTemplate","ngBindTemplateDirective","ngClass","ngClassDirective","ngClassEven","ngClassEvenDirective","ngClassOdd","ngClassOddDirective","ngCsp","ngCspDirective","ngCloak","ngCloakDirective","ngController","ngControllerDirective","ngForm","ngFormDirective","ngHide","ngHideDirective","ngInclude","ngIncludeDirective","ngInit","ngInitDirective","ngNonBindable","ngNonBindableDirective","ngPluralize","ngPluralizeDirective","ngRepeat","ngRepeatDirective","ngShow","ngShowDirective","ngStyle","ngStyleDirective","ngSwitch","ngSwitchDirective","ngSwitchWhen","ngSwitchWhenDirective","ngSwitchDefault","ngSwitchDefaultDirective","ngOptions","ngOptionsDirective","ngView","ngViewDirective","ngTransclude","ngTranscludeDirective","ngModel","ngModelDirective","ngList","ngListDirective","ngChange","ngChangeDirective","required","requiredDirective","ngRequired","ngValue","ngValueDirective","ngAttributeAliasDirectives","ngEventDirectives","$anchorScroll","$AnchorScrollProvider","$browser","$BrowserProvider","$cacheFactory","$CacheFactoryProvider","$controller","$ControllerProvider","$document","$DocumentProvider","$exceptionHandler","$ExceptionHandlerProvider","$filter","$FilterProvider","$interpolate","$InterpolateProvider","$http","$HttpProvider","$httpBackend","$HttpBackendProvider","$location","$LocationProvider","$log","$LogProvider","$parse","$ParseProvider","$route","$RouteProvider","$routeParams","$RouteParamsProvider","$rootScope","$RootScopeProvider","$q","$QProvider","$sniffer","$SnifferProvider","$templateCache","$TemplateCacheProvider","$timeout","$TimeoutProvider","$window","$WindowProvider","jqNextId","jqId","SPECIAL_CHARS_REGEXP","_","toUpperCase","MOZ_HACK_REGEXP","dispatchThis","filterElems","getterIfNoArguments","removePatch","param","set","setIndex","setLength","childIndex","childLength","fireEvent","shift","triggerHandler","originalJqFn","$original","div","innerHTML","firstChild","JQLiteAddNodes","childNodes","JQLiteClone","cloneNode","JQLiteDealoc","JQLiteRemoveData","JQLiteUnbind","events","JQLiteExpandoStore","eventHandler","removeEventListenerFn","expandoId","jqName","expandoStore","jqCache","$destroy","JQLiteData","isSetter","keyDefined","isSimpleGetter","JQLiteHasClass","JQLiteRemoveClass","cssClasses","cssClass","trim","JQLiteAddClass","root","JQLiteController","JQLiteInheritedData","getBooleanAttrName","booleanAttr","BOOLEAN_ATTR","BOOLEAN_ELEMENTS","createEventHandler","returnValue","cancelBubble","srcElement","defaultPrevented","prevent","msie","elem","hashKey","objType","HashMap","put","HashQueueMap","annotate","$inject","fnText","argDecl","last","STRIP_COMMENTS","FN_ARGS","FN_ARG_SPLIT","FN_ARG","all","underscore","modulesToLoad","supportObject","delegate","provider_","providerInjector","instantiate","$get","providerCache","providerSuffix","factoryFn","$injector","instanceCache","decorator","serviceName","decorFn","origProvider","get","orig$get","origInstance","instanceInjector","$delegate","loadModules","loadedModules","moduleFn","ii","invokeArgs","message","createInternalInjector","cache","getService","INSTANTIATING","locals","Type","instance","returnedValue","servicename","autoScrollingEnabled","disableAutoScrolling","getFirstAnchor","result","elm","hash","scrollIntoView","getElementsByName","scrollTo","Browser","completeOutstandingRequest","outstandingRequestCount","outstandingRequestCallbacks","pop","error","startPoller","check","pollFns","pollFn","pollTimeout","fireUrlChange","lastBrowserUrl","url","urlChangeListeners","listener","rawDocument","history","pendingDeferIds","isMock","$$completeOutstandingRequest","$$incOutstandingRequestCount","notifyWhenNoOutstandingRequests","addPollFn","baseElement","replacedUrl","replaceState","pushState","urlChangeInit","onUrlChange","hashchange","baseHref","lastCookies","lastCookieString","cookiePath","cookies","cookieLength","cookieArray","cookie","unescape","substring","warn","defer","timeoutId","cancel","deferId","cacheFactory","cacheId","entry","freshEnd","staleEnd","n","link","p","nextEntry","prevEntry","caches","size","stats","capacity","Number","MAX_VALUE","lruHash","lruEntry","removeAll","info","hasDirectives","Suffix","COMMENT_DIRECTIVE_REGEXP","CLASS_DIRECTIVE_REGEXP","MULTI_ROOT_TEMPLATE_ERROR","urlSanitizationWhitelist","registerDirective","directiveFactory","directives","priority","require","restrict","regexp","$compileNodes","transcludeFn","maxPriority","nodeValue","compositeLinkFn","compileNodes","cloneConnectFn","$linkNode","safeAddClass","nodeList","$rootElement","boundTranscludeFn","nodeLinkFn","childLinkFn","childScope","childTranscludeFn","stableNodeList","linkFns","$new","transclude","cloneFn","transcludeScope","$$transcluded","attrs","linkFnFound","Attributes","collectDirectives","applyDirectivesToNode","terminal","attrsMap","$attr","addDirective","directiveNormalize","nodeName_","nName","nAttrs","j","jj","specified","getAttribute","addAttrInterpolateDirective","addTextInterpolateDirective","byPriority","compileNode","templateAttrs","jqCollection","addLinkFns","pre","post","preLinkFns","postLinkFns","getControllers","retrievalMethod","optional","linkNode","linkFn","$$element","newIsolateScopeDirective","LOCAL_REGEXP","parentScope","definiton","scopeName","lastValue","parentGet","parentSet","attrName","mode","$$isolateBindings","$observe","$$observers","$$scope","assign","NON_ASSIGNABLE_MODEL_EXPRESSION","parentValue","controllerDirectives","$scope","$attrs","$transclude","directiveName","$template","transcludeDirective","directiveValue","terminalPriority","newScopeDirective","templateDirective","$compileNode","assertNoDuplicate","createComment","replaceWith","contents","denormalizeTemplate","newTemplateAttrs","mergeTemplateAttributes","templateUrl","compileTemplateUrl","tDirectives","srcAttr","dstAttr","$set","beforeTemplateNodeLinkFn","tAttrs","afterTemplateNodeLinkFn","afterTemplateChildLinkFn","linkQueue","beforeTemplateCompileNode","origAsyncDirective","derivedSyncDirective","success","tempTemplateAttrs","linkRootElement","beforeTemplateLinkNode","response","code","headers","ignoreChildLinkFn","rootElement","what","previousDirective","text","interpolateFn","bindings","$$inter","newNode","oldNode","parentNode","replaceChild","expando","$normalize","writeAttr","normalizedVal","booleanKey","urlSanitizationNode","setAttribute","listeners","startSymbol","endSymbol","PREFIX_REGEXP","controllers","register","mustHaveExpression","endIndex","exp","hasInterpolation","startSymbolLength","endSymbolLength","part","encodePath","segments","matchUrl","URL_MATCH","protocol","host","port","DEFAULT_PORTS","search","$$protocol","$$host","$$port","composeProtocolHostPort","pathPrefixFromBase","basePath","lastIndexOf","convertToHtml5Url","hashPrefix","convertToHashbangUrl","pathPrefix","LocationUrl","appBaseUrl","$$parse","newAbsoluteUrl","$$path","$$search","$$hash","$$compose","$$url","$$absUrl","$$rewriteAppUrl","absoluteLinkUrl","LocationHashbangUrl","HASH_MATCH","LocationHashbangInHtml5Url","baseExtra","locationGetter","property","locationGetterSetter","preprocess","html5Mode","afterLocationChange","oldUrl","$broadcast","absUrl","initUrl","initUrlParts","ctrlKey","metaKey","absHref","rewrittenUrl","newUrl","$$phase","$digest","changeCounter","currentReplace","$$replace","formatError","stack","sourceURL","line","consoleLog","console","logFn","log","arg1","arg2","lex","csp","chars","ch","was","lastCh","peek","isWhitespace","isIdent","isExpOperator","throwError","start","readNumber","number","peekCh","tokens","readIdent","lastDot","peekIndex","methodName","ident","token","OPERATORS","getterFn","setter","readString","quote","string","rawString","hex","rep","ESCAPE","ch2","fn2","parser","msg","peekToken","e1","e2","e3","e4","t","expect","consume","unaryFn","binaryFn","statements","filterChain","statement","_filterChain","expression","argsFn","fnInvoke","assignment","_assignment","logicalOR","logicalAND","equality","relational","additive","multiplicative","unary","primary","ZERO","arrayDeclaration","object","functionCall","objectIndex","fieldAccess","_fieldAccess","field","_objectIndex","indexFn","then","$$v","_functionCall","contextGetter","fnPtr","elementFns","keyValues","setValue","propertyObj","cspSafeGetterFn","key0","key1","key2","key3","key4","promise","pathVal","getterFnCache","pathKeys","pathKeysLength","Function","qFactory","nextTick","exceptionHandler","defaultCallback","defaultErrback","reject","promises","deferred","ref","resolve","pending","errback","wrappedCallback","wrappedErrback","when","done","routes","route","reloadOnSearch","redirectPath","redirectTo","otherwise","params","switchRouteMatcher","paramMatch","regex","re","lastMatchedIndex","lastIndex","updateRoute","parseRoute","current","$$route","pathParams","forceReload","interpolate","values","segment","segmentMatch","reload","$on","TTL","digestTtl","Scope","$id","$$watchers","$$nextSibling","$$prevSibling","$$childHead","$$childTail","$root","$$destroyed","$$asyncQueue","$$listeners","beginPhase","phase","clearPhase","compileToFn","initWatchVal","isolate","Child","child","watchExp","objectEquality","watcher","listenFn","newVal","oldVal","watch","watchers","asyncQueue","dirty","logIdx","logMsg","ttl","watchLog","$eval","expr","namedListeners","$emit","empty","targetScope","listenerArgs","currentScope","eventSupport","android","navigator","userAgent","documentMode","hasEvent","divElm","parseHeaders","parsed","headersGetter","headersObj","transformData","fns","isSuccess","status","JSON_START","JSON_END","PROTECTION_PREFIX","$config","transformResponse","transformRequest","common","Accept","X-Requested-With","Content-Type","providerResponseInterceptors","responseInterceptors","resp","respTransformFn","reqData","defHeaderName","lowercaseDefHeaderName","headerName","reqTransformFn","reqHeaders","defHeaders","X-XSRF-TOKEN","defaultHeadersIteration","header","sendReq","interceptor","createShortMethods","createShortMethodsWithData","headersString","resolvePromise","removePendingReq","idx","pendingRequests","cachedResp","buildUrl","defaultCache","withCredentials","createHttpBackend","XHR","$browserDefer","locationProtocol","jsonpReq","doneWrapper","onreadystatechange","readyState","onload","onerror","appendChild","completeRequest","callbackId","xhr","open","setRequestHeader","responseHeaders","getAllResponseHeaders","simpleHeaders","getResponseHeader","responseText","send","abort","NUMBER_FORMATS","DECIMAL_SEP","GROUP_SEP","PATTERNS","minInt","minFrac","maxFrac","posPre","posSuf","negPre","negSuf","gSize","lgSize","CURRENCY_SYM","DATETIME_FORMATS","MONTH","SHORTMONTH","DAY","SHORTDAY","AMPMS","medium","short","fullDate","longDate","mediumDate","shortDate","mediumTime","shortTime","pluralCat","num","invokeApply","skipApply","deferreds","$$timeoutId","suffix","currencyFilter","dateFilter","filterFilter","jsonFilter","limitToFilter","lowercaseFilter","numberFilter","orderByFilter","uppercaseFilter","predicates","objKey","filtered","$locale","formats","amount","currencySymbol","formatNumber","fractionSize","pattern","groupSep","decimalSep","isFinite","isNegative","numStr","formatedText","hasExponent","toFixed","fractionLen","min","pow","fraction","whole","lgroup","group","padNumber","digits","neg","dateGetter","date","dateStrGetter","shortForm","timeZoneGetter","zone","getTimezoneOffset","paddedZone","ampmGetter","getHours","jsonStringToDate","R_ISO8601_STR","tzHour","tzMin","setUTCFullYear","setUTCHours","format","NUMBER_STRING","DATE_FORMATS_SPLIT","DATE_FORMATS","limit","Array","out","sortPredicate","reverseOrder","comparator","comp","reverseComparator","descending","compare","v1","v2","predicate","arrayCopy","ngDirective","FormController","toggleValidCss","isValid","validationErrorKey","INVALID_CLASS","VALID_CLASS","parentForm","nullFormCtrl","invalidCount","errors","$error","$name","$dirty","$pristine","$valid","$invalid","$addControl","PRISTINE_CLASS","control","$removeControl","queue","validationToken","$setValidity","$setDirty","DIRTY_CLASS","isEmpty","textInputType","ctrl","$viewValue","$setViewValue","deferListener","keyCode","$render","patternValidator","ngPattern","validate","patternObj","$formatters","$parsers","ngMinlength","minlength","minLengthValidator","ngMaxlength","maxlength","maxLengthValidator","numberInputType","NUMBER_REGEXP","parseFloat","minValidator","maxValidator","urlInputType","urlValidator","URL_REGEXP","emailInputType","emailValidator","EMAIL_REGEXP","radioInputType","checked","checkboxInputType","trueValue","ngTrueValue","falseValue","ngFalseValue","classDirective","ngClassWatchAction","$index","classVal","k","old$index","mod","manualLowercase","s","manualUppercase","full","major","minor","dot","codeName","addEventListenerFn","addEventListener","attachEvent","removeEventListener","detachEvent","ready","fired","removeAttribute","currentStyle","lowercasedName","getNamedItem","ret","innerText","textContent","$dv","multiple","selected","dealoc","bindFn","eventFns","compareDocumentPosition","adown","bup","eventmap","mouseleave","mouseenter","related","unbind","replaceNode","insertBefore","nextSibling","prepend","wrapNode","after","newElement","condition","nextElementSibling","getElementsByTagName","eventName","PATH_MATCH","http","https","ftp","paramValue","null","true","false","+","-","*","/","%","^","=","==","!=","<",">","<=",">=","&&","||","&","|","!","f","r","'","\"","XMLHttpRequest","ActiveXObject","yyyy","yy","y","MMMM","MMM","MM","M","dd","HH","H","hh","mm","m","ss","EEEE","EEE","Z","propName","normalized","formDirectiveFactory","isNgForm","formElement","preventDefaultListener","parentFormCtrl","alias","inputType","email","radio","checkbox","hidden","submit","reset","NgModelController","NaN","$modelValue","$viewChangeListeners","ngModelGet","ngModelSet","formatters","ctrls","modelCtrl","formCtrl","validator","viewValue","CONSTANT_VALUE_REGEXP","tpl","tplAttr","$event","$compile","srcExp","onloadExp","autoScrollExp","autoscroll","clearContent","thisChangeId","BRACE","numberExp","count","whenExp","whens","whensExpFns","linker","iterStartElement","lhs","rhs","valueIdent","keyIdent","lastOrder","arrayBound","collection","cursor","nextOrder","$first","$last","$middle","newStyles","oldStyles","cases","selectedTransclude","selectedElement","selectedScope","watchExpr","change","caseElement","destroyLastScope","lastScope","update","NG_OPTIONS_REGEXP","nullModelCtrl","nullOption","unknownOption","optionsMap","ngModelCtrl","databound","ngModelCtrl_","nullOption_","unknownOption_","addOption","removeOption","hasOption","renderUnknownOption","unknownVal","Single","selectElement","selectCtrl","emptyOption","Multiple","lastView","items","Options","render","optionGroupName","optionGroup","existingParent","existingOptions","existingOption","groupLength","groupIndex","lastElement","label","optionGroups","optionGroupNames","modelValue","valuesFn","keyName","selectedSet","valueName","groupByFn","displayFn","optionGroupsCache","optGroupTemplate","optionTemplate","optionsExp","optionElement","requiredValidator","nullSelectCtrl","selectCtrlName","c","conjunction","none","optionType","g","opened","nlSelect","getLabels","getSelected","isSelected","placeholder","subline","showSubline","Sage","finalize","home","about_us","UTIL","fire","func","funcname","namespace","loadEvents","classnm"],"mappings":"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","file":"main.js","sourcesContent":["/* ========================================================================\n * Bootstrap: transition.js v3.3.4\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap')\n\n    var transEndEventNames = {\n      WebkitTransition : 'webkitTransitionEnd',\n      MozTransition    : 'transitionend',\n      OTransition      : 'oTransitionEnd otransitionend',\n      transition       : 'transitionend'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one('bsTransitionEnd', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: alert.js v3.3.4\n * http://getbootstrap.com/javascript/#alerts\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // ALERT CLASS DEFINITION\n  // ======================\n\n  var dismiss = '[data-dismiss=\"alert\"]'\n  var Alert   = function (el) {\n    $(el).on('click', dismiss, this.close)\n  }\n\n  Alert.VERSION = '3.3.4'\n\n  Alert.TRANSITION_DURATION = 150\n\n  Alert.prototype.close = function (e) {\n    var $this    = $(this)\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = $(selector)\n\n    if (e) e.preventDefault()\n\n    if (!$parent.length) {\n      $parent = $this.closest('.alert')\n    }\n\n    $parent.trigger(e = $.Event('close.bs.alert'))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent.removeClass('in')\n\n    function removeElement() {\n      // detach from parent, fire event then clean up data\n      $parent.detach().trigger('closed.bs.alert').remove()\n    }\n\n    $.support.transition && $parent.hasClass('fade') ?\n      $parent\n        .one('bsTransitionEnd', removeElement)\n        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\n      removeElement()\n  }\n\n\n  // ALERT PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.alert')\n\n      if (!data) $this.data('bs.alert', (data = new Alert(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.alert\n\n  $.fn.alert             = Plugin\n  $.fn.alert.Constructor = Alert\n\n\n  // ALERT NO CONFLICT\n  // =================\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old\n    return this\n  }\n\n\n  // ALERT DATA-API\n  // ==============\n\n  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: button.js v3.3.4\n * http://getbootstrap.com/javascript/#buttons\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // BUTTON PUBLIC CLASS DEFINITION\n  // ==============================\n\n  var Button = function (element, options) {\n    this.$element  = $(element)\n    this.options   = $.extend({}, Button.DEFAULTS, options)\n    this.isLoading = false\n  }\n\n  Button.VERSION  = '3.3.4'\n\n  Button.DEFAULTS = {\n    loadingText: 'loading...'\n  }\n\n  Button.prototype.setState = function (state) {\n    var d    = 'disabled'\n    var $el  = this.$element\n    var val  = $el.is('input') ? 'val' : 'html'\n    var data = $el.data()\n\n    state = state + 'Text'\n\n    if (data.resetText == null) $el.data('resetText', $el[val]())\n\n    // push to event loop to allow forms to submit\n    setTimeout($.proxy(function () {\n      $el[val](data[state] == null ? this.options[state] : data[state])\n\n      if (state == 'loadingText') {\n        this.isLoading = true\n        $el.addClass(d).attr(d, d)\n      } else if (this.isLoading) {\n        this.isLoading = false\n        $el.removeClass(d).removeAttr(d)\n      }\n    }, this), 0)\n  }\n\n  Button.prototype.toggle = function () {\n    var changed = true\n    var $parent = this.$element.closest('[data-toggle=\"buttons\"]')\n\n    if ($parent.length) {\n      var $input = this.$element.find('input')\n      if ($input.prop('type') == 'radio') {\n        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false\n        else $parent.find('.active').removeClass('active')\n      }\n      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')\n    } else {\n      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))\n    }\n\n    if (changed) this.$element.toggleClass('active')\n  }\n\n\n  // BUTTON PLUGIN DEFINITION\n  // ========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.button')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.button', (data = new Button(this, options)))\n\n      if (option == 'toggle') data.toggle()\n      else if (option) data.setState(option)\n    })\n  }\n\n  var old = $.fn.button\n\n  $.fn.button             = Plugin\n  $.fn.button.Constructor = Button\n\n\n  // BUTTON NO CONFLICT\n  // ==================\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old\n    return this\n  }\n\n\n  // BUTTON DATA-API\n  // ===============\n\n  $(document)\n    .on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      var $btn = $(e.target)\n      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')\n      Plugin.call($btn, 'toggle')\n      e.preventDefault()\n    })\n    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))\n    })\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: carousel.js v3.3.4\n * http://getbootstrap.com/javascript/#carousel\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CAROUSEL CLASS DEFINITION\n  // =========================\n\n  var Carousel = function (element, options) {\n    this.$element    = $(element)\n    this.$indicators = this.$element.find('.carousel-indicators')\n    this.options     = options\n    this.paused      = null\n    this.sliding     = null\n    this.interval    = null\n    this.$active     = null\n    this.$items      = null\n\n    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))\n\n    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element\n      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))\n      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))\n  }\n\n  Carousel.VERSION  = '3.3.4'\n\n  Carousel.TRANSITION_DURATION = 600\n\n  Carousel.DEFAULTS = {\n    interval: 5000,\n    pause: 'hover',\n    wrap: true,\n    keyboard: true\n  }\n\n  Carousel.prototype.keydown = function (e) {\n    if (/input|textarea/i.test(e.target.tagName)) return\n    switch (e.which) {\n      case 37: this.prev(); break\n      case 39: this.next(); break\n      default: return\n    }\n\n    e.preventDefault()\n  }\n\n  Carousel.prototype.cycle = function (e) {\n    e || (this.paused = false)\n\n    this.interval && clearInterval(this.interval)\n\n    this.options.interval\n      && !this.paused\n      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\n\n    return this\n  }\n\n  Carousel.prototype.getItemIndex = function (item) {\n    this.$items = item.parent().children('.item')\n    return this.$items.index(item || this.$active)\n  }\n\n  Carousel.prototype.getItemForDirection = function (direction, active) {\n    var activeIndex = this.getItemIndex(active)\n    var willWrap = (direction == 'prev' && activeIndex === 0)\n                || (direction == 'next' && activeIndex == (this.$items.length - 1))\n    if (willWrap && !this.options.wrap) return active\n    var delta = direction == 'prev' ? -1 : 1\n    var itemIndex = (activeIndex + delta) % this.$items.length\n    return this.$items.eq(itemIndex)\n  }\n\n  Carousel.prototype.to = function (pos) {\n    var that        = this\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))\n\n    if (pos > (this.$items.length - 1) || pos < 0) return\n\n    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, \"slid\"\n    if (activeIndex == pos) return this.pause().cycle()\n\n    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))\n  }\n\n  Carousel.prototype.pause = function (e) {\n    e || (this.paused = true)\n\n    if (this.$element.find('.next, .prev').length && $.support.transition) {\n      this.$element.trigger($.support.transition.end)\n      this.cycle(true)\n    }\n\n    this.interval = clearInterval(this.interval)\n\n    return this\n  }\n\n  Carousel.prototype.next = function () {\n    if (this.sliding) return\n    return this.slide('next')\n  }\n\n  Carousel.prototype.prev = function () {\n    if (this.sliding) return\n    return this.slide('prev')\n  }\n\n  Carousel.prototype.slide = function (type, next) {\n    var $active   = this.$element.find('.item.active')\n    var $next     = next || this.getItemForDirection(type, $active)\n    var isCycling = this.interval\n    var direction = type == 'next' ? 'left' : 'right'\n    var that      = this\n\n    if ($next.hasClass('active')) return (this.sliding = false)\n\n    var relatedTarget = $next[0]\n    var slideEvent = $.Event('slide.bs.carousel', {\n      relatedTarget: relatedTarget,\n      direction: direction\n    })\n    this.$element.trigger(slideEvent)\n    if (slideEvent.isDefaultPrevented()) return\n\n    this.sliding = true\n\n    isCycling && this.pause()\n\n    if (this.$indicators.length) {\n      this.$indicators.find('.active').removeClass('active')\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\n      $nextIndicator && $nextIndicator.addClass('active')\n    }\n\n    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, \"slid\"\n    if ($.support.transition && this.$element.hasClass('slide')) {\n      $next.addClass(type)\n      $next[0].offsetWidth // force reflow\n      $active.addClass(direction)\n      $next.addClass(direction)\n      $active\n        .one('bsTransitionEnd', function () {\n          $next.removeClass([type, direction].join(' ')).addClass('active')\n          $active.removeClass(['active', direction].join(' '))\n          that.sliding = false\n          setTimeout(function () {\n            that.$element.trigger(slidEvent)\n          }, 0)\n        })\n        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\n    } else {\n      $active.removeClass('active')\n      $next.addClass('active')\n      this.sliding = false\n      this.$element.trigger(slidEvent)\n    }\n\n    isCycling && this.cycle()\n\n    return this\n  }\n\n\n  // CAROUSEL PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.carousel')\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)\n      var action  = typeof option == 'string' ? option : options.slide\n\n      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))\n      if (typeof option == 'number') data.to(option)\n      else if (action) data[action]()\n      else if (options.interval) data.pause().cycle()\n    })\n  }\n\n  var old = $.fn.carousel\n\n  $.fn.carousel             = Plugin\n  $.fn.carousel.Constructor = Carousel\n\n\n  // CAROUSEL NO CONFLICT\n  // ====================\n\n  $.fn.carousel.noConflict = function () {\n    $.fn.carousel = old\n    return this\n  }\n\n\n  // CAROUSEL DATA-API\n  // =================\n\n  var clickHandler = function (e) {\n    var href\n    var $this   = $(this)\n    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')) // strip for ie7\n    if (!$target.hasClass('carousel')) return\n    var options = $.extend({}, $target.data(), $this.data())\n    var slideIndex = $this.attr('data-slide-to')\n    if (slideIndex) options.interval = false\n\n    Plugin.call($target, options)\n\n    if (slideIndex) {\n      $target.data('bs.carousel').to(slideIndex)\n    }\n\n    e.preventDefault()\n  }\n\n  $(document)\n    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)\n    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)\n\n  $(window).on('load', function () {\n    $('[data-ride=\"carousel\"]').each(function () {\n      var $carousel = $(this)\n      Plugin.call($carousel, $carousel.data())\n    })\n  })\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: collapse.js v3.3.4\n * http://getbootstrap.com/javascript/#collapse\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // COLLAPSE PUBLIC CLASS DEFINITION\n  // ================================\n\n  var Collapse = function (element, options) {\n    this.$element      = $(element)\n    this.options       = $.extend({}, Collapse.DEFAULTS, options)\n    this.$trigger      = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' +\n                           '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]')\n    this.transitioning = null\n\n    if (this.options.parent) {\n      this.$parent = this.getParent()\n    } else {\n      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\n    }\n\n    if (this.options.toggle) this.toggle()\n  }\n\n  Collapse.VERSION  = '3.3.4'\n\n  Collapse.TRANSITION_DURATION = 350\n\n  Collapse.DEFAULTS = {\n    toggle: true\n  }\n\n  Collapse.prototype.dimension = function () {\n    var hasWidth = this.$element.hasClass('width')\n    return hasWidth ? 'width' : 'height'\n  }\n\n  Collapse.prototype.show = function () {\n    if (this.transitioning || this.$element.hasClass('in')) return\n\n    var activesData\n    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')\n\n    if (actives && actives.length) {\n      activesData = actives.data('bs.collapse')\n      if (activesData && activesData.transitioning) return\n    }\n\n    var startEvent = $.Event('show.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    if (actives && actives.length) {\n      Plugin.call(actives, 'hide')\n      activesData || actives.data('bs.collapse', null)\n    }\n\n    var dimension = this.dimension()\n\n    this.$element\n      .removeClass('collapse')\n      .addClass('collapsing')[dimension](0)\n      .attr('aria-expanded', true)\n\n    this.$trigger\n      .removeClass('collapsed')\n      .attr('aria-expanded', true)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse in')[dimension]('')\n      this.transitioning = 0\n      this.$element\n        .trigger('shown.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    var scrollSize = $.camelCase(['scroll', dimension].join('-'))\n\n    this.$element\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\n  }\n\n  Collapse.prototype.hide = function () {\n    if (this.transitioning || !this.$element.hasClass('in')) return\n\n    var startEvent = $.Event('hide.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    var dimension = this.dimension()\n\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\n\n    this.$element\n      .addClass('collapsing')\n      .removeClass('collapse in')\n      .attr('aria-expanded', false)\n\n    this.$trigger\n      .addClass('collapsed')\n      .attr('aria-expanded', false)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.transitioning = 0\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse')\n        .trigger('hidden.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    this.$element\n      [dimension](0)\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\n  }\n\n  Collapse.prototype.toggle = function () {\n    this[this.$element.hasClass('in') ? 'hide' : 'show']()\n  }\n\n  Collapse.prototype.getParent = function () {\n    return $(this.options.parent)\n      .find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]')\n      .each($.proxy(function (i, element) {\n        var $element = $(element)\n        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\n      }, this))\n      .end()\n  }\n\n  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\n    var isOpen = $element.hasClass('in')\n\n    $element.attr('aria-expanded', isOpen)\n    $trigger\n      .toggleClass('collapsed', !isOpen)\n      .attr('aria-expanded', isOpen)\n  }\n\n  function getTargetFromTrigger($trigger) {\n    var href\n    var target = $trigger.attr('data-target')\n      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '') // strip for ie7\n\n    return $(target)\n  }\n\n\n  // COLLAPSE PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.collapse')\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\n      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.collapse\n\n  $.fn.collapse             = Plugin\n  $.fn.collapse.Constructor = Collapse\n\n\n  // COLLAPSE NO CONFLICT\n  // ====================\n\n  $.fn.collapse.noConflict = function () {\n    $.fn.collapse = old\n    return this\n  }\n\n\n  // COLLAPSE DATA-API\n  // =================\n\n  $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\n    var $this   = $(this)\n\n    if (!$this.attr('data-target')) e.preventDefault()\n\n    var $target = getTargetFromTrigger($this)\n    var data    = $target.data('bs.collapse')\n    var option  = data ? 'toggle' : $this.data()\n\n    Plugin.call($target, option)\n  })\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: dropdown.js v3.3.4\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.3.4'\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $('<div class=\"dropdown-backdrop\"/>').insertAfter($(this)).on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger('shown.bs.dropdown', relatedTarget)\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.disabled):visible a'\n    var $items = $parent.find('[role=\"menu\"]' + desc + ', [role=\"listbox\"]' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--                        // up\n    if (e.which == 40 && index < $items.length - 1) index++                        // down\n    if (!~index)                                      index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)\n    })\n  }\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '[role=\"menu\"]', Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '[role=\"listbox\"]', Dropdown.prototype.keydown)\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: modal.js v3.3.4\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  var Modal = function (element, options) {\n    this.options             = options\n    this.$body               = $(document.body)\n    this.$element            = $(element)\n    this.$dialog             = this.$element.find('.modal-dialog')\n    this.$backdrop           = null\n    this.isShown             = null\n    this.originalBodyPad     = null\n    this.scrollbarWidth      = 0\n    this.ignoreBackdropClick = false\n\n    if (this.options.remote) {\n      this.$element\n        .find('.modal-content')\n        .load(this.options.remote, $.proxy(function () {\n          this.$element.trigger('loaded.bs.modal')\n        }, this))\n    }\n  }\n\n  Modal.VERSION  = '3.3.4'\n\n  Modal.TRANSITION_DURATION = 300\n  Modal.BACKDROP_TRANSITION_DURATION = 150\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  }\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\n  }\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this\n    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })\n\n    this.$element.trigger(e)\n\n    if (this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = true\n\n    this.checkScrollbar()\n    this.setScrollbar()\n    this.$body.addClass('modal-open')\n\n    this.escape()\n    this.resize()\n\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this))\n\n    this.$dialog.on('mousedown.dismiss.bs.modal', function () {\n      that.$element.one('mouseup.dismiss.bs.modal', function (e) {\n        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\n      })\n    })\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass('fade')\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body) // don't move modals dom position\n      }\n\n      that.$element\n        .show()\n        .scrollTop(0)\n\n      that.adjustDialog()\n\n      if (transition) {\n        that.$element[0].offsetWidth // force reflow\n      }\n\n      that.$element\n        .addClass('in')\n        .attr('aria-hidden', false)\n\n      that.enforceFocus()\n\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })\n\n      transition ?\n        that.$dialog // wait for modal to slide in\n          .one('bsTransitionEnd', function () {\n            that.$element.trigger('focus').trigger(e)\n          })\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n        that.$element.trigger('focus').trigger(e)\n    })\n  }\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault()\n\n    e = $.Event('hide.bs.modal')\n\n    this.$element.trigger(e)\n\n    if (!this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = false\n\n    this.escape()\n    this.resize()\n\n    $(document).off('focusin.bs.modal')\n\n    this.$element\n      .removeClass('in')\n      .attr('aria-hidden', true)\n      .off('click.dismiss.bs.modal')\n      .off('mouseup.dismiss.bs.modal')\n\n    this.$dialog.off('mousedown.dismiss.bs.modal')\n\n    $.support.transition && this.$element.hasClass('fade') ?\n      this.$element\n        .one('bsTransitionEnd', $.proxy(this.hideModal, this))\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n      this.hideModal()\n  }\n\n  Modal.prototype.enforceFocus = function () {\n    $(document)\n      .off('focusin.bs.modal') // guard against infinite focus loop\n      .on('focusin.bs.modal', $.proxy(function (e) {\n        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {\n          this.$element.trigger('focus')\n        }\n      }, this))\n  }\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\n        e.which == 27 && this.hide()\n      }, this))\n    } else if (!this.isShown) {\n      this.$element.off('keydown.dismiss.bs.modal')\n    }\n  }\n\n  Modal.prototype.resize = function () {\n    if (this.isShown) {\n      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))\n    } else {\n      $(window).off('resize.bs.modal')\n    }\n  }\n\n  Modal.prototype.hideModal = function () {\n    var that = this\n    this.$element.hide()\n    this.backdrop(function () {\n      that.$body.removeClass('modal-open')\n      that.resetAdjustments()\n      that.resetScrollbar()\n      that.$element.trigger('hidden.bs.modal')\n    })\n  }\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this\n    var animate = this.$element.hasClass('fade') ? 'fade' : ''\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />')\n        .appendTo(this.$body)\n\n      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\n        if (this.ignoreBackdropClick) {\n          this.ignoreBackdropClick = false\n          return\n        }\n        if (e.target !== e.currentTarget) return\n        this.options.backdrop == 'static'\n          ? this.$element[0].focus()\n          : this.hide()\n      }, this))\n\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n      this.$backdrop.addClass('in')\n\n      if (!callback) return\n\n      doAnimate ?\n        this.$backdrop\n          .one('bsTransitionEnd', callback)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callback()\n\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass('in')\n\n      var callbackRemove = function () {\n        that.removeBackdrop()\n        callback && callback()\n      }\n      $.support.transition && this.$element.hasClass('fade') ?\n        this.$backdrop\n          .one('bsTransitionEnd', callbackRemove)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callbackRemove()\n\n    } else if (callback) {\n      callback()\n    }\n  }\n\n  // these following methods are used to handle overflowing modals\n\n  Modal.prototype.handleUpdate = function () {\n    this.adjustDialog()\n  }\n\n  Modal.prototype.adjustDialog = function () {\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\n\n    this.$element.css({\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\n    })\n  }\n\n  Modal.prototype.resetAdjustments = function () {\n    this.$element.css({\n      paddingLeft: '',\n      paddingRight: ''\n    })\n  }\n\n  Modal.prototype.checkScrollbar = function () {\n    var fullWindowWidth = window.innerWidth\n    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n      var documentElementRect = document.documentElement.getBoundingClientRect()\n      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\n    }\n    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth\n    this.scrollbarWidth = this.measureScrollbar()\n  }\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)\n    this.originalBodyPad = document.body.style.paddingRight || ''\n    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)\n  }\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css('padding-right', this.originalBodyPad)\n  }\n\n  Modal.prototype.measureScrollbar = function () { // thx walsh\n    var scrollDiv = document.createElement('div')\n    scrollDiv.className = 'modal-scrollbar-measure'\n    this.$body.append(scrollDiv)\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n    this.$body[0].removeChild(scrollDiv)\n    return scrollbarWidth\n  }\n\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.modal')\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))\n      if (typeof option == 'string') data[option](_relatedTarget)\n      else if (options.show) data.show(_relatedTarget)\n    })\n  }\n\n  var old = $.fn.modal\n\n  $.fn.modal             = Plugin\n  $.fn.modal.Constructor = Modal\n\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this   = $(this)\n    var href    = $this.attr('href')\n    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7\n    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\n\n    if ($this.is('a')) e.preventDefault()\n\n    $target.one('show.bs.modal', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\n      $target.one('hidden.bs.modal', function () {\n        $this.is(':visible') && $this.trigger('focus')\n      })\n    })\n    Plugin.call($target, option, this)\n  })\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: tooltip.js v3.3.4\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Tooltip = function (element, options) {\n    this.type       = null\n    this.options    = null\n    this.enabled    = null\n    this.timeout    = null\n    this.hoverState = null\n    this.$element   = null\n\n    this.init('tooltip', element, options)\n  }\n\n  Tooltip.VERSION  = '3.3.4'\n\n  Tooltip.TRANSITION_DURATION = 150\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: 'top',\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: 'body',\n      padding: 0\n    }\n  }\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled   = true\n    this.type      = type\n    this.$element  = $(element)\n    this.options   = this.getOptions(options)\n    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)\n\n    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\n      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')\n    }\n\n    var triggers = this.options.trigger.split(' ')\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i]\n\n      if (trigger == 'click') {\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))\n      } else if (trigger != 'manual') {\n        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'\n\n        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))\n      }\n    }\n\n    this.options.selector ?\n      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :\n      this.fixTitle()\n  }\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS\n  }\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\n\n    if (options.delay && typeof options.delay == 'number') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      }\n    }\n\n    return options\n  }\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options  = {}\n    var defaults = this.getDefaults()\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value\n    })\n\n    return options\n  }\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (self && self.$tip && self.$tip.is(':visible')) {\n      self.hoverState = 'in'\n      return\n    }\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'in'\n\n    if (!self.options.delay || !self.options.delay.show) return self.show()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'in') self.show()\n    }, self.options.delay.show)\n  }\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'out'\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'out') self.hide()\n    }, self.options.delay.hide)\n  }\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event('show.bs.' + this.type)\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e)\n\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n      if (e.isDefaultPrevented() || !inDom) return\n      var that = this\n\n      var $tip = this.tip()\n\n      var tipId = this.getUID(this.type)\n\n      this.setContent()\n      $tip.attr('id', tipId)\n      this.$element.attr('aria-describedby', tipId)\n\n      if (this.options.animation) $tip.addClass('fade')\n\n      var placement = typeof this.options.placement == 'function' ?\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\n        this.options.placement\n\n      var autoToken = /\\s?auto?\\s?/i\n      var autoPlace = autoToken.test(placement)\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\n\n      $tip\n        .detach()\n        .css({ top: 0, left: 0, display: 'block' })\n        .addClass(placement)\n        .data('bs.' + this.type, this)\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\n\n      var pos          = this.getPosition()\n      var actualWidth  = $tip[0].offsetWidth\n      var actualHeight = $tip[0].offsetHeight\n\n      if (autoPlace) {\n        var orgPlacement = placement\n        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()\n        var containerDim = this.getPosition($container)\n\n        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :\n                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :\n                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :\n                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :\n                    placement\n\n        $tip\n          .removeClass(orgPlacement)\n          .addClass(placement)\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\n\n      this.applyPlacement(calculatedOffset, placement)\n\n      var complete = function () {\n        var prevHoverState = that.hoverState\n        that.$element.trigger('shown.bs.' + that.type)\n        that.hoverState = null\n\n        if (prevHoverState == 'out') that.leave(that)\n      }\n\n      $.support.transition && this.$tip.hasClass('fade') ?\n        $tip\n          .one('bsTransitionEnd', complete)\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n        complete()\n    }\n  }\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip   = this.tip()\n    var width  = $tip[0].offsetWidth\n    var height = $tip[0].offsetHeight\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css('margin-top'), 10)\n    var marginLeft = parseInt($tip.css('margin-left'), 10)\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop))  marginTop  = 0\n    if (isNaN(marginLeft)) marginLeft = 0\n\n    offset.top  = offset.top  + marginTop\n    offset.left = offset.left + marginLeft\n\n    // $.fn.offset doesn't round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function (props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        })\n      }\n    }, offset), 0)\n\n    $tip.addClass('in')\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth  = $tip[0].offsetWidth\n    var actualHeight = $tip[0].offsetHeight\n\n    if (placement == 'top' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\n\n    if (delta.left) offset.left += delta.left\n    else offset.top += delta.top\n\n    var isVertical          = /top|bottom/.test(placement)\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\n    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'\n\n    $tip.offset(offset)\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\n  }\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\n    this.arrow()\n      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n      .css(isVertical ? 'top' : 'left', '')\n  }\n\n  Tooltip.prototype.setContent = function () {\n    var $tip  = this.tip()\n    var title = this.getTitle()\n\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)\n    $tip.removeClass('fade in top bottom left right')\n  }\n\n  Tooltip.prototype.hide = function (callback) {\n    var that = this\n    var $tip = $(this.$tip)\n    var e    = $.Event('hide.bs.' + this.type)\n\n    function complete() {\n      if (that.hoverState != 'in') $tip.detach()\n      that.$element\n        .removeAttr('aria-describedby')\n        .trigger('hidden.bs.' + that.type)\n      callback && callback()\n    }\n\n    this.$element.trigger(e)\n\n    if (e.isDefaultPrevented()) return\n\n    $tip.removeClass('in')\n\n    $.support.transition && $tip.hasClass('fade') ?\n      $tip\n        .one('bsTransitionEnd', complete)\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n      complete()\n\n    this.hoverState = null\n\n    return this\n  }\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element\n    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')\n    }\n  }\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle()\n  }\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element   = $element || this.$element\n\n    var el     = $element[0]\n    var isBody = el.tagName == 'BODY'\n\n    var elRect    = el.getBoundingClientRect()\n    if (elRect.width == null) {\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\n    }\n    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\n\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\n  }\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\n\n  }\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 }\n    if (!this.$viewport) return delta\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\n    var viewportDimensions = this.getPosition(this.$viewport)\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\n      }\n    } else {\n      var leftEdgeOffset  = pos.left - viewportPadding\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset\n      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\n      }\n    }\n\n    return delta\n  }\n\n  Tooltip.prototype.getTitle = function () {\n    var title\n    var $e = this.$element\n    var o  = this.options\n\n    title = $e.attr('data-original-title')\n      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)\n\n    return title\n  }\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do prefix += ~~(Math.random() * 1000000)\n    while (document.getElementById(prefix))\n    return prefix\n  }\n\n  Tooltip.prototype.tip = function () {\n    return (this.$tip = this.$tip || $(this.options.template))\n  }\n\n  Tooltip.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\n  }\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true\n  }\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false\n  }\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled\n  }\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this\n    if (e) {\n      self = $(e.currentTarget).data('bs.' + this.type)\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\n        $(e.currentTarget).data('bs.' + this.type, self)\n      }\n    }\n\n    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)\n  }\n\n  Tooltip.prototype.destroy = function () {\n    var that = this\n    clearTimeout(this.timeout)\n    this.hide(function () {\n      that.$element.off('.' + that.type).removeData('bs.' + that.type)\n    })\n  }\n\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.tooltip')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tooltip\n\n  $.fn.tooltip             = Plugin\n  $.fn.tooltip.Constructor = Tooltip\n\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old\n    return this\n  }\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: popover.js v3.3.4\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Popover = function (element, options) {\n    this.init('popover', element, options)\n  }\n\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')\n\n  Popover.VERSION  = '3.3.4'\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n  })\n\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\n\n  Popover.prototype.constructor = Popover\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS\n  }\n\n  Popover.prototype.setContent = function () {\n    var $tip    = this.tip()\n    var title   = this.getTitle()\n    var content = this.getContent()\n\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)\n    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events\n      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'\n    ](content)\n\n    $tip.removeClass('fade top bottom left right in')\n\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()\n  }\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent()\n  }\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element\n    var o  = this.options\n\n    return $e.attr('data-content')\n      || (typeof o.content == 'function' ?\n            o.content.call($e[0]) :\n            o.content)\n  }\n\n  Popover.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\n  }\n\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.popover')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.popover\n\n  $.fn.popover             = Plugin\n  $.fn.popover.Constructor = Popover\n\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old\n    return this\n  }\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: scrollspy.js v3.3.4\n * http://getbootstrap.com/javascript/#scrollspy\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // SCROLLSPY CLASS DEFINITION\n  // ==========================\n\n  function ScrollSpy(element, options) {\n    this.$body          = $(document.body)\n    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\n    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\n    this.selector       = (this.options.target || '') + ' .nav li > a'\n    this.offsets        = []\n    this.targets        = []\n    this.activeTarget   = null\n    this.scrollHeight   = 0\n\n    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))\n    this.refresh()\n    this.process()\n  }\n\n  ScrollSpy.VERSION  = '3.3.4'\n\n  ScrollSpy.DEFAULTS = {\n    offset: 10\n  }\n\n  ScrollSpy.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\n  }\n\n  ScrollSpy.prototype.refresh = function () {\n    var that          = this\n    var offsetMethod  = 'offset'\n    var offsetBase    = 0\n\n    this.offsets      = []\n    this.targets      = []\n    this.scrollHeight = this.getScrollHeight()\n\n    if (!$.isWindow(this.$scrollElement[0])) {\n      offsetMethod = 'position'\n      offsetBase   = this.$scrollElement.scrollTop()\n    }\n\n    this.$body\n      .find(this.selector)\n      .map(function () {\n        var $el   = $(this)\n        var href  = $el.data('target') || $el.attr('href')\n        var $href = /^#./.test(href) && $(href)\n\n        return ($href\n          && $href.length\n          && $href.is(':visible')\n          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\n      })\n      .sort(function (a, b) { return a[0] - b[0] })\n      .each(function () {\n        that.offsets.push(this[0])\n        that.targets.push(this[1])\n      })\n  }\n\n  ScrollSpy.prototype.process = function () {\n    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\n    var scrollHeight = this.getScrollHeight()\n    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\n    var offsets      = this.offsets\n    var targets      = this.targets\n    var activeTarget = this.activeTarget\n    var i\n\n    if (this.scrollHeight != scrollHeight) {\n      this.refresh()\n    }\n\n    if (scrollTop >= maxScroll) {\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\n    }\n\n    if (activeTarget && scrollTop < offsets[0]) {\n      this.activeTarget = null\n      return this.clear()\n    }\n\n    for (i = offsets.length; i--;) {\n      activeTarget != targets[i]\n        && scrollTop >= offsets[i]\n        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])\n        && this.activate(targets[i])\n    }\n  }\n\n  ScrollSpy.prototype.activate = function (target) {\n    this.activeTarget = target\n\n    this.clear()\n\n    var selector = this.selector +\n      '[data-target=\"' + target + '\"],' +\n      this.selector + '[href=\"' + target + '\"]'\n\n    var active = $(selector)\n      .parents('li')\n      .addClass('active')\n\n    if (active.parent('.dropdown-menu').length) {\n      active = active\n        .closest('li.dropdown')\n        .addClass('active')\n    }\n\n    active.trigger('activate.bs.scrollspy')\n  }\n\n  ScrollSpy.prototype.clear = function () {\n    $(this.selector)\n      .parentsUntil(this.options.target, '.active')\n      .removeClass('active')\n  }\n\n\n  // SCROLLSPY PLUGIN DEFINITION\n  // ===========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.scrollspy')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.scrollspy\n\n  $.fn.scrollspy             = Plugin\n  $.fn.scrollspy.Constructor = ScrollSpy\n\n\n  // SCROLLSPY NO CONFLICT\n  // =====================\n\n  $.fn.scrollspy.noConflict = function () {\n    $.fn.scrollspy = old\n    return this\n  }\n\n\n  // SCROLLSPY DATA-API\n  // ==================\n\n  $(window).on('load.bs.scrollspy.data-api', function () {\n    $('[data-spy=\"scroll\"]').each(function () {\n      var $spy = $(this)\n      Plugin.call($spy, $spy.data())\n    })\n  })\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: tab.js v3.3.4\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TAB CLASS DEFINITION\n  // ====================\n\n  var Tab = function (element) {\n    this.element = $(element)\n  }\n\n  Tab.VERSION = '3.3.4'\n\n  Tab.TRANSITION_DURATION = 150\n\n  Tab.prototype.show = function () {\n    var $this    = this.element\n    var $ul      = $this.closest('ul:not(.dropdown-menu)')\n    var selector = $this.data('target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    if ($this.parent('li').hasClass('active')) return\n\n    var $previous = $ul.find('.active:last a')\n    var hideEvent = $.Event('hide.bs.tab', {\n      relatedTarget: $this[0]\n    })\n    var showEvent = $.Event('show.bs.tab', {\n      relatedTarget: $previous[0]\n    })\n\n    $previous.trigger(hideEvent)\n    $this.trigger(showEvent)\n\n    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\n\n    var $target = $(selector)\n\n    this.activate($this.closest('li'), $ul)\n    this.activate($target, $target.parent(), function () {\n      $previous.trigger({\n        type: 'hidden.bs.tab',\n        relatedTarget: $this[0]\n      })\n      $this.trigger({\n        type: 'shown.bs.tab',\n        relatedTarget: $previous[0]\n      })\n    })\n  }\n\n  Tab.prototype.activate = function (element, container, callback) {\n    var $active    = container.find('> .active')\n    var transition = callback\n      && $.support.transition\n      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)\n\n    function next() {\n      $active\n        .removeClass('active')\n        .find('> .dropdown-menu > .active')\n          .removeClass('active')\n        .end()\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', false)\n\n      element\n        .addClass('active')\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', true)\n\n      if (transition) {\n        element[0].offsetWidth // reflow for transition\n        element.addClass('in')\n      } else {\n        element.removeClass('fade')\n      }\n\n      if (element.parent('.dropdown-menu').length) {\n        element\n          .closest('li.dropdown')\n            .addClass('active')\n          .end()\n          .find('[data-toggle=\"tab\"]')\n            .attr('aria-expanded', true)\n      }\n\n      callback && callback()\n    }\n\n    $active.length && transition ?\n      $active\n        .one('bsTransitionEnd', next)\n        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\n      next()\n\n    $active.removeClass('in')\n  }\n\n\n  // TAB PLUGIN DEFINITION\n  // =====================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.tab')\n\n      if (!data) $this.data('bs.tab', (data = new Tab(this)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tab\n\n  $.fn.tab             = Plugin\n  $.fn.tab.Constructor = Tab\n\n\n  // TAB NO CONFLICT\n  // ===============\n\n  $.fn.tab.noConflict = function () {\n    $.fn.tab = old\n    return this\n  }\n\n\n  // TAB DATA-API\n  // ============\n\n  var clickHandler = function (e) {\n    e.preventDefault()\n    Plugin.call($(this), 'show')\n  }\n\n  $(document)\n    .on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler)\n    .on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler)\n\n}(jQuery);\n","/* ========================================================================\n * Bootstrap: affix.js v3.3.4\n * http://getbootstrap.com/javascript/#affix\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // AFFIX CLASS DEFINITION\n  // ======================\n\n  var Affix = function (element, options) {\n    this.options = $.extend({}, Affix.DEFAULTS, options)\n\n    this.$target = $(this.options.target)\n      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))\n      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))\n\n    this.$element     = $(element)\n    this.affixed      = null\n    this.unpin        = null\n    this.pinnedOffset = null\n\n    this.checkPosition()\n  }\n\n  Affix.VERSION  = '3.3.4'\n\n  Affix.RESET    = 'affix affix-top affix-bottom'\n\n  Affix.DEFAULTS = {\n    offset: 0,\n    target: window\n  }\n\n  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\n    var scrollTop    = this.$target.scrollTop()\n    var position     = this.$element.offset()\n    var targetHeight = this.$target.height()\n\n    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false\n\n    if (this.affixed == 'bottom') {\n      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'\n      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'\n    }\n\n    var initializing   = this.affixed == null\n    var colliderTop    = initializing ? scrollTop : position.top\n    var colliderHeight = initializing ? targetHeight : height\n\n    if (offsetTop != null && scrollTop <= offsetTop) return 'top'\n    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'\n\n    return false\n  }\n\n  Affix.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset\n    this.$element.removeClass(Affix.RESET).addClass('affix')\n    var scrollTop = this.$target.scrollTop()\n    var position  = this.$element.offset()\n    return (this.pinnedOffset = position.top - scrollTop)\n  }\n\n  Affix.prototype.checkPositionWithEventLoop = function () {\n    setTimeout($.proxy(this.checkPosition, this), 1)\n  }\n\n  Affix.prototype.checkPosition = function () {\n    if (!this.$element.is(':visible')) return\n\n    var height       = this.$element.height()\n    var offset       = this.options.offset\n    var offsetTop    = offset.top\n    var offsetBottom = offset.bottom\n    var scrollHeight = $(document.body).height()\n\n    if (typeof offset != 'object')         offsetBottom = offsetTop = offset\n    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)\n    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)\n\n    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\n\n    if (this.affixed != affix) {\n      if (this.unpin != null) this.$element.css('top', '')\n\n      var affixType = 'affix' + (affix ? '-' + affix : '')\n      var e         = $.Event(affixType + '.bs.affix')\n\n      this.$element.trigger(e)\n\n      if (e.isDefaultPrevented()) return\n\n      this.affixed = affix\n      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null\n\n      this.$element\n        .removeClass(Affix.RESET)\n        .addClass(affixType)\n        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')\n    }\n\n    if (affix == 'bottom') {\n      this.$element.offset({\n        top: scrollHeight - height - offsetBottom\n      })\n    }\n  }\n\n\n  // AFFIX PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.affix')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.affix\n\n  $.fn.affix             = Plugin\n  $.fn.affix.Constructor = Affix\n\n\n  // AFFIX NO CONFLICT\n  // =================\n\n  $.fn.affix.noConflict = function () {\n    $.fn.affix = old\n    return this\n  }\n\n\n  // AFFIX DATA-API\n  // ==============\n\n  $(window).on('load', function () {\n    $('[data-spy=\"affix\"]').each(function () {\n      var $spy = $(this)\n      var data = $spy.data()\n\n      data.offset = data.offset || {}\n\n      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\n      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\n\n      Plugin.call($spy, data)\n    })\n  })\n\n}(jQuery);\n","/**\n * @license AngularJS v1.0.8\n * (c) 2010-2012 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, document, undefined) {\n'use strict';\n\n////////////////////////////////////\n\n/**\n * @ngdoc function\n * @name angular.lowercase\n * @function\n *\n * @description Converts the specified string to lowercase.\n * @param {string} string String to be converted to lowercase.\n * @returns {string} Lowercased string.\n */\nvar lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};\n\n\n/**\n * @ngdoc function\n * @name angular.uppercase\n * @function\n *\n * @description Converts the specified string to uppercase.\n * @param {string} string String to be converted to uppercase.\n * @returns {string} Uppercased string.\n */\nvar uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};\n\n\nvar manualLowercase = function(s) {\n  return isString(s)\n      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})\n      : s;\n};\nvar manualUppercase = function(s) {\n  return isString(s)\n      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})\n      : s;\n};\n\n\n// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish\n// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods\n// with correct but slower alternatives.\nif ('i' !== 'I'.toLowerCase()) {\n  lowercase = manualLowercase;\n  uppercase = manualUppercase;\n}\n\n\nvar /** holds major version number for IE or NaN for real browsers */\n    msie              = int((/msie (\\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]),\n    jqLite,           // delay binding since jQuery could be loaded after us.\n    jQuery,           // delay binding\n    slice             = [].slice,\n    push              = [].push,\n    toString          = Object.prototype.toString,\n\n    /** @name angular */\n    angular           = window.angular || (window.angular = {}),\n    angularModule,\n    nodeName_,\n    uid               = ['0', '0', '0'];\n\n\n/**\n * @private\n * @param {*} obj\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments, ...)\n */\nfunction isArrayLike(obj) {\n  if (!obj || (typeof obj.length !== 'number')) return false;\n\n  // We have on object which has length property. Should we treat it as array?\n  if (typeof obj.hasOwnProperty != 'function' &&\n      typeof obj.constructor != 'function') {\n    // This is here for IE8: it is a bogus object treat it as array;\n    return true;\n  } else  {\n    return obj instanceof JQLite ||                      // JQLite\n           (jQuery && obj instanceof jQuery) ||          // jQuery\n           toString.call(obj) !== '[object Object]' ||   // some browser native object\n           typeof obj.callee === 'function';              // arguments (on IE8 looks like regular obj)\n  }\n}\n\n\n/**\n * @ngdoc function\n * @name angular.forEach\n * @function\n *\n * @description\n * Invokes the `iterator` function once for each item in `obj` collection, which can be either an\n * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`\n * is the value of an object property or an array element and `key` is the object property key or\n * array element index. Specifying a `context` for the function is optional.\n *\n * Note: this function was previously known as `angular.foreach`.\n *\n   <pre>\n     var values = {name: 'misko', gender: 'male'};\n     var log = [];\n     angular.forEach(values, function(value, key){\n       this.push(key + ': ' + value);\n     }, log);\n     expect(log).toEqual(['name: misko', 'gender:male']);\n   </pre>\n *\n * @param {Object|Array} obj Object to iterate over.\n * @param {Function} iterator Iterator function.\n * @param {Object=} context Object to become context (`this`) for the iterator function.\n * @returns {Object|Array} Reference to `obj`.\n */\nfunction forEach(obj, iterator, context) {\n  var key;\n  if (obj) {\n    if (isFunction(obj)){\n      for (key in obj) {\n        if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {\n          iterator.call(context, obj[key], key);\n        }\n      }\n    } else if (obj.forEach && obj.forEach !== forEach) {\n      obj.forEach(iterator, context);\n    } else if (isArrayLike(obj)) {\n      for (key = 0; key < obj.length; key++)\n        iterator.call(context, obj[key], key);\n    } else {\n      for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          iterator.call(context, obj[key], key);\n        }\n      }\n    }\n  }\n  return obj;\n}\n\nfunction sortedKeys(obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      keys.push(key);\n    }\n  }\n  return keys.sort();\n}\n\nfunction forEachSorted(obj, iterator, context) {\n  var keys = sortedKeys(obj);\n  for ( var i = 0; i < keys.length; i++) {\n    iterator.call(context, obj[keys[i]], keys[i]);\n  }\n  return keys;\n}\n\n\n/**\n * when using forEach the params are value, key, but it is often useful to have key, value.\n * @param {function(string, *)} iteratorFn\n * @returns {function(*, string)}\n */\nfunction reverseParams(iteratorFn) {\n  return function(value, key) { iteratorFn(key, value) };\n}\n\n/**\n * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric\n * characters such as '012ABC'. The reason why we are not using simply a number counter is that\n * the number string gets longer over time, and it can also overflow, where as the nextId\n * will grow much slower, it is a string, and it will never overflow.\n *\n * @returns an unique alpha-numeric string\n */\nfunction nextUid() {\n  var index = uid.length;\n  var digit;\n\n  while(index) {\n    index--;\n    digit = uid[index].charCodeAt(0);\n    if (digit == 57 /*'9'*/) {\n      uid[index] = 'A';\n      return uid.join('');\n    }\n    if (digit == 90  /*'Z'*/) {\n      uid[index] = '0';\n    } else {\n      uid[index] = String.fromCharCode(digit + 1);\n      return uid.join('');\n    }\n  }\n  uid.unshift('0');\n  return uid.join('');\n}\n\n\n/**\n * Set or clear the hashkey for an object.\n * @param obj object \n * @param h the hashkey (!truthy to delete the hashkey)\n */\nfunction setHashKey(obj, h) {\n  if (h) {\n    obj.$$hashKey = h;\n  }\n  else {\n    delete obj.$$hashKey;\n  }\n}\n\n/**\n * @ngdoc function\n * @name angular.extend\n * @function\n *\n * @description\n * Extends the destination object `dst` by copying all of the properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects.\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nfunction extend(dst) {\n  var h = dst.$$hashKey;\n  forEach(arguments, function(obj){\n    if (obj !== dst) {\n      forEach(obj, function(value, key){\n        dst[key] = value;\n      });\n    }\n  });\n\n  setHashKey(dst,h);\n  return dst;\n}\n\nfunction int(str) {\n  return parseInt(str, 10);\n}\n\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, {prototype:parent}))(), extra);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.noop\n * @function\n *\n * @description\n * A function that performs no operations. This function can be useful when writing code in the\n * functional style.\n   <pre>\n     function foo(callback) {\n       var result = calculateResult();\n       (callback || angular.noop)(result);\n     }\n   </pre>\n */\nfunction noop() {}\nnoop.$inject = [];\n\n\n/**\n * @ngdoc function\n * @name angular.identity\n * @function\n *\n * @description\n * A function that returns its first argument. This function is useful when writing code in the\n * functional style.\n *\n   <pre>\n     function transformer(transformationFn, value) {\n       return (transformationFn || angular.identity)(value);\n     };\n   </pre>\n */\nfunction identity($) {return $;}\nidentity.$inject = [];\n\n\nfunction valueFn(value) {return function() {return value;};}\n\n/**\n * @ngdoc function\n * @name angular.isUndefined\n * @function\n *\n * @description\n * Determines if a reference is undefined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is undefined.\n */\nfunction isUndefined(value){return typeof value == 'undefined';}\n\n\n/**\n * @ngdoc function\n * @name angular.isDefined\n * @function\n *\n * @description\n * Determines if a reference is defined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is defined.\n */\nfunction isDefined(value){return typeof value != 'undefined';}\n\n\n/**\n * @ngdoc function\n * @name angular.isObject\n * @function\n *\n * @description\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\n * considered to be objects.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Object` but not `null`.\n */\nfunction isObject(value){return value != null && typeof value == 'object';}\n\n\n/**\n * @ngdoc function\n * @name angular.isString\n * @function\n *\n * @description\n * Determines if a reference is a `String`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `String`.\n */\nfunction isString(value){return typeof value == 'string';}\n\n\n/**\n * @ngdoc function\n * @name angular.isNumber\n * @function\n *\n * @description\n * Determines if a reference is a `Number`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Number`.\n */\nfunction isNumber(value){return typeof value == 'number';}\n\n\n/**\n * @ngdoc function\n * @name angular.isDate\n * @function\n *\n * @description\n * Determines if a value is a date.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Date`.\n */\nfunction isDate(value){\n  return toString.apply(value) == '[object Date]';\n}\n\n\n/**\n * @ngdoc function\n * @name angular.isArray\n * @function\n *\n * @description\n * Determines if a reference is an `Array`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Array`.\n */\nfunction isArray(value) {\n  return toString.apply(value) == '[object Array]';\n}\n\n\n/**\n * @ngdoc function\n * @name angular.isFunction\n * @function\n *\n * @description\n * Determines if a reference is a `Function`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Function`.\n */\nfunction isFunction(value){return typeof value == 'function';}\n\n\n/**\n * Determines if a value is a regular expression object.\n *\n * @private\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `RegExp`.\n */\nfunction isRegExp(value) {\n  return toString.apply(value) == '[object RegExp]';\n}\n\n\n/**\n * Checks if `obj` is a window object.\n *\n * @private\n * @param {*} obj Object to check\n * @returns {boolean} True if `obj` is a window obj.\n */\nfunction isWindow(obj) {\n  return obj && obj.document && obj.location && obj.alert && obj.setInterval;\n}\n\n\nfunction isScope(obj) {\n  return obj && obj.$evalAsync && obj.$watch;\n}\n\n\nfunction isFile(obj) {\n  return toString.apply(obj) === '[object File]';\n}\n\n\nfunction isBoolean(value) {\n  return typeof value == 'boolean';\n}\n\n\nvar trim = (function() {\n  // native trim is way faster: http://jsperf.com/angular-trim-test\n  // but IE doesn't have it... :-(\n  // TODO: we should move this into IE/ES5 polyfill\n  if (!String.prototype.trim) {\n    return function(value) {\n      return isString(value) ? value.replace(/^\\s*/, '').replace(/\\s*$/, '') : value;\n    };\n  }\n  return function(value) {\n    return isString(value) ? value.trim() : value;\n  };\n})();\n\n\n/**\n * @ngdoc function\n * @name angular.isElement\n * @function\n *\n * @description\n * Determines if a reference is a DOM element (or wrapped jQuery element).\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).\n */\nfunction isElement(node) {\n  return node &&\n    (node.nodeName  // we are a direct element\n    || (node.bind && node.find));  // we have a bind and find method part of jQuery API\n}\n\n/**\n * @param str 'key1,key2,...'\n * @returns {object} in the form of {key1:true, key2:true, ...}\n */\nfunction makeMap(str){\n  var obj = {}, items = str.split(\",\"), i;\n  for ( i = 0; i < items.length; i++ )\n    obj[ items[i] ] = true;\n  return obj;\n}\n\n\nif (msie < 9) {\n  nodeName_ = function(element) {\n    element = element.nodeName ? element : element[0];\n    return (element.scopeName && element.scopeName != 'HTML')\n      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;\n  };\n} else {\n  nodeName_ = function(element) {\n    return element.nodeName ? element.nodeName : element[0].nodeName;\n  };\n}\n\n\nfunction map(obj, iterator, context) {\n  var results = [];\n  forEach(obj, function(value, index, list) {\n    results.push(iterator.call(context, value, index, list));\n  });\n  return results;\n}\n\n\n/**\n * @description\n * Determines the number of elements in an array, the number of properties an object has, or\n * the length of a string.\n *\n * Note: This function is used to augment the Object type in Angular expressions. See\n * {@link angular.Object} for more information about Angular arrays.\n *\n * @param {Object|Array|string} obj Object, array, or string to inspect.\n * @param {boolean} [ownPropsOnly=false] Count only \"own\" properties in an object\n * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.\n */\nfunction size(obj, ownPropsOnly) {\n  var size = 0, key;\n\n  if (isArray(obj) || isString(obj)) {\n    return obj.length;\n  } else if (isObject(obj)){\n    for (key in obj)\n      if (!ownPropsOnly || obj.hasOwnProperty(key))\n        size++;\n  }\n\n  return size;\n}\n\n\nfunction includes(array, obj) {\n  return indexOf(array, obj) != -1;\n}\n\nfunction indexOf(array, obj) {\n  if (array.indexOf) return array.indexOf(obj);\n\n  for ( var i = 0; i < array.length; i++) {\n    if (obj === array[i]) return i;\n  }\n  return -1;\n}\n\nfunction arrayRemove(array, value) {\n  var index = indexOf(array, value);\n  if (index >=0)\n    array.splice(index, 1);\n  return value;\n}\n\nfunction isLeafNode (node) {\n  if (node) {\n    switch (node.nodeName) {\n    case \"OPTION\":\n    case \"PRE\":\n    case \"TITLE\":\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @ngdoc function\n * @name angular.copy\n * @function\n *\n * @description\n * Creates a deep copy of `source`, which should be an object or an array.\n *\n * * If no destination is supplied, a copy of the object or array is created.\n * * If a destination is provided, all of its elements (for array) or properties (for objects)\n *   are deleted and then all elements/properties from the source are copied to it.\n * * If  `source` is not an object or array, `source` is returned.\n *\n * Note: this function is used to augment the Object type in Angular expressions. See\n * {@link ng.$filter} for more information about Angular arrays.\n *\n * @param {*} source The source that will be used to make a copy.\n *                   Can be any type, including primitives, `null`, and `undefined`.\n * @param {(Object|Array)=} destination Destination into which the source is copied. If\n *     provided, must be of the same type as `source`.\n * @returns {*} The copy or updated `destination`, if `destination` was specified.\n */\nfunction copy(source, destination){\n  if (isWindow(source) || isScope(source)) throw Error(\"Can't copy Window or Scope\");\n  if (!destination) {\n    destination = source;\n    if (source) {\n      if (isArray(source)) {\n        destination = copy(source, []);\n      } else if (isDate(source)) {\n        destination = new Date(source.getTime());\n      } else if (isRegExp(source)) {\n        destination = new RegExp(source.source);\n      } else if (isObject(source)) {\n        destination = copy(source, {});\n      }\n    }\n  } else {\n    if (source === destination) throw Error(\"Can't copy equivalent objects or arrays\");\n    if (isArray(source)) {\n      destination.length = 0;\n      for ( var i = 0; i < source.length; i++) {\n        destination.push(copy(source[i]));\n      }\n    } else {\n      var h = destination.$$hashKey;\n      forEach(destination, function(value, key){\n        delete destination[key];\n      });\n      for ( var key in source) {\n        destination[key] = copy(source[key]);\n      }\n      setHashKey(destination,h);\n    }\n  }\n  return destination;\n}\n\n/**\n * Create a shallow copy of an object\n */\nfunction shallowCopy(src, dst) {\n  dst = dst || {};\n\n  for(var key in src) {\n    if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {\n      dst[key] = src[key];\n    }\n  }\n\n  return dst;\n}\n\n\n/**\n * @ngdoc function\n * @name angular.equals\n * @function\n *\n * @description\n * Determines if two objects or two values are equivalent. Supports value types, regular expressions, arrays and\n * objects.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties pass `===` comparison.\n * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)\n * * Both values represent the same regular expression (In JavasScript,\n *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual\n *   representation matches).\n *\n * During a property comparision, properties of `function` type and properties with names\n * that begin with `$` are ignored.\n *\n * Scope and DOMWindow objects are being compared only by identify (`===`).\n *\n * @param {*} o1 Object or value to compare.\n * @param {*} o2 Object or value to compare.\n * @returns {boolean} True if arguments are equal.\n */\nfunction equals(o1, o2) {\n  if (o1 === o2) return true;\n  if (o1 === null || o2 === null) return false;\n  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;\n  if (t1 == t2) {\n    if (t1 == 'object') {\n      if (isArray(o1)) {\n        if (!isArray(o2)) return false;\n        if ((length = o1.length) == o2.length) {\n          for(key=0; key<length; key++) {\n            if (!equals(o1[key], o2[key])) return false;\n          }\n          return true;\n        }\n      } else if (isDate(o1)) {\n        return isDate(o2) && o1.getTime() == o2.getTime();\n      } else if (isRegExp(o1) && isRegExp(o2)) {\n        return o1.toString() == o2.toString();\n      } else {\n        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;\n        keySet = {};\n        for(key in o1) {\n          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;\n          if (!equals(o1[key], o2[key])) return false;\n          keySet[key] = true;\n        }\n        for(key in o2) {\n          if (!keySet[key] &&\n              key.charAt(0) !== '$' &&\n              o2[key] !== undefined &&\n              !isFunction(o2[key])) return false;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n\nfunction concat(array1, array2, index) {\n  return array1.concat(slice.call(array2, index));\n}\n\nfunction sliceArgs(args, startIndex) {\n  return slice.call(args, startIndex || 0);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.bind\n * @function\n *\n * @description\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\n * known as [function currying](http://en.wikipedia.org/wiki/Currying).\n *\n * @param {Object} self Context which `fn` should be evaluated in.\n * @param {function()} fn Function to be bound.\n * @param {...*} args Optional arguments to be prebound to the `fn` function call.\n * @returns {function()} Function that wraps the `fn` with all the specified bindings.\n */\nfunction bind(self, fn) {\n  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];\n  if (isFunction(fn) && !(fn instanceof RegExp)) {\n    return curryArgs.length\n      ? function() {\n          return arguments.length\n            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))\n            : fn.apply(self, curryArgs);\n        }\n      : function() {\n          return arguments.length\n            ? fn.apply(self, arguments)\n            : fn.call(self);\n        };\n  } else {\n    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)\n    return fn;\n  }\n}\n\n\nfunction toJsonReplacer(key, value) {\n  var val = value;\n\n  if (/^\\$+/.test(key)) {\n    val = undefined;\n  } else if (isWindow(value)) {\n    val = '$WINDOW';\n  } else if (value &&  document === value) {\n    val = '$DOCUMENT';\n  } else if (isScope(value)) {\n    val = '$SCOPE';\n  }\n\n  return val;\n}\n\n\n/**\n * @ngdoc function\n * @name angular.toJson\n * @function\n *\n * @description\n * Serializes input into a JSON-formatted string. Properties with leading $ characters will be\n * stripped since angular uses this notation internally.\n *\n * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.\n * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.\n * @returns {string|undefined} Jsonified string representing `obj`.\n */\nfunction toJson(obj, pretty) {\n  if (typeof obj === 'undefined') return undefined;\n  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.fromJson\n * @function\n *\n * @description\n * Deserializes a JSON string.\n *\n * @param {string} json JSON string to deserialize.\n * @returns {Object|Array|Date|string|number} Deserialized thingy.\n */\nfunction fromJson(json) {\n  return isString(json)\n      ? JSON.parse(json)\n      : json;\n}\n\n\nfunction toBoolean(value) {\n  if (value && value.length !== 0) {\n    var v = lowercase(\"\" + value);\n    value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');\n  } else {\n    value = false;\n  }\n  return value;\n}\n\n/**\n * @returns {string} Returns the string representation of the element.\n */\nfunction startingTag(element) {\n  element = jqLite(element).clone();\n  try {\n    // turns out IE does not let you set .html() on elements which\n    // are not allowed to have children. So we just ignore it.\n    element.html('');\n  } catch(e) {}\n  // As Per DOM Standards\n  var TEXT_NODE = 3;\n  var elemHtml = jqLite('<div>').append(element).html();\n  try {\n    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :\n        elemHtml.\n          match(/^(<[^>]+>)/)[1].\n          replace(/^<([\\w\\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });\n  } catch(e) {\n    return lowercase(elemHtml);\n  }\n\n}\n\n\n/////////////////////////////////////////////////\n\n/**\n * Tries to decode the URI component without throwing an exception.\n *\n * @private\n * @param str value potential URI component to check.\n * @returns {boolean} True if `value` can be decoded\n * with the decodeURIComponent function.\n */\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch(e) {\n    // Ignore any invalid uri component\n  }\n}\n\n\n/**\n * Parses an escaped url query string into key-value pairs.\n * @returns Object.<(string|boolean)>\n */\nfunction parseKeyValue(/**string*/keyValue) {\n  var obj = {}, key_value, key;\n  forEach((keyValue || \"\").split('&'), function(keyValue){\n    if ( keyValue ) {\n      key_value = keyValue.split('=');\n      key = tryDecodeURIComponent(key_value[0]);\n      if ( isDefined(key) ) {\n        obj[key] = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;\n      }\n    }\n  });\n  return obj;\n}\n\nfunction toKeyValue(obj) {\n  var parts = [];\n  forEach(obj, function(value, key) {\n    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));\n  });\n  return parts.length ? parts.join('&') : '';\n}\n\n\n/**\n * We need our custom method because encodeURIComponent is too agressive and doesn't follow\n * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\n * segments:\n *    segment       = *pchar\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriSegment(val) {\n  return encodeUriQuery(val, true).\n             replace(/%26/gi, '&').\n             replace(/%3D/gi, '=').\n             replace(/%2B/gi, '+');\n}\n\n\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method becuase encodeURIComponent is too agressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query       = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriQuery(val, pctEncodeSpaces) {\n  return encodeURIComponent(val).\n             replace(/%40/gi, '@').\n             replace(/%3A/gi, ':').\n             replace(/%24/g, '$').\n             replace(/%2C/gi, ',').\n             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n}\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngApp\n *\n * @element ANY\n * @param {angular.Module} ngApp an optional application\n *   {@link angular.module module} name to load.\n *\n * @description\n *\n * Use this directive to auto-bootstrap an application. Only\n * one ngApp directive can be used per HTML document. The directive\n * designates the root of the application and is typically placed\n * at the root of the page.\n *\n * The first ngApp found in the document will be auto-bootstrapped. To use multiple applications in an\n * HTML document you must manually bootstrap them using {@link angular.bootstrap}.\n * Applications cannot be nested.\n *\n * In the example below if the `ngApp` directive would not be placed\n * on the `html` element then the document would not be compiled\n * and the `{{ 1+2 }}` would not be resolved to `3`.\n *\n * `ngApp` is the easiest way to bootstrap an application.\n *\n <doc:example>\n   <doc:source>\n    I can add: 1 + 2 =  {{ 1+2 }}\n   </doc:source>\n </doc:example>\n *\n */\nfunction angularInit(element, bootstrap) {\n  var elements = [element],\n      appElement,\n      module,\n      names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n      NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/;\n\n  function append(element) {\n    element && elements.push(element);\n  }\n\n  forEach(names, function(name) {\n    names[name] = true;\n    append(document.getElementById(name));\n    name = name.replace(':', '\\\\:');\n    if (element.querySelectorAll) {\n      forEach(element.querySelectorAll('.' + name), append);\n      forEach(element.querySelectorAll('.' + name + '\\\\:'), append);\n      forEach(element.querySelectorAll('[' + name + ']'), append);\n    }\n  });\n\n  forEach(elements, function(element) {\n    if (!appElement) {\n      var className = ' ' + element.className + ' ';\n      var match = NG_APP_CLASS_REGEXP.exec(className);\n      if (match) {\n        appElement = element;\n        module = (match[2] || '').replace(/\\s+/g, ',');\n      } else {\n        forEach(element.attributes, function(attr) {\n          if (!appElement && names[attr.name]) {\n            appElement = element;\n            module = attr.value;\n          }\n        });\n      }\n    }\n  });\n  if (appElement) {\n    bootstrap(appElement, module ? [module] : []);\n  }\n}\n\n/**\n * @ngdoc function\n * @name angular.bootstrap\n * @description\n * Use this function to manually start up angular application.\n *\n * See: {@link guide/bootstrap Bootstrap}\n *\n * Note that ngScenario-based end-to-end tests cannot use this function to bootstrap manually.\n * They must use {@link api/ng.directive:ngApp ngApp}.\n *\n * @param {Element} element DOM element which is the root of angular application.\n * @param {Array<String|Function>=} modules an array of module declarations. See: {@link angular.module modules}\n * @returns {AUTO.$injector} Returns the newly created injector for this app.\n */\nfunction bootstrap(element, modules) {\n  var doBootstrap = function() {\n    element = jqLite(element);\n    modules = modules || [];\n    modules.unshift(['$provide', function($provide) {\n      $provide.value('$rootElement', element);\n    }]);\n    modules.unshift('ng');\n    var injector = createInjector(modules);\n    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',\n       function(scope, element, compile, injector) {\n        scope.$apply(function() {\n          element.data('$injector', injector);\n          compile(element)(scope);\n        });\n      }]\n    );\n    return injector;\n  };\n\n  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;\n\n  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {\n    return doBootstrap();\n  }\n\n  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');\n  angular.resumeBootstrap = function(extraModules) {\n    forEach(extraModules, function(module) {\n      modules.push(module);\n    });\n    doBootstrap();\n  };\n}\n\nvar SNAKE_CASE_REGEXP = /[A-Z]/g;\nfunction snake_case(name, separator){\n  separator = separator || '_';\n  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n    return (pos ? separator : '') + letter.toLowerCase();\n  });\n}\n\nfunction bindJQuery() {\n  // bind to jQuery if present;\n  jQuery = window.jQuery;\n  // reset to jQuery or default to us.\n  if (jQuery) {\n    jqLite = jQuery;\n    extend(jQuery.fn, {\n      scope: JQLitePrototype.scope,\n      controller: JQLitePrototype.controller,\n      injector: JQLitePrototype.injector,\n      inheritedData: JQLitePrototype.inheritedData\n    });\n    // Method signature: JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)\n    JQLitePatchJQueryRemove('remove', true, true, false);\n    JQLitePatchJQueryRemove('empty', false, false, false);\n    JQLitePatchJQueryRemove('html', false, false, true);\n  } else {\n    jqLite = JQLite;\n  }\n  angular.element = jqLite;\n}\n\n/**\n * throw error if the argument is falsy.\n */\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw new Error(\"Argument '\" + (name || '?') + \"' is \" + (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction assertArgFn(arg, name, acceptArrayAnnotation) {\n  if (acceptArrayAnnotation && isArray(arg)) {\n      arg = arg[arg.length - 1];\n  }\n\n  assertArg(isFunction(arg), name, 'not a function, got ' +\n      (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));\n  return arg;\n}\n\n/**\n * Return the value accessible from the object by path. Any undefined traversals are ignored\n * @param {Object} obj starting object\n * @param {string} path path to traverse\n * @param {boolean=true} bindFnToScope\n * @returns value as accessible by path\n */\n//TODO(misko): this function needs to be removed\nfunction getter(obj, path, bindFnToScope) {\n  if (!path) return obj;\n  var keys = path.split('.');\n  var key;\n  var lastInstance = obj;\n  var len = keys.length;\n\n  for (var i = 0; i < len; i++) {\n    key = keys[i];\n    if (obj) {\n      obj = (lastInstance = obj)[key];\n    }\n  }\n  if (!bindFnToScope && isFunction(obj)) {\n    return bind(lastInstance, obj);\n  }\n  return obj;\n}\n\n/**\n * @ngdoc interface\n * @name angular.Module\n * @description\n *\n * Interface for configuring angular {@link angular.module modules}.\n */\n\nfunction setupModuleLoader(window) {\n\n  function ensure(obj, name, factory) {\n    return obj[name] || (obj[name] = factory());\n  }\n\n  return ensure(ensure(window, 'angular', Object), 'module', function() {\n    /** @type {Object.<string, angular.Module>} */\n    var modules = {};\n\n    /**\n     * @ngdoc function\n     * @name angular.module\n     * @description\n     *\n     * The `angular.module` is a global place for creating and registering Angular modules. All\n     * modules (angular core or 3rd party) that should be available to an application must be\n     * registered using this mechanism.\n     *\n     *\n     * # Module\n     *\n     * A module is a collection of services, directives, filters, and configuration information.\n     * `angular.module` is used to configure the {@link AUTO.$injector $injector}.\n     *\n     * <pre>\n     * // Create a new module\n     * var myModule = angular.module('myModule', []);\n     *\n     * // register a new service\n     * myModule.value('appName', 'MyCoolApp');\n     *\n     * // configure existing services inside initialization blocks.\n     * myModule.config(function($locationProvider) {\n     *   // Configure existing providers\n     *   $locationProvider.hashPrefix('!');\n     * });\n     * </pre>\n     *\n     * Then you can create an injector and load your modules like this:\n     *\n     * <pre>\n     * var injector = angular.injector(['ng', 'MyModule'])\n     * </pre>\n     *\n     * However it's more likely that you'll just use\n     * {@link ng.directive:ngApp ngApp} or\n     * {@link angular.bootstrap} to simplify this process for you.\n     *\n     * @param {!string} name The name of the module to create or retrieve.\n     * @param {Array.<string>=} requires If specified then new module is being created. If unspecified then the\n     *        the module is being retrieved for further configuration.\n     * @param {Function} configFn Optional configuration function for the module. Same as\n     *        {@link angular.Module#config Module#config()}.\n     * @returns {module} new module with the {@link angular.Module} api.\n     */\n    return function module(name, requires, configFn) {\n      if (requires && modules.hasOwnProperty(name)) {\n        modules[name] = null;\n      }\n      return ensure(modules, name, function() {\n        if (!requires) {\n          throw Error('No module: ' + name);\n        }\n\n        /** @type {!Array.<Array.<*>>} */\n        var invokeQueue = [];\n\n        /** @type {!Array.<Function>} */\n        var runBlocks = [];\n\n        var config = invokeLater('$injector', 'invoke');\n\n        /** @type {angular.Module} */\n        var moduleInstance = {\n          // Private state\n          _invokeQueue: invokeQueue,\n          _runBlocks: runBlocks,\n\n          /**\n           * @ngdoc property\n           * @name angular.Module#requires\n           * @propertyOf angular.Module\n           * @returns {Array.<string>} List of module names which must be loaded before this module.\n           * @description\n           * Holds the list of modules which the injector will load before the current module is loaded.\n           */\n          requires: requires,\n\n          /**\n           * @ngdoc property\n           * @name angular.Module#name\n           * @propertyOf angular.Module\n           * @returns {string} Name of the module.\n           * @description\n           */\n          name: name,\n\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#provider\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {Function} providerType Construction function for creating new instance of the service.\n           * @description\n           * See {@link AUTO.$provide#provider $provide.provider()}.\n           */\n          provider: invokeLater('$provide', 'provider'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#factory\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {Function} providerFunction Function for creating new instance of the service.\n           * @description\n           * See {@link AUTO.$provide#factory $provide.factory()}.\n           */\n          factory: invokeLater('$provide', 'factory'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#service\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {Function} constructor A constructor function that will be instantiated.\n           * @description\n           * See {@link AUTO.$provide#service $provide.service()}.\n           */\n          service: invokeLater('$provide', 'service'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#value\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {*} object Service instance object.\n           * @description\n           * See {@link AUTO.$provide#value $provide.value()}.\n           */\n          value: invokeLater('$provide', 'value'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#constant\n           * @methodOf angular.Module\n           * @param {string} name constant name\n           * @param {*} object Constant value.\n           * @description\n           * Because the constant are fixed, they get applied before other provide methods.\n           * See {@link AUTO.$provide#constant $provide.constant()}.\n           */\n          constant: invokeLater('$provide', 'constant', 'unshift'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#filter\n           * @methodOf angular.Module\n           * @param {string} name Filter name.\n           * @param {Function} filterFactory Factory function for creating new instance of filter.\n           * @description\n           * See {@link ng.$filterProvider#register $filterProvider.register()}.\n           */\n          filter: invokeLater('$filterProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#controller\n           * @methodOf angular.Module\n           * @param {string} name Controller name.\n           * @param {Function} constructor Controller constructor function.\n           * @description\n           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.\n           */\n          controller: invokeLater('$controllerProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#directive\n           * @methodOf angular.Module\n           * @param {string} name directive name\n           * @param {Function} directiveFactory Factory function for creating new instance of\n           * directives.\n           * @description\n           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.\n           */\n          directive: invokeLater('$compileProvider', 'directive'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#config\n           * @methodOf angular.Module\n           * @param {Function} configFn Execute this function on module load. Useful for service\n           *    configuration.\n           * @description\n           * Use this method to register work which needs to be performed on module loading.\n           */\n          config: config,\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#run\n           * @methodOf angular.Module\n           * @param {Function} initializationFn Execute this function after injector creation.\n           *    Useful for application initialization.\n           * @description\n           * Use this method to register work which should be performed when the injector is done\n           * loading all modules.\n           */\n          run: function(block) {\n            runBlocks.push(block);\n            return this;\n          }\n        };\n\n        if (configFn) {\n          config(configFn);\n        }\n\n        return  moduleInstance;\n\n        /**\n         * @param {string} provider\n         * @param {string} method\n         * @param {String=} insertMethod\n         * @returns {angular.Module}\n         */\n        function invokeLater(provider, method, insertMethod) {\n          return function() {\n            invokeQueue[insertMethod || 'push']([provider, method, arguments]);\n            return moduleInstance;\n          }\n        }\n      });\n    };\n  });\n\n}\n\n/**\n * @ngdoc property\n * @name angular.version\n * @description\n * An object that contains information about the current AngularJS version. This object has the\n * following properties:\n *\n * - `full` – `{string}` – Full version string, such as \"0.9.18\".\n * - `major` – `{number}` – Major version number, such as \"0\".\n * - `minor` – `{number}` – Minor version number, such as \"9\".\n * - `dot` – `{number}` – Dot version number, such as \"18\".\n * - `codeName` – `{string}` – Code name of the release, such as \"jiggling-armfat\".\n */\nvar version = {\n  full: '1.0.8',    // all of these placeholder strings will be replaced by grunt's\n  major: 1,    // package task\n  minor: 0,\n  dot: 8,\n  codeName: 'bubble-burst'\n};\n\n\nfunction publishExternalAPI(angular){\n  extend(angular, {\n    'bootstrap': bootstrap,\n    'copy': copy,\n    'extend': extend,\n    'equals': equals,\n    'element': jqLite,\n    'forEach': forEach,\n    'injector': createInjector,\n    'noop':noop,\n    'bind':bind,\n    'toJson': toJson,\n    'fromJson': fromJson,\n    'identity':identity,\n    'isUndefined': isUndefined,\n    'isDefined': isDefined,\n    'isString': isString,\n    'isFunction': isFunction,\n    'isObject': isObject,\n    'isNumber': isNumber,\n    'isElement': isElement,\n    'isArray': isArray,\n    'version': version,\n    'isDate': isDate,\n    'lowercase': lowercase,\n    'uppercase': uppercase,\n    'callbacks': {counter: 0}\n  });\n\n  angularModule = setupModuleLoader(window);\n  try {\n    angularModule('ngLocale');\n  } catch (e) {\n    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);\n  }\n\n  angularModule('ng', ['ngLocale'], ['$provide',\n    function ngModule($provide) {\n      $provide.provider('$compile', $CompileProvider).\n        directive({\n            a: htmlAnchorDirective,\n            input: inputDirective,\n            textarea: inputDirective,\n            form: formDirective,\n            script: scriptDirective,\n            select: selectDirective,\n            style: styleDirective,\n            option: optionDirective,\n            ngBind: ngBindDirective,\n            ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,\n            ngBindTemplate: ngBindTemplateDirective,\n            ngClass: ngClassDirective,\n            ngClassEven: ngClassEvenDirective,\n            ngClassOdd: ngClassOddDirective,\n            ngCsp: ngCspDirective,\n            ngCloak: ngCloakDirective,\n            ngController: ngControllerDirective,\n            ngForm: ngFormDirective,\n            ngHide: ngHideDirective,\n            ngInclude: ngIncludeDirective,\n            ngInit: ngInitDirective,\n            ngNonBindable: ngNonBindableDirective,\n            ngPluralize: ngPluralizeDirective,\n            ngRepeat: ngRepeatDirective,\n            ngShow: ngShowDirective,\n            ngStyle: ngStyleDirective,\n            ngSwitch: ngSwitchDirective,\n            ngSwitchWhen: ngSwitchWhenDirective,\n            ngSwitchDefault: ngSwitchDefaultDirective,\n            ngOptions: ngOptionsDirective,\n            ngView: ngViewDirective,\n            ngTransclude: ngTranscludeDirective,\n            ngModel: ngModelDirective,\n            ngList: ngListDirective,\n            ngChange: ngChangeDirective,\n            required: requiredDirective,\n            ngRequired: requiredDirective,\n            ngValue: ngValueDirective\n        }).\n        directive(ngAttributeAliasDirectives).\n        directive(ngEventDirectives);\n      $provide.provider({\n        $anchorScroll: $AnchorScrollProvider,\n        $browser: $BrowserProvider,\n        $cacheFactory: $CacheFactoryProvider,\n        $controller: $ControllerProvider,\n        $document: $DocumentProvider,\n        $exceptionHandler: $ExceptionHandlerProvider,\n        $filter: $FilterProvider,\n        $interpolate: $InterpolateProvider,\n        $http: $HttpProvider,\n        $httpBackend: $HttpBackendProvider,\n        $location: $LocationProvider,\n        $log: $LogProvider,\n        $parse: $ParseProvider,\n        $route: $RouteProvider,\n        $routeParams: $RouteParamsProvider,\n        $rootScope: $RootScopeProvider,\n        $q: $QProvider,\n        $sniffer: $SnifferProvider,\n        $templateCache: $TemplateCacheProvider,\n        $timeout: $TimeoutProvider,\n        $window: $WindowProvider\n      });\n    }\n  ]);\n}\n\n//////////////////////////////////\n//JQLite\n//////////////////////////////////\n\n/**\n * @ngdoc function\n * @name angular.element\n * @function\n *\n * @description\n * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.\n * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if\n * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite\n * implementation (commonly referred to as jqLite).\n *\n * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`\n * event fired.\n *\n * jqLite is a tiny, API-compatible subset of jQuery that allows\n * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality\n * within a very small footprint, so only a subset of the jQuery API - methods, arguments and\n * invocation styles - are supported.\n *\n * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never\n * raw DOM references.\n *\n * ## Angular's jqLite\n * Angular's lite version of jQuery provides only the following jQuery methods:\n *\n * - [addClass()](http://api.jquery.com/addClass/)\n * - [after()](http://api.jquery.com/after/)\n * - [append()](http://api.jquery.com/append/)\n * - [attr()](http://api.jquery.com/attr/)\n * - [bind()](http://api.jquery.com/bind/) - Does not support namespaces\n * - [children()](http://api.jquery.com/children/) - Does not support selectors\n * - [clone()](http://api.jquery.com/clone/)\n * - [contents()](http://api.jquery.com/contents/)\n * - [css()](http://api.jquery.com/css/)\n * - [data()](http://api.jquery.com/data/)\n * - [eq()](http://api.jquery.com/eq/)\n * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name\n * - [hasClass()](http://api.jquery.com/hasClass/)\n * - [html()](http://api.jquery.com/html/)\n * - [next()](http://api.jquery.com/next/) - Does not support selectors\n * - [parent()](http://api.jquery.com/parent/) - Does not support selectors\n * - [prepend()](http://api.jquery.com/prepend/)\n * - [prop()](http://api.jquery.com/prop/)\n * - [ready()](http://api.jquery.com/ready/)\n * - [remove()](http://api.jquery.com/remove/)\n * - [removeAttr()](http://api.jquery.com/removeAttr/)\n * - [removeClass()](http://api.jquery.com/removeClass/)\n * - [removeData()](http://api.jquery.com/removeData/)\n * - [replaceWith()](http://api.jquery.com/replaceWith/)\n * - [text()](http://api.jquery.com/text/)\n * - [toggleClass()](http://api.jquery.com/toggleClass/)\n * - [triggerHandler()](http://api.jquery.com/triggerHandler/) - Doesn't pass native event objects to handlers.\n * - [unbind()](http://api.jquery.com/unbind/) - Does not support namespaces\n * - [val()](http://api.jquery.com/val/)\n * - [wrap()](http://api.jquery.com/wrap/)\n *\n * ## jQuery/jqLite Extras\n * Angular also provides the following additional methods and events to both jQuery and jqLite:\n *\n * ### Events\n * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event\n *    on all DOM nodes being removed.  This can be used to clean up and 3rd party bindings to the DOM\n *    element before it is removed.\n * ### Methods\n * - `controller(name)` - retrieves the controller of the current element or its parent. By default\n *   retrieves controller associated with the `ngController` directive. If `name` is provided as\n *   camelCase directive name, then the controller for this directive will be retrieved (e.g.\n *   `'ngModel'`).\n * - `injector()` - retrieves the injector of the current element or its parent.\n * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current\n *   element or its parent.\n * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top\n *   parent element is reached.\n *\n * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.\n * @returns {Object} jQuery object.\n */\n\nvar jqCache = JQLite.cache = {},\n    jqName = JQLite.expando = 'ng-' + new Date().getTime(),\n    jqId = 1,\n    addEventListenerFn = (window.document.addEventListener\n      ? function(element, type, fn) {element.addEventListener(type, fn, false);}\n      : function(element, type, fn) {element.attachEvent('on' + type, fn);}),\n    removeEventListenerFn = (window.document.removeEventListener\n      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }\n      : function(element, type, fn) {element.detachEvent('on' + type, fn); });\n\nfunction jqNextId() { return ++jqId; }\n\n\nvar SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\nvar MOZ_HACK_REGEXP = /^moz([A-Z])/;\n\n/**\n * Converts snake_case to camelCase.\n * Also there is special case for Moz prefix starting with upper case letter.\n * @param name Name to normalize\n */\nfunction camelCase(name) {\n  return name.\n    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {\n      return offset ? letter.toUpperCase() : letter;\n    }).\n    replace(MOZ_HACK_REGEXP, 'Moz$1');\n}\n\n/////////////////////////////////////////////\n// jQuery mutation patch\n//\n// In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a\n// $destroy event on all DOM nodes being removed.\n//\n/////////////////////////////////////////////\n\nfunction JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {\n  var originalJqFn = jQuery.fn[name];\n  originalJqFn = originalJqFn.$original || originalJqFn;\n  removePatch.$original = originalJqFn;\n  jQuery.fn[name] = removePatch;\n\n  function removePatch(param) {\n    var list = filterElems && param ? [this.filter(param)] : [this],\n        fireEvent = dispatchThis,\n        set, setIndex, setLength,\n        element, childIndex, childLength, children;\n\n    if (!getterIfNoArguments || param != null) {\n      while(list.length) {\n        set = list.shift();\n        for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {\n          element = jqLite(set[setIndex]);\n          if (fireEvent) {\n            element.triggerHandler('$destroy');\n          } else {\n            fireEvent = !fireEvent;\n          }\n          for(childIndex = 0, childLength = (children = element.children()).length;\n              childIndex < childLength;\n              childIndex++) {\n            list.push(jQuery(children[childIndex]));\n          }\n        }\n      }\n    }\n    return originalJqFn.apply(this, arguments);\n  }\n}\n\n/////////////////////////////////////////////\nfunction JQLite(element) {\n  if (element instanceof JQLite) {\n    return element;\n  }\n  if (!(this instanceof JQLite)) {\n    if (isString(element) && element.charAt(0) != '<') {\n      throw Error('selectors not implemented');\n    }\n    return new JQLite(element);\n  }\n\n  if (isString(element)) {\n    var div = document.createElement('div');\n    // Read about the NoScope elements here:\n    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx\n    div.innerHTML = '<div>&#160;</div>' + element; // IE insanity to make NoScope elements work!\n    div.removeChild(div.firstChild); // remove the superfluous div\n    JQLiteAddNodes(this, div.childNodes);\n    this.remove(); // detach the elements from the temporary DOM div.\n  } else {\n    JQLiteAddNodes(this, element);\n  }\n}\n\nfunction JQLiteClone(element) {\n  return element.cloneNode(true);\n}\n\nfunction JQLiteDealoc(element){\n  JQLiteRemoveData(element);\n  for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {\n    JQLiteDealoc(children[i]);\n  }\n}\n\nfunction JQLiteUnbind(element, type, fn) {\n  var events = JQLiteExpandoStore(element, 'events'),\n      handle = JQLiteExpandoStore(element, 'handle');\n\n  if (!handle) return; //no listeners registered\n\n  if (isUndefined(type)) {\n    forEach(events, function(eventHandler, type) {\n      removeEventListenerFn(element, type, eventHandler);\n      delete events[type];\n    });\n  } else {\n    if (isUndefined(fn)) {\n      removeEventListenerFn(element, type, events[type]);\n      delete events[type];\n    } else {\n      arrayRemove(events[type] || [], fn);\n    }\n  }\n}\n\nfunction JQLiteRemoveData(element) {\n  var expandoId = element[jqName],\n      expandoStore = jqCache[expandoId];\n\n  if (expandoStore) {\n    if (expandoStore.handle) {\n      expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');\n      JQLiteUnbind(element);\n    }\n    delete jqCache[expandoId];\n    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.\n  }\n}\n\nfunction JQLiteExpandoStore(element, key, value) {\n  var expandoId = element[jqName],\n      expandoStore = jqCache[expandoId || -1];\n\n  if (isDefined(value)) {\n    if (!expandoStore) {\n      element[jqName] = expandoId = jqNextId();\n      expandoStore = jqCache[expandoId] = {};\n    }\n    expandoStore[key] = value;\n  } else {\n    return expandoStore && expandoStore[key];\n  }\n}\n\nfunction JQLiteData(element, key, value) {\n  var data = JQLiteExpandoStore(element, 'data'),\n      isSetter = isDefined(value),\n      keyDefined = !isSetter && isDefined(key),\n      isSimpleGetter = keyDefined && !isObject(key);\n\n  if (!data && !isSimpleGetter) {\n    JQLiteExpandoStore(element, 'data', data = {});\n  }\n\n  if (isSetter) {\n    data[key] = value;\n  } else {\n    if (keyDefined) {\n      if (isSimpleGetter) {\n        // don't create data in this case.\n        return data && data[key];\n      } else {\n        extend(data, key);\n      }\n    } else {\n      return data;\n    }\n  }\n}\n\nfunction JQLiteHasClass(element, selector) {\n  return ((\" \" + element.className + \" \").replace(/[\\n\\t]/g, \" \").\n      indexOf( \" \" + selector + \" \" ) > -1);\n}\n\nfunction JQLiteRemoveClass(element, cssClasses) {\n  if (cssClasses) {\n    forEach(cssClasses.split(' '), function(cssClass) {\n      element.className = trim(\n          (\" \" + element.className + \" \")\n          .replace(/[\\n\\t]/g, \" \")\n          .replace(\" \" + trim(cssClass) + \" \", \" \")\n      );\n    });\n  }\n}\n\nfunction JQLiteAddClass(element, cssClasses) {\n  if (cssClasses) {\n    forEach(cssClasses.split(' '), function(cssClass) {\n      if (!JQLiteHasClass(element, cssClass)) {\n        element.className = trim(element.className + ' ' + trim(cssClass));\n      }\n    });\n  }\n}\n\nfunction JQLiteAddNodes(root, elements) {\n  if (elements) {\n    elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))\n      ? elements\n      : [ elements ];\n    for(var i=0; i < elements.length; i++) {\n      root.push(elements[i]);\n    }\n  }\n}\n\nfunction JQLiteController(element, name) {\n  return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');\n}\n\nfunction JQLiteInheritedData(element, name, value) {\n  element = jqLite(element);\n\n  // if element is the document object work with the html element instead\n  // this makes $(document).scope() possible\n  if(element[0].nodeType == 9) {\n    element = element.find('html');\n  }\n\n  while (element.length) {\n    if (value = element.data(name)) return value;\n    element = element.parent();\n  }\n}\n\n//////////////////////////////////////////\n// Functions which are declared directly.\n//////////////////////////////////////////\nvar JQLitePrototype = JQLite.prototype = {\n  ready: function(fn) {\n    var fired = false;\n\n    function trigger() {\n      if (fired) return;\n      fired = true;\n      fn();\n    }\n\n    this.bind('DOMContentLoaded', trigger); // works for modern browsers and IE9\n    // we can not use jqLite since we are not done loading and jQuery could be loaded later.\n    JQLite(window).bind('load', trigger); // fallback to window.onload for others\n  },\n  toString: function() {\n    var value = [];\n    forEach(this, function(e){ value.push('' + e);});\n    return '[' + value.join(', ') + ']';\n  },\n\n  eq: function(index) {\n      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);\n  },\n\n  length: 0,\n  push: push,\n  sort: [].sort,\n  splice: [].splice\n};\n\n//////////////////////////////////////////\n// Functions iterating getter/setters.\n// these functions return self on setter and\n// value on get.\n//////////////////////////////////////////\nvar BOOLEAN_ATTR = {};\nforEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function(value) {\n  BOOLEAN_ATTR[lowercase(value)] = value;\n});\nvar BOOLEAN_ELEMENTS = {};\nforEach('input,select,option,textarea,button,form'.split(','), function(value) {\n  BOOLEAN_ELEMENTS[uppercase(value)] = true;\n});\n\nfunction getBooleanAttrName(element, name) {\n  // check dom last since we will most likely fail on name\n  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];\n\n  // booleanAttr is here twice to minimize DOM access\n  return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;\n}\n\nforEach({\n  data: JQLiteData,\n  inheritedData: JQLiteInheritedData,\n\n  scope: function(element) {\n    return JQLiteInheritedData(element, '$scope');\n  },\n\n  controller: JQLiteController ,\n\n  injector: function(element) {\n    return JQLiteInheritedData(element, '$injector');\n  },\n\n  removeAttr: function(element,name) {\n    element.removeAttribute(name);\n  },\n\n  hasClass: JQLiteHasClass,\n\n  css: function(element, name, value) {\n    name = camelCase(name);\n\n    if (isDefined(value)) {\n      element.style[name] = value;\n    } else {\n      var val;\n\n      if (msie <= 8) {\n        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why\n        val = element.currentStyle && element.currentStyle[name];\n        if (val === '') val = 'auto';\n      }\n\n      val = val || element.style[name];\n\n      if (msie <= 8) {\n        // jquery weirdness :-/\n        val = (val === '') ? undefined : val;\n      }\n\n      return  val;\n    }\n  },\n\n  attr: function(element, name, value){\n    var lowercasedName = lowercase(name);\n    if (BOOLEAN_ATTR[lowercasedName]) {\n      if (isDefined(value)) {\n        if (!!value) {\n          element[name] = true;\n          element.setAttribute(name, lowercasedName);\n        } else {\n          element[name] = false;\n          element.removeAttribute(lowercasedName);\n        }\n      } else {\n        return (element[name] ||\n                 (element.attributes.getNamedItem(name)|| noop).specified)\n               ? lowercasedName\n               : undefined;\n      }\n    } else if (isDefined(value)) {\n      element.setAttribute(name, value);\n    } else if (element.getAttribute) {\n      // the extra argument \"2\" is to get the right thing for a.href in IE, see jQuery code\n      // some elements (e.g. Document) don't have get attribute, so return undefined\n      var ret = element.getAttribute(name, 2);\n      // normalize non-existing attributes to undefined (as jQuery)\n      return ret === null ? undefined : ret;\n    }\n  },\n\n  prop: function(element, name, value) {\n    if (isDefined(value)) {\n      element[name] = value;\n    } else {\n      return element[name];\n    }\n  },\n\n  text: extend((msie < 9)\n      ? function(element, value) {\n        if (element.nodeType == 1 /** Element */) {\n          if (isUndefined(value))\n            return element.innerText;\n          element.innerText = value;\n        } else {\n          if (isUndefined(value))\n            return element.nodeValue;\n          element.nodeValue = value;\n        }\n      }\n      : function(element, value) {\n        if (isUndefined(value)) {\n          return element.textContent;\n        }\n        element.textContent = value;\n      }, {$dv:''}),\n\n  val: function(element, value) {\n    if (isUndefined(value)) {\n      if (nodeName_(element) === 'SELECT' && element.multiple) {\n        var result = [];\n        forEach(element.options, function (option) {\n          if (option.selected) {\n            result.push(option.value || option.text);\n          }\n        });\n        return result.length === 0 ? null : result;\n      }\n      return element.value;\n    }\n    element.value = value;\n  },\n\n  html: function(element, value) {\n    if (isUndefined(value)) {\n      return element.innerHTML;\n    }\n    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {\n      JQLiteDealoc(childNodes[i]);\n    }\n    element.innerHTML = value;\n  }\n}, function(fn, name){\n  /**\n   * Properties: writes return selection, reads return first value\n   */\n  JQLite.prototype[name] = function(arg1, arg2) {\n    var i, key;\n\n    // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it\n    // in a way that survives minification.\n    if (((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController)) ? arg1 : arg2) === undefined) {\n      if (isObject(arg1)) {\n\n        // we are a write, but the object properties are the key/values\n        for(i=0; i < this.length; i++) {\n          if (fn === JQLiteData) {\n            // data() takes the whole object in jQuery\n            fn(this[i], arg1);\n          } else {\n            for (key in arg1) {\n              fn(this[i], key, arg1[key]);\n            }\n          }\n        }\n        // return self for chaining\n        return this;\n      } else {\n        // we are a read, so read the first child.\n        if (this.length)\n          return fn(this[0], arg1, arg2);\n      }\n    } else {\n      // we are a write, so apply to all children\n      for(i=0; i < this.length; i++) {\n        fn(this[i], arg1, arg2);\n      }\n      // return self for chaining\n      return this;\n    }\n    return fn.$dv;\n  };\n});\n\nfunction createEventHandler(element, events) {\n  var eventHandler = function (event, type) {\n    if (!event.preventDefault) {\n      event.preventDefault = function() {\n        event.returnValue = false; //ie\n      };\n    }\n\n    if (!event.stopPropagation) {\n      event.stopPropagation = function() {\n        event.cancelBubble = true; //ie\n      };\n    }\n\n    if (!event.target) {\n      event.target = event.srcElement || document;\n    }\n\n    if (isUndefined(event.defaultPrevented)) {\n      var prevent = event.preventDefault;\n      event.preventDefault = function() {\n        event.defaultPrevented = true;\n        prevent.call(event);\n      };\n      event.defaultPrevented = false;\n    }\n\n    event.isDefaultPrevented = function() {\n      return event.defaultPrevented;\n    };\n\n    forEach(events[type || event.type], function(fn) {\n      fn.call(element, event);\n    });\n\n    // Remove monkey-patched methods (IE),\n    // as they would cause memory leaks in IE8.\n    if (msie <= 8) {\n      // IE7/8 does not allow to delete property on native object\n      event.preventDefault = null;\n      event.stopPropagation = null;\n      event.isDefaultPrevented = null;\n    } else {\n      // It shouldn't affect normal browsers (native methods are defined on prototype).\n      delete event.preventDefault;\n      delete event.stopPropagation;\n      delete event.isDefaultPrevented;\n    }\n  };\n  eventHandler.elem = element;\n  return eventHandler;\n}\n\n//////////////////////////////////////////\n// Functions iterating traversal.\n// These functions chain results into a single\n// selector.\n//////////////////////////////////////////\nforEach({\n  removeData: JQLiteRemoveData,\n\n  dealoc: JQLiteDealoc,\n\n  bind: function bindFn(element, type, fn){\n    var events = JQLiteExpandoStore(element, 'events'),\n        handle = JQLiteExpandoStore(element, 'handle');\n\n    if (!events) JQLiteExpandoStore(element, 'events', events = {});\n    if (!handle) JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));\n\n    forEach(type.split(' '), function(type){\n      var eventFns = events[type];\n\n      if (!eventFns) {\n        if (type == 'mouseenter' || type == 'mouseleave') {\n          var contains = document.body.contains || document.body.compareDocumentPosition ?\n          function( a, b ) {\n            var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n            return a === bup || !!( bup && bup.nodeType === 1 && (\n              adown.contains ?\n              adown.contains( bup ) :\n              a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n              ));\n            } :\n            function( a, b ) {\n              if ( b ) {\n                while ( (b = b.parentNode) ) {\n                  if ( b === a ) {\n                    return true;\n                  }\n                }\n              }\n              return false;\n            };\t\n\n          events[type] = [];\n\t\t\n\t\t  // Refer to jQuery's implementation of mouseenter & mouseleave\n          // Read about mouseenter and mouseleave:\n          // http://www.quirksmode.org/js/events_mouse.html#link8\n          var eventmap = { mouseleave : \"mouseout\", mouseenter : \"mouseover\"}          \n          bindFn(element, eventmap[type], function(event) {\n            var ret, target = this, related = event.relatedTarget;\n            // For mousenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n            if ( !related || (related !== target && !contains(target, related)) ){\n              handle(event, type);\n            }\t\n\n          });\n\n        } else {\n          addEventListenerFn(element, type, handle);\n          events[type] = [];\n        }\n        eventFns = events[type]\n      }\n      eventFns.push(fn);\n    });\n  },\n\n  unbind: JQLiteUnbind,\n\n  replaceWith: function(element, replaceNode) {\n    var index, parent = element.parentNode;\n    JQLiteDealoc(element);\n    forEach(new JQLite(replaceNode), function(node){\n      if (index) {\n        parent.insertBefore(node, index.nextSibling);\n      } else {\n        parent.replaceChild(node, element);\n      }\n      index = node;\n    });\n  },\n\n  children: function(element) {\n    var children = [];\n    forEach(element.childNodes, function(element){\n      if (element.nodeType === 1)\n        children.push(element);\n    });\n    return children;\n  },\n\n  contents: function(element) {\n    return element.childNodes || [];\n  },\n\n  append: function(element, node) {\n    forEach(new JQLite(node), function(child){\n      if (element.nodeType === 1)\n        element.appendChild(child);\n    });\n  },\n\n  prepend: function(element, node) {\n    if (element.nodeType === 1) {\n      var index = element.firstChild;\n      forEach(new JQLite(node), function(child){\n        element.insertBefore(child, index);\n      });\n    }\n  },\n\n  wrap: function(element, wrapNode) {\n    wrapNode = jqLite(wrapNode)[0];\n    var parent = element.parentNode;\n    if (parent) {\n      parent.replaceChild(wrapNode, element);\n    }\n    wrapNode.appendChild(element);\n  },\n\n  remove: function(element) {\n    JQLiteDealoc(element);\n    var parent = element.parentNode;\n    if (parent) parent.removeChild(element);\n  },\n\n  after: function(element, newElement) {\n    var index = element, parent = element.parentNode;\n    forEach(new JQLite(newElement), function(node){\n      parent.insertBefore(node, index.nextSibling);\n      index = node;\n    });\n  },\n\n  addClass: JQLiteAddClass,\n  removeClass: JQLiteRemoveClass,\n\n  toggleClass: function(element, selector, condition) {\n    if (isUndefined(condition)) {\n      condition = !JQLiteHasClass(element, selector);\n    }\n    (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);\n  },\n\n  parent: function(element) {\n    var parent = element.parentNode;\n    return parent && parent.nodeType !== 11 ? parent : null;\n  },\n\n  next: function(element) {\n    if (element.nextElementSibling) {\n      return element.nextElementSibling;\n    }\n\n    // IE8 doesn't have nextElementSibling\n    var elm = element.nextSibling;\n    while (elm != null && elm.nodeType !== 1) {\n      elm = elm.nextSibling;\n    }\n    return elm;\n  },\n\n  find: function(element, selector) {\n    return element.getElementsByTagName(selector);\n  },\n\n  clone: JQLiteClone,\n\n  triggerHandler: function(element, eventName) {\n    var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];\n\n    forEach(eventFns, function(fn) {\n      fn.call(element, null);\n    });\n  }\n}, function(fn, name){\n  /**\n   * chaining functions\n   */\n  JQLite.prototype[name] = function(arg1, arg2) {\n    var value;\n    for(var i=0; i < this.length; i++) {\n      if (value == undefined) {\n        value = fn(this[i], arg1, arg2);\n        if (value !== undefined) {\n          // any function which returns a value needs to be wrapped\n          value = jqLite(value);\n        }\n      } else {\n        JQLiteAddNodes(value, fn(this[i], arg1, arg2));\n      }\n    }\n    return value == undefined ? this : value;\n  };\n});\n\n/**\n * Computes a hash of an 'obj'.\n * Hash of a:\n *  string is string\n *  number is number as string\n *  object is either result of calling $$hashKey function on the object or uniquely generated id,\n *         that is also assigned to the $$hashKey property of the object.\n *\n * @param obj\n * @returns {string} hash string such that the same input will have the same hash string.\n *         The resulting string key is in 'type:hashKey' format.\n */\nfunction hashKey(obj) {\n  var objType = typeof obj,\n      key;\n\n  if (objType == 'object' && obj !== null) {\n    if (typeof (key = obj.$$hashKey) == 'function') {\n      // must invoke on object to keep the right this\n      key = obj.$$hashKey();\n    } else if (key === undefined) {\n      key = obj.$$hashKey = nextUid();\n    }\n  } else {\n    key = obj;\n  }\n\n  return objType + ':' + key;\n}\n\n/**\n * HashMap which can use objects as keys\n */\nfunction HashMap(array){\n  forEach(array, this.put, this);\n}\nHashMap.prototype = {\n  /**\n   * Store key value pair\n   * @param key key to store can be any type\n   * @param value value to store can be any type\n   */\n  put: function(key, value) {\n    this[hashKey(key)] = value;\n  },\n\n  /**\n   * @param key\n   * @returns the value for the key\n   */\n  get: function(key) {\n    return this[hashKey(key)];\n  },\n\n  /**\n   * Remove the key/value pair\n   * @param key\n   */\n  remove: function(key) {\n    var value = this[key = hashKey(key)];\n    delete this[key];\n    return value;\n  }\n};\n\n/**\n * A map where multiple values can be added to the same key such that they form a queue.\n * @returns {HashQueueMap}\n */\nfunction HashQueueMap() {}\nHashQueueMap.prototype = {\n  /**\n   * Same as array push, but using an array as the value for the hash\n   */\n  push: function(key, value) {\n    var array = this[key = hashKey(key)];\n    if (!array) {\n      this[key] = [value];\n    } else {\n      array.push(value);\n    }\n  },\n\n  /**\n   * Same as array shift, but using an array as the value for the hash\n   */\n  shift: function(key) {\n    var array = this[key = hashKey(key)];\n    if (array) {\n      if (array.length == 1) {\n        delete this[key];\n        return array[0];\n      } else {\n        return array.shift();\n      }\n    }\n  },\n\n  /**\n   * return the first item without deleting it\n   */\n  peek: function(key) {\n    var array = this[hashKey(key)];\n    if (array) {\n    return array[0];\n    }\n  }\n};\n\n/**\n * @ngdoc function\n * @name angular.injector\n * @function\n *\n * @description\n * Creates an injector function that can be used for retrieving services as well as for\n * dependency injection (see {@link guide/di dependency injection}).\n *\n\n * @param {Array.<string|Function>} modules A list of module functions or their aliases. See\n *        {@link angular.module}. The `ng` module must be explicitly added.\n * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.\n *\n * @example\n * Typical usage\n * <pre>\n *   // create an injector\n *   var $injector = angular.injector(['ng']);\n *\n *   // use the injector to kick off your application\n *   // use the type inference to auto inject arguments, or use implicit injection\n *   $injector.invoke(function($rootScope, $compile, $document){\n *     $compile($document)($rootScope);\n *     $rootScope.$digest();\n *   });\n * </pre>\n */\n\n\n/**\n * @ngdoc overview\n * @name AUTO\n * @description\n *\n * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.\n */\n\nvar FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nfunction annotate(fn) {\n  var $inject,\n      fnText,\n      argDecl,\n      last;\n\n  if (typeof fn == 'function') {\n    if (!($inject = fn.$inject)) {\n      $inject = [];\n      fnText = fn.toString().replace(STRIP_COMMENTS, '');\n      argDecl = fnText.match(FN_ARGS);\n      forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){\n        arg.replace(FN_ARG, function(all, underscore, name){\n          $inject.push(name);\n        });\n      });\n      fn.$inject = $inject;\n    }\n  } else if (isArray(fn)) {\n    last = fn.length - 1;\n    assertArgFn(fn[last], 'fn');\n    $inject = fn.slice(0, last);\n  } else {\n    assertArgFn(fn, 'fn', true);\n  }\n  return $inject;\n}\n\n///////////////////////////////////////\n\n/**\n * @ngdoc object\n * @name AUTO.$injector\n * @function\n *\n * @description\n *\n * `$injector` is used to retrieve object instances as defined by\n * {@link AUTO.$provide provider}, instantiate types, invoke methods,\n * and load modules.\n *\n * The following always holds true:\n *\n * <pre>\n *   var $injector = angular.injector();\n *   expect($injector.get('$injector')).toBe($injector);\n *   expect($injector.invoke(function($injector){\n *     return $injector;\n *   }).toBe($injector);\n * </pre>\n *\n * # Injection Function Annotation\n *\n * JavaScript does not have annotations, and annotations are needed for dependency injection. The\n * following are all valid ways of annotating function with injection arguments and are equivalent.\n *\n * <pre>\n *   // inferred (only works if code not minified/obfuscated)\n *   $injector.invoke(function(serviceA){});\n *\n *   // annotated\n *   function explicit(serviceA) {};\n *   explicit.$inject = ['serviceA'];\n *   $injector.invoke(explicit);\n *\n *   // inline\n *   $injector.invoke(['serviceA', function(serviceA){}]);\n * </pre>\n *\n * ## Inference\n *\n * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be\n * parsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation\n * tools since these tools change the argument names.\n *\n * ## `$inject` Annotation\n * By adding a `$inject` property onto a function the injection parameters can be specified.\n *\n * ## Inline\n * As an array of injection names, where the last item in the array is the function to call.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#get\n * @methodOf AUTO.$injector\n *\n * @description\n * Return an instance of the service.\n *\n * @param {string} name The name of the instance to retrieve.\n * @return {*} The instance.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#invoke\n * @methodOf AUTO.$injector\n *\n * @description\n * Invoke the method and supply the method arguments from the `$injector`.\n *\n * @param {!function} fn The function to invoke. The function arguments come form the function annotation.\n * @param {Object=} self The `this` for the invoked method.\n * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before\n *   the `$injector` is consulted.\n * @returns {*} the value returned by the invoked `fn` function.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#instantiate\n * @methodOf AUTO.$injector\n * @description\n * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies\n * all of the arguments to the constructor function as specified by the constructor annotation.\n *\n * @param {function} Type Annotated constructor function.\n * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before\n *   the `$injector` is consulted.\n * @returns {Object} new instance of `Type`.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#annotate\n * @methodOf AUTO.$injector\n *\n * @description\n * Returns an array of service names which the function is requesting for injection. This API is used by the injector\n * to determine which services need to be injected into the function when the function is invoked. There are three\n * ways in which the function can be annotated with the needed dependencies.\n *\n * # Argument names\n *\n * The simplest form is to extract the dependencies from the arguments of the function. This is done by converting\n * the function into a string using `toString()` method and extracting the argument names.\n * <pre>\n *   // Given\n *   function MyController($scope, $route) {\n *     // ...\n *   }\n *\n *   // Then\n *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n * </pre>\n *\n * This method does not work with code minfication / obfuscation. For this reason the following annotation strategies\n * are supported.\n *\n * # The `$inject` property\n *\n * If a function has an `$inject` property and its value is an array of strings, then the strings represent names of\n * services to be injected into the function.\n * <pre>\n *   // Given\n *   var MyController = function(obfuscatedScope, obfuscatedRoute) {\n *     // ...\n *   }\n *   // Define function dependencies\n *   MyController.$inject = ['$scope', '$route'];\n *\n *   // Then\n *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n * </pre>\n *\n * # The array notation\n *\n * It is often desirable to inline Injected functions and that's when setting the `$inject` property is very\n * inconvenient. In these situations using the array notation to specify the dependencies in a way that survives\n * minification is a better choice:\n *\n * <pre>\n *   // We wish to write this (not minification / obfuscation safe)\n *   injector.invoke(function($compile, $rootScope) {\n *     // ...\n *   });\n *\n *   // We are forced to write break inlining\n *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {\n *     // ...\n *   };\n *   tmpFn.$inject = ['$compile', '$rootScope'];\n *   injector.invoke(tmpFn);\n *\n *   // To better support inline function the inline annotation is supported\n *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {\n *     // ...\n *   }]);\n *\n *   // Therefore\n *   expect(injector.annotate(\n *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])\n *    ).toEqual(['$compile', '$rootScope']);\n * </pre>\n *\n * @param {function|Array.<string|Function>} fn Function for which dependent service names need to be retrieved as described\n *   above.\n *\n * @returns {Array.<string>} The names of the services which the function requires.\n */\n\n\n\n\n/**\n * @ngdoc object\n * @name AUTO.$provide\n *\n * @description\n *\n * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.\n * The providers share the same name as the instance they create with `Provider` suffixed to them.\n *\n * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of\n * a service. The Provider can have additional methods which would allow for configuration of the provider.\n *\n * <pre>\n *   function GreetProvider() {\n *     var salutation = 'Hello';\n *\n *     this.salutation = function(text) {\n *       salutation = text;\n *     };\n *\n *     this.$get = function() {\n *       return function (name) {\n *         return salutation + ' ' + name + '!';\n *       };\n *     };\n *   }\n *\n *   describe('Greeter', function(){\n *\n *     beforeEach(module(function($provide) {\n *       $provide.provider('greet', GreetProvider);\n *     }));\n *\n *     it('should greet', inject(function(greet) {\n *       expect(greet('angular')).toEqual('Hello angular!');\n *     }));\n *\n *     it('should allow configuration of salutation', function() {\n *       module(function(greetProvider) {\n *         greetProvider.salutation('Ahoj');\n *       });\n *       inject(function(greet) {\n *         expect(greet('angular')).toEqual('Ahoj angular!');\n *       });\n *     });\n * </pre>\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#provider\n * @methodOf AUTO.$provide\n * @description\n *\n * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.\n *\n * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.\n * @param {(Object|function())} provider If the provider is:\n *\n *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using\n *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.\n *   - `Constructor`: a new instance of the provider will be created using\n *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.\n *\n * @returns {Object} registered provider instance\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#factory\n * @methodOf AUTO.$provide\n * @description\n *\n * A short hand for configuring services if only `$get` method is required.\n *\n * @param {string} name The name of the instance.\n * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for\n * `$provide.provider(name, {$get: $getFn})`.\n * @returns {Object} registered provider instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#service\n * @methodOf AUTO.$provide\n * @description\n *\n * A short hand for registering service of given class.\n *\n * @param {string} name The name of the instance.\n * @param {Function} constructor A class (constructor function) that will be instantiated.\n * @returns {Object} registered provider instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#value\n * @methodOf AUTO.$provide\n * @description\n *\n * A short hand for configuring services if the `$get` method is a constant.\n *\n * @param {string} name The name of the instance.\n * @param {*} value The value.\n * @returns {Object} registered provider instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#constant\n * @methodOf AUTO.$provide\n * @description\n *\n * A constant value, but unlike {@link AUTO.$provide#value value} it can be injected\n * into configuration function (other modules) and it is not interceptable by\n * {@link AUTO.$provide#decorator decorator}.\n *\n * @param {string} name The name of the constant.\n * @param {*} value The constant value.\n * @returns {Object} registered instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#decorator\n * @methodOf AUTO.$provide\n * @description\n *\n * Decoration of service, allows the decorator to intercept the service instance creation. The\n * returned instance may be the original instance, or a new instance which delegates to the\n * original instance.\n *\n * @param {string} name The name of the service to decorate.\n * @param {function()} decorator This function will be invoked when the service needs to be\n *    instantiated. The function is called using the {@link AUTO.$injector#invoke\n *    injector.invoke} method and is therefore fully injectable. Local injection arguments:\n *\n *    * `$delegate` - The original service instance, which can be monkey patched, configured,\n *      decorated or delegated to.\n */\n\n\nfunction createInjector(modulesToLoad) {\n  var INSTANTIATING = {},\n      providerSuffix = 'Provider',\n      path = [],\n      loadedModules = new HashMap(),\n      providerCache = {\n        $provide: {\n            provider: supportObject(provider),\n            factory: supportObject(factory),\n            service: supportObject(service),\n            value: supportObject(value),\n            constant: supportObject(constant),\n            decorator: decorator\n          }\n      },\n      providerInjector = createInternalInjector(providerCache, function() {\n        throw Error(\"Unknown provider: \" + path.join(' <- '));\n      }),\n      instanceCache = {},\n      instanceInjector = (instanceCache.$injector =\n          createInternalInjector(instanceCache, function(servicename) {\n            var provider = providerInjector.get(servicename + providerSuffix);\n            return instanceInjector.invoke(provider.$get, provider);\n          }));\n\n\n  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });\n\n  return instanceInjector;\n\n  ////////////////////////////////////\n  // $provider\n  ////////////////////////////////////\n\n  function supportObject(delegate) {\n    return function(key, value) {\n      if (isObject(key)) {\n        forEach(key, reverseParams(delegate));\n      } else {\n        return delegate(key, value);\n      }\n    }\n  }\n\n  function provider(name, provider_) {\n    if (isFunction(provider_) || isArray(provider_)) {\n      provider_ = providerInjector.instantiate(provider_);\n    }\n    if (!provider_.$get) {\n      throw Error('Provider ' + name + ' must define $get factory method.');\n    }\n    return providerCache[name + providerSuffix] = provider_;\n  }\n\n  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }\n\n  function service(name, constructor) {\n    return factory(name, ['$injector', function($injector) {\n      return $injector.instantiate(constructor);\n    }]);\n  }\n\n  function value(name, value) { return factory(name, valueFn(value)); }\n\n  function constant(name, value) {\n    providerCache[name] = value;\n    instanceCache[name] = value;\n  }\n\n  function decorator(serviceName, decorFn) {\n    var origProvider = providerInjector.get(serviceName + providerSuffix),\n        orig$get = origProvider.$get;\n\n    origProvider.$get = function() {\n      var origInstance = instanceInjector.invoke(orig$get, origProvider);\n      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});\n    };\n  }\n\n  ////////////////////////////////////\n  // Module Loading\n  ////////////////////////////////////\n  function loadModules(modulesToLoad){\n    var runBlocks = [];\n    forEach(modulesToLoad, function(module) {\n      if (loadedModules.get(module)) return;\n      loadedModules.put(module, true);\n      if (isString(module)) {\n        var moduleFn = angularModule(module);\n        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);\n\n        try {\n          for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {\n            var invokeArgs = invokeQueue[i],\n                provider = invokeArgs[0] == '$injector'\n                    ? providerInjector\n                    : providerInjector.get(invokeArgs[0]);\n\n            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);\n          }\n        } catch (e) {\n          if (e.message) e.message += ' from ' + module;\n          throw e;\n        }\n      } else if (isFunction(module)) {\n        try {\n          runBlocks.push(providerInjector.invoke(module));\n        } catch (e) {\n          if (e.message) e.message += ' from ' + module;\n          throw e;\n        }\n      } else if (isArray(module)) {\n        try {\n          runBlocks.push(providerInjector.invoke(module));\n        } catch (e) {\n          if (e.message) e.message += ' from ' + String(module[module.length - 1]);\n          throw e;\n        }\n      } else {\n        assertArgFn(module, 'module');\n      }\n    });\n    return runBlocks;\n  }\n\n  ////////////////////////////////////\n  // internal Injector\n  ////////////////////////////////////\n\n  function createInternalInjector(cache, factory) {\n\n    function getService(serviceName) {\n      if (typeof serviceName !== 'string') {\n        throw Error('Service name expected');\n      }\n      if (cache.hasOwnProperty(serviceName)) {\n        if (cache[serviceName] === INSTANTIATING) {\n          throw Error('Circular dependency: ' + path.join(' <- '));\n        }\n        return cache[serviceName];\n      } else {\n        try {\n          path.unshift(serviceName);\n          cache[serviceName] = INSTANTIATING;\n          return cache[serviceName] = factory(serviceName);\n        } finally {\n          path.shift();\n        }\n      }\n    }\n\n    function invoke(fn, self, locals){\n      var args = [],\n          $inject = annotate(fn),\n          length, i,\n          key;\n\n      for(i = 0, length = $inject.length; i < length; i++) {\n        key = $inject[i];\n        args.push(\n          locals && locals.hasOwnProperty(key)\n          ? locals[key]\n          : getService(key)\n        );\n      }\n      if (!fn.$inject) {\n        // this means that we must be an array.\n        fn = fn[length];\n      }\n\n\n      // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke\n      switch (self ? -1 : args.length) {\n        case  0: return fn();\n        case  1: return fn(args[0]);\n        case  2: return fn(args[0], args[1]);\n        case  3: return fn(args[0], args[1], args[2]);\n        case  4: return fn(args[0], args[1], args[2], args[3]);\n        case  5: return fn(args[0], args[1], args[2], args[3], args[4]);\n        case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);\n        case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n        case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n        case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\n        default: return fn.apply(self, args);\n      }\n    }\n\n    function instantiate(Type, locals) {\n      var Constructor = function() {},\n          instance, returnedValue;\n\n      // Check if Type is annotated and use just the given function at n-1 as parameter\n      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);\n      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;\n      instance = new Constructor();\n      returnedValue = invoke(Type, instance, locals);\n\n      return isObject(returnedValue) ? returnedValue : instance;\n    }\n\n    return {\n      invoke: invoke,\n      instantiate: instantiate,\n      get: getService,\n      annotate: annotate\n    };\n  }\n}\n\n/**\n * @ngdoc function\n * @name ng.$anchorScroll\n * @requires $window\n * @requires $location\n * @requires $rootScope\n *\n * @description\n * When called, it checks current value of `$location.hash()` and scroll to related element,\n * according to rules specified in\n * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.\n *\n * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.\n * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.\n */\nfunction $AnchorScrollProvider() {\n\n  var autoScrollingEnabled = true;\n\n  this.disableAutoScrolling = function() {\n    autoScrollingEnabled = false;\n  };\n\n  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {\n    var document = $window.document;\n\n    // helper function to get first anchor from a NodeList\n    // can't use filter.filter, as it accepts only instances of Array\n    // and IE can't convert NodeList to an array using [].slice\n    // TODO(vojta): use filter if we change it to accept lists as well\n    function getFirstAnchor(list) {\n      var result = null;\n      forEach(list, function(element) {\n        if (!result && lowercase(element.nodeName) === 'a') result = element;\n      });\n      return result;\n    }\n\n    function scroll() {\n      var hash = $location.hash(), elm;\n\n      // empty hash, scroll to the top of the page\n      if (!hash) $window.scrollTo(0, 0);\n\n      // element with given id\n      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();\n\n      // first anchor with given name :-D\n      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();\n\n      // no element and hash == 'top', scroll to the top of the page\n      else if (hash === 'top') $window.scrollTo(0, 0);\n    }\n\n    // does not scroll when user clicks on anchor link that is currently on\n    // (no url change, no $location.hash() change), browser native does scroll\n    if (autoScrollingEnabled) {\n      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},\n        function autoScrollWatchAction() {\n          $rootScope.$evalAsync(scroll);\n        });\n    }\n\n    return scroll;\n  }];\n}\n\n/**\n * ! This is a private undocumented service !\n *\n * @name ng.$browser\n * @requires $log\n * @description\n * This object has two goals:\n *\n * - hide all the global state in the browser caused by the window object\n * - abstract away all the browser specific features and inconsistencies\n *\n * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`\n * service, which can be used for convenient testing of the application without the interaction with\n * the real browser apis.\n */\n/**\n * @param {object} window The global window object.\n * @param {object} document jQuery wrapped document.\n * @param {function()} XHR XMLHttpRequest constructor.\n * @param {object} $log console.log or an object with the same interface.\n * @param {object} $sniffer $sniffer service\n */\nfunction Browser(window, document, $log, $sniffer) {\n  var self = this,\n      rawDocument = document[0],\n      location = window.location,\n      history = window.history,\n      setTimeout = window.setTimeout,\n      clearTimeout = window.clearTimeout,\n      pendingDeferIds = {};\n\n  self.isMock = false;\n\n  var outstandingRequestCount = 0;\n  var outstandingRequestCallbacks = [];\n\n  // TODO(vojta): remove this temporary api\n  self.$$completeOutstandingRequest = completeOutstandingRequest;\n  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };\n\n  /**\n   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`\n   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.\n   */\n  function completeOutstandingRequest(fn) {\n    try {\n      fn.apply(null, sliceArgs(arguments, 1));\n    } finally {\n      outstandingRequestCount--;\n      if (outstandingRequestCount === 0) {\n        while(outstandingRequestCallbacks.length) {\n          try {\n            outstandingRequestCallbacks.pop()();\n          } catch (e) {\n            $log.error(e);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   * Note: this method is used only by scenario runner\n   * TODO(vojta): prefix this method with $$ ?\n   * @param {function()} callback Function that will be called when no outstanding request\n   */\n  self.notifyWhenNoOutstandingRequests = function(callback) {\n    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire\n    // at some deterministic time in respect to the test runner's actions. Leaving things up to the\n    // regular poller would result in flaky tests.\n    forEach(pollFns, function(pollFn){ pollFn(); });\n\n    if (outstandingRequestCount === 0) {\n      callback();\n    } else {\n      outstandingRequestCallbacks.push(callback);\n    }\n  };\n\n  //////////////////////////////////////////////////////////////\n  // Poll Watcher API\n  //////////////////////////////////////////////////////////////\n  var pollFns = [],\n      pollTimeout;\n\n  /**\n   * @name ng.$browser#addPollFn\n   * @methodOf ng.$browser\n   *\n   * @param {function()} fn Poll function to add\n   *\n   * @description\n   * Adds a function to the list of functions that poller periodically executes,\n   * and starts polling if not started yet.\n   *\n   * @returns {function()} the added function\n   */\n  self.addPollFn = function(fn) {\n    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);\n    pollFns.push(fn);\n    return fn;\n  };\n\n  /**\n   * @param {number} interval How often should browser call poll functions (ms)\n   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.\n   *\n   * @description\n   * Configures the poller to run in the specified intervals, using the specified\n   * setTimeout fn and kicks it off.\n   */\n  function startPoller(interval, setTimeout) {\n    (function check() {\n      forEach(pollFns, function(pollFn){ pollFn(); });\n      pollTimeout = setTimeout(check, interval);\n    })();\n  }\n\n  //////////////////////////////////////////////////////////////\n  // URL API\n  //////////////////////////////////////////////////////////////\n\n  var lastBrowserUrl = location.href,\n      baseElement = document.find('base'),\n      replacedUrl = null;\n\n  /**\n   * @name ng.$browser#url\n   * @methodOf ng.$browser\n   *\n   * @description\n   * GETTER:\n   * Without any argument, this method just returns current value of location.href.\n   *\n   * SETTER:\n   * With at least one argument, this method sets url to new value.\n   * If html5 history api supported, pushState/replaceState is used, otherwise\n   * location.href/location.replace is used.\n   * Returns its own instance to allow chaining\n   *\n   * NOTE: this api is intended for use only by the $location service. Please use the\n   * {@link ng.$location $location service} to change url.\n   *\n   * @param {string} url New url (when used as setter)\n   * @param {boolean=} replace Should new url replace current history record ?\n   */\n  self.url = function(url, replace) {\n    // setter\n    if (url) {\n      if (lastBrowserUrl == url) return;\n      lastBrowserUrl = url;\n      if ($sniffer.history) {\n        if (replace) history.replaceState(null, '', url);\n        else {\n          history.pushState(null, '', url);\n          // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462\n          baseElement.attr('href', baseElement.attr('href'));\n        }\n      } else {\n        if (replace) {\n          location.replace(url);\n          replacedUrl = url;\n        } else {\n          location.href = url;\n          replacedUrl = null;\n        }\n      }\n      return self;\n    // getter\n    } else {\n      // - the replacedUrl is a workaround for an IE8-9 issue with location.replace method that doesn't update\n      //   location.href synchronously\n      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172\n      return replacedUrl || location.href.replace(/%27/g,\"'\");\n    }\n  };\n\n  var urlChangeListeners = [],\n      urlChangeInit = false;\n\n  function fireUrlChange() {\n    if (lastBrowserUrl == self.url()) return;\n\n    lastBrowserUrl = self.url();\n    forEach(urlChangeListeners, function(listener) {\n      listener(self.url());\n    });\n  }\n\n  /**\n   * @name ng.$browser#onUrlChange\n   * @methodOf ng.$browser\n   * @TODO(vojta): refactor to use node's syntax for events\n   *\n   * @description\n   * Register callback function that will be called, when url changes.\n   *\n   * It's only called when the url is changed by outside of angular:\n   * - user types different url into address bar\n   * - user clicks on history (forward/back) button\n   * - user clicks on a link\n   *\n   * It's not called when url is changed by $browser.url() method\n   *\n   * The listener gets called with new url as parameter.\n   *\n   * NOTE: this api is intended for use only by the $location service. Please use the\n   * {@link ng.$location $location service} to monitor url changes in angular apps.\n   *\n   * @param {function(string)} listener Listener function to be called when url changes.\n   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.\n   */\n  self.onUrlChange = function(callback) {\n    if (!urlChangeInit) {\n      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)\n      // don't fire popstate when user change the address bar and don't fire hashchange when url\n      // changed by push/replaceState\n\n      // html5 history api - popstate event\n      if ($sniffer.history) jqLite(window).bind('popstate', fireUrlChange);\n      // hashchange event\n      if ($sniffer.hashchange) jqLite(window).bind('hashchange', fireUrlChange);\n      // polling\n      else self.addPollFn(fireUrlChange);\n\n      urlChangeInit = true;\n    }\n\n    urlChangeListeners.push(callback);\n    return callback;\n  };\n\n  //////////////////////////////////////////////////////////////\n  // Misc API\n  //////////////////////////////////////////////////////////////\n\n  /**\n   * Returns current <base href>\n   * (always relative - without domain)\n   *\n   * @returns {string=}\n   */\n  self.baseHref = function() {\n    var href = baseElement.attr('href');\n    return href ? href.replace(/^https?\\:\\/\\/[^\\/]*/, '') : '';\n  };\n\n  //////////////////////////////////////////////////////////////\n  // Cookies API\n  //////////////////////////////////////////////////////////////\n  var lastCookies = {};\n  var lastCookieString = '';\n  var cookiePath = self.baseHref();\n\n  /**\n   * @name ng.$browser#cookies\n   * @methodOf ng.$browser\n   *\n   * @param {string=} name Cookie name\n   * @param {string=} value Cokkie value\n   *\n   * @description\n   * The cookies method provides a 'private' low level access to browser cookies.\n   * It is not meant to be used directly, use the $cookie service instead.\n   *\n   * The return values vary depending on the arguments that the method was called with as follows:\n   * <ul>\n   *   <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>\n   *   <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>\n   *   <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>\n   * </ul>\n   *\n   * @returns {Object} Hash of all cookies (if called without any parameter)\n   */\n  self.cookies = function(name, value) {\n    var cookieLength, cookieArray, cookie, i, index;\n\n    if (name) {\n      if (value === undefined) {\n        rawDocument.cookie = escape(name) + \"=;path=\" + cookiePath + \";expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n      } else {\n        if (isString(value)) {\n          cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;\n\n          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n          // - 300 cookies\n          // - 20 cookies per unique domain\n          // - 4096 bytes per cookie\n          if (cookieLength > 4096) {\n            $log.warn(\"Cookie '\"+ name +\"' possibly not set or overflowed because it was too large (\"+\n              cookieLength + \" > 4096 bytes)!\");\n          }\n        }\n      }\n    } else {\n      if (rawDocument.cookie !== lastCookieString) {\n        lastCookieString = rawDocument.cookie;\n        cookieArray = lastCookieString.split(\"; \");\n        lastCookies = {};\n\n        for (i = 0; i < cookieArray.length; i++) {\n          cookie = cookieArray[i];\n          index = cookie.indexOf('=');\n          if (index > 0) { //ignore nameless cookies\n            var name = unescape(cookie.substring(0, index));\n            // the first value that is seen for a cookie is the most\n            // specific one.  values for the same cookie name that\n            // follow are for less specific paths.\n            if (lastCookies[name] === undefined) {\n              lastCookies[name] = unescape(cookie.substring(index + 1));\n            }\n          }\n        }\n      }\n      return lastCookies;\n    }\n  };\n\n\n  /**\n   * @name ng.$browser#defer\n   * @methodOf ng.$browser\n   * @param {function()} fn A function, who's execution should be defered.\n   * @param {number=} [delay=0] of milliseconds to defer the function execution.\n   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.\n   *\n   * @description\n   * Executes a fn asynchroniously via `setTimeout(fn, delay)`.\n   *\n   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using\n   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed\n   * via `$browser.defer.flush()`.\n   *\n   */\n  self.defer = function(fn, delay) {\n    var timeoutId;\n    outstandingRequestCount++;\n    timeoutId = setTimeout(function() {\n      delete pendingDeferIds[timeoutId];\n      completeOutstandingRequest(fn);\n    }, delay || 0);\n    pendingDeferIds[timeoutId] = true;\n    return timeoutId;\n  };\n\n\n  /**\n   * @name ng.$browser#defer.cancel\n   * @methodOf ng.$browser.defer\n   *\n   * @description\n   * Cancels a defered task identified with `deferId`.\n   *\n   * @param {*} deferId Token returned by the `$browser.defer` function.\n   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfuly canceled.\n   */\n  self.defer.cancel = function(deferId) {\n    if (pendingDeferIds[deferId]) {\n      delete pendingDeferIds[deferId];\n      clearTimeout(deferId);\n      completeOutstandingRequest(noop);\n      return true;\n    }\n    return false;\n  };\n\n}\n\nfunction $BrowserProvider(){\n  this.$get = ['$window', '$log', '$sniffer', '$document',\n      function( $window,   $log,   $sniffer,   $document){\n        return new Browser($window, $document, $log, $sniffer);\n      }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$cacheFactory\n *\n * @description\n * Factory that constructs cache objects and gives access to them.\n * \n * <pre>\n * \n *  var cache = $cacheFactory('cacheId');\n *  expect($cacheFactory.get('cacheId')).toBe(cache);\n *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();\n *\n *  cache.put(\"key\", \"value\");\n *  cache.put(\"another key\", \"another value\");\n * \n *  expect(cache.info()).toEqual({id: 'cacheId', size: 2}); // Since we've specified no options on creation\n * \n * </pre>\n *\n *\n * @param {string} cacheId Name or id of the newly created cache.\n * @param {object=} options Options object that specifies the cache behavior. Properties:\n *\n *   - `{number=}` `capacity` — turns the cache into LRU cache.\n *\n * @returns {object} Newly created cache object with the following set of methods:\n *\n * - `{object}` `info()` — Returns id, size, and options of cache.\n * - `{void}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache.\n * - `{{*}}` `get({string} key)` — Returns cached value for `key` or undefined for cache miss.\n * - `{void}` `remove({string} key)` — Removes a key-value pair from the cache.\n * - `{void}` `removeAll()` — Removes all cached values.\n * - `{void}` `destroy()` — Removes references to this cache from $cacheFactory.\n *\n */\nfunction $CacheFactoryProvider() {\n\n  this.$get = function() {\n    var caches = {};\n\n    function cacheFactory(cacheId, options) {\n      if (cacheId in caches) {\n        throw Error('cacheId ' + cacheId + ' taken');\n      }\n\n      var size = 0,\n          stats = extend({}, options, {id: cacheId}),\n          data = {},\n          capacity = (options && options.capacity) || Number.MAX_VALUE,\n          lruHash = {},\n          freshEnd = null,\n          staleEnd = null;\n\n      return caches[cacheId] = {\n\n        put: function(key, value) {\n          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});\n\n          refresh(lruEntry);\n\n          if (isUndefined(value)) return;\n          if (!(key in data)) size++;\n          data[key] = value;\n\n          if (size > capacity) {\n            this.remove(staleEnd.key);\n          }\n        },\n\n\n        get: function(key) {\n          var lruEntry = lruHash[key];\n\n          if (!lruEntry) return;\n\n          refresh(lruEntry);\n\n          return data[key];\n        },\n\n\n        remove: function(key) {\n          var lruEntry = lruHash[key];\n\n          if (!lruEntry) return;\n\n          if (lruEntry == freshEnd) freshEnd = lruEntry.p;\n          if (lruEntry == staleEnd) staleEnd = lruEntry.n;\n          link(lruEntry.n,lruEntry.p);\n\n          delete lruHash[key];\n          delete data[key];\n          size--;\n        },\n\n\n        removeAll: function() {\n          data = {};\n          size = 0;\n          lruHash = {};\n          freshEnd = staleEnd = null;\n        },\n\n\n        destroy: function() {\n          data = null;\n          stats = null;\n          lruHash = null;\n          delete caches[cacheId];\n        },\n\n\n        info: function() {\n          return extend({}, stats, {size: size});\n        }\n      };\n\n\n      /**\n       * makes the `entry` the freshEnd of the LRU linked list\n       */\n      function refresh(entry) {\n        if (entry != freshEnd) {\n          if (!staleEnd) {\n            staleEnd = entry;\n          } else if (staleEnd == entry) {\n            staleEnd = entry.n;\n          }\n\n          link(entry.n, entry.p);\n          link(entry, freshEnd);\n          freshEnd = entry;\n          freshEnd.n = null;\n        }\n      }\n\n\n      /**\n       * bidirectionally links two entries of the LRU linked list\n       */\n      function link(nextEntry, prevEntry) {\n        if (nextEntry != prevEntry) {\n          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify\n          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify\n        }\n      }\n    }\n\n\n  /**\n   * @ngdoc method\n   * @name ng.$cacheFactory#info\n   * @methodOf ng.$cacheFactory\n   *\n   * @description\n   * Get information about all the of the caches that have been created\n   *\n   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`\n   */\n    cacheFactory.info = function() {\n      var info = {};\n      forEach(caches, function(cache, cacheId) {\n        info[cacheId] = cache.info();\n      });\n      return info;\n    };\n\n\n  /**\n   * @ngdoc method\n   * @name ng.$cacheFactory#get\n   * @methodOf ng.$cacheFactory\n   *\n   * @description\n   * Get access to a cache object by the `cacheId` used when it was created.\n   *\n   * @param {string} cacheId Name or id of a cache to access.\n   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.\n   */\n    cacheFactory.get = function(cacheId) {\n      return caches[cacheId];\n    };\n\n\n    return cacheFactory;\n  };\n}\n\n/**\n * @ngdoc object\n * @name ng.$templateCache\n *\n * @description\n * The first time a template is used, it is loaded in the template cache for quick retrieval.  You can \n * load templates directly into the cache in a `script` tag, or by consuming the `$templateCache` \n * service directly.\n * \n * Adding via the `script` tag:\n * <pre>\n * <html ng-app>\n * <head>\n * <script type=\"text/ng-template\" id=\"templateId.html\">\n *   This is the content of the template\n * </script>\n * </head>\n *   ...\n * </html>\n * </pre>\n * \n * **Note:** the `script` tag containing the template does not need to be included in the `head` of the document, but \n * it must be below the `ng-app` definition.\n * \n * Adding via the $templateCache service:\n * \n * <pre>\n * var myApp = angular.module('myApp', []);\n * myApp.run(function($templateCache) {\n *   $templateCache.put('templateId.html', 'This is the content of the template');\n * });\n * </pre>\n * \n * To retrieve the template later, simply use it in your HTML:\n * <pre>\n * <div ng-include=\" 'templateId.html' \"></div>\n * </pre>\n * \n * or get it via Javascript:\n * <pre>\n * $templateCache.get('templateId.html')\n * </pre>\n * \n * See {@link ng.$cacheFactory $cacheFactory}.\n *\n */\nfunction $TemplateCacheProvider() {\n  this.$get = ['$cacheFactory', function($cacheFactory) {\n    return $cacheFactory('templates');\n  }];\n}\n\n/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!\n *\n * DOM-related variables:\n *\n * - \"node\" - DOM Node\n * - \"element\" - DOM Element or Node\n * - \"$node\" or \"$element\" - jqLite-wrapped node or element\n *\n *\n * Compiler related stuff:\n *\n * - \"linkFn\" - linking fn of a single directive\n * - \"nodeLinkFn\" - function that aggregates all linking fns for a particular node\n * - \"childLinkFn\" -  function that aggregates all linking fns for child nodes of a particular node\n * - \"compositeLinkFn\" - function that aggregates all linking fns for a compilation root (nodeList)\n */\n\n\nvar NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';\n\n\n/**\n * @ngdoc function\n * @name ng.$compile\n * @function\n *\n * @description\n * Compiles a piece of HTML string or DOM into a template and produces a template function, which\n * can then be used to link {@link ng.$rootScope.Scope scope} and the template together.\n *\n * The compilation is a process of walking the DOM tree and trying to match DOM elements to\n * {@link ng.$compileProvider#directive directives}. For each match it\n * executes corresponding template function and collects the\n * instance functions into a single template function which is then returned.\n *\n * The template function can then be used once to produce the view or as it is the case with\n * {@link ng.directive:ngRepeat repeater} many-times, in which\n * case each call results in a view that is a DOM clone of the original template.\n *\n <doc:example module=\"compile\">\n   <doc:source>\n    <script>\n      // declare a new module, and inject the $compileProvider\n      angular.module('compile', [], function($compileProvider) {\n        // configure new 'compile' directive by passing a directive\n        // factory function. The factory function injects the '$compile'\n        $compileProvider.directive('compile', function($compile) {\n          // directive factory creates a link function\n          return function(scope, element, attrs) {\n            scope.$watch(\n              function(scope) {\n                 // watch the 'compile' expression for changes\n                return scope.$eval(attrs.compile);\n              },\n              function(value) {\n                // when the 'compile' expression changes\n                // assign it into the current DOM\n                element.html(value);\n\n                // compile the new DOM and link it to the current\n                // scope.\n                // NOTE: we only compile .childNodes so that\n                // we don't get into infinite loop compiling ourselves\n                $compile(element.contents())(scope);\n              }\n            );\n          };\n        })\n      });\n\n      function Ctrl($scope) {\n        $scope.name = 'Angular';\n        $scope.html = 'Hello {{name}}';\n      }\n    </script>\n    <div ng-controller=\"Ctrl\">\n      <input ng-model=\"name\"> <br>\n      <textarea ng-model=\"html\"></textarea> <br>\n      <div compile=\"html\"></div>\n    </div>\n   </doc:source>\n   <doc:scenario>\n     it('should auto compile', function() {\n       expect(element('div[compile]').text()).toBe('Hello Angular');\n       input('html').enter('{{name}}!');\n       expect(element('div[compile]').text()).toBe('Angular!');\n     });\n   </doc:scenario>\n </doc:example>\n\n *\n *\n * @param {string|DOMElement} element Element or HTML string to compile into a template function.\n * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.\n * @param {number} maxPriority only apply directives lower then given priority (Only effects the\n *                 root element(s), not their children)\n * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template\n * (a DOM element/tree) to a scope. Where:\n *\n *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.\n *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the\n *               `template` and call the `cloneAttachFn` function allowing the caller to attach the\n *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is\n *               called as: <br> `cloneAttachFn(clonedElement, scope)` where:\n *\n *      * `clonedElement` - is a clone of the original `element` passed into the compiler.\n *      * `scope` - is the current scope with which the linking function is working with.\n *\n * Calling the linking function returns the element of the template. It is either the original element\n * passed in, or the clone of the element if the `cloneAttachFn` is provided.\n *\n * After linking the view is not updated until after a call to $digest which typically is done by\n * Angular automatically.\n *\n * If you need access to the bound view, there are two ways to do it:\n *\n * - If you are not asking the linking function to clone the template, create the DOM element(s)\n *   before you send them to the compiler and keep this reference around.\n *   <pre>\n *     var element = $compile('<p>{{total}}</p>')(scope);\n *   </pre>\n *\n * - if on the other hand, you need the element to be cloned, the view reference from the original\n *   example would not point to the clone, but rather to the original template that was cloned. In\n *   this case, you can access the clone via the cloneAttachFn:\n *   <pre>\n *     var templateHTML = angular.element('<p>{{total}}</p>'),\n *         scope = ....;\n *\n *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {\n *       //attach the clone to DOM document at the right place\n *     });\n *\n *     //now we have reference to the cloned DOM via `clone`\n *   </pre>\n *\n *\n * For information on how the compiler works, see the\n * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.\n */\n\n\n/**\n * @ngdoc service\n * @name ng.$compileProvider\n * @function\n *\n * @description\n */\n$CompileProvider.$inject = ['$provide'];\nfunction $CompileProvider($provide) {\n  var hasDirectives = {},\n      Suffix = 'Directive',\n      COMMENT_DIRECTIVE_REGEXP = /^\\s*directive\\:\\s*([\\d\\w\\-_]+)\\s+(.*)$/,\n      CLASS_DIRECTIVE_REGEXP = /(([\\d\\w\\-_]+)(?:\\:([^;]+))?;?)/,\n      MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ',\n      urlSanitizationWhitelist = /^\\s*(https?|ftp|mailto|file):/;\n\n\n  /**\n   * @ngdoc function\n   * @name ng.$compileProvider#directive\n   * @methodOf ng.$compileProvider\n   * @function\n   *\n   * @description\n   * Register a new directive with the compiler.\n   *\n   * @param {string} name Name of the directive in camel-case. (ie <code>ngBind</code> which will match as\n   *                <code>ng-bind</code>).\n   * @param {function|Array} directiveFactory An injectable directive factory function. See {@link guide/directive} for more\n   *                info.\n   * @returns {ng.$compileProvider} Self for chaining.\n   */\n   this.directive = function registerDirective(name, directiveFactory) {\n    if (isString(name)) {\n      assertArg(directiveFactory, 'directive');\n      if (!hasDirectives.hasOwnProperty(name)) {\n        hasDirectives[name] = [];\n        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',\n          function($injector, $exceptionHandler) {\n            var directives = [];\n            forEach(hasDirectives[name], function(directiveFactory) {\n              try {\n                var directive = $injector.invoke(directiveFactory);\n                if (isFunction(directive)) {\n                  directive = { compile: valueFn(directive) };\n                } else if (!directive.compile && directive.link) {\n                  directive.compile = valueFn(directive.link);\n                }\n                directive.priority = directive.priority || 0;\n                directive.name = directive.name || name;\n                directive.require = directive.require || (directive.controller && directive.name);\n                directive.restrict = directive.restrict || 'A';\n                directives.push(directive);\n              } catch (e) {\n                $exceptionHandler(e);\n              }\n            });\n            return directives;\n          }]);\n      }\n      hasDirectives[name].push(directiveFactory);\n    } else {\n      forEach(name, reverseParams(registerDirective));\n    }\n    return this;\n  };\n\n\n  /**\n   * @ngdoc function\n   * @name ng.$compileProvider#urlSanitizationWhitelist\n   * @methodOf ng.$compileProvider\n   * @function\n   *\n   * @description\n   * Retrieves or overrides the default regular expression that is used for whitelisting of safe\n   * urls during a[href] sanitization.\n   *\n   * The sanitization is a security measure aimed at prevent XSS attacks via html links.\n   *\n   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into an\n   * absolute url. Afterwards the url is matched against the `urlSanitizationWhitelist` regular\n   * expression. If a match is found the original url is written into the dom. Otherwise the\n   * absolute url is prefixed with `'unsafe:'` string and only then it is written into the DOM.\n   *\n   * @param {RegExp=} regexp New regexp to whitelist urls with.\n   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for\n   *    chaining otherwise.\n   */\n  this.urlSanitizationWhitelist = function(regexp) {\n    if (isDefined(regexp)) {\n      urlSanitizationWhitelist = regexp;\n      return this;\n    }\n    return urlSanitizationWhitelist;\n  };\n\n\n  this.$get = [\n            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',\n            '$controller', '$rootScope', '$document',\n    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,\n             $controller,   $rootScope,   $document) {\n\n    var Attributes = function(element, attr) {\n      this.$$element = element;\n      this.$attr = attr || {};\n    };\n\n    Attributes.prototype = {\n      $normalize: directiveNormalize,\n\n\n      /**\n       * Set a normalized attribute on the element in a way such that all directives\n       * can share the attribute. This function properly handles boolean attributes.\n       * @param {string} key Normalized key. (ie ngAttribute)\n       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.\n       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.\n       *     Defaults to true.\n       * @param {string=} attrName Optional none normalized name. Defaults to key.\n       */\n      $set: function(key, value, writeAttr, attrName) {\n        var booleanKey = getBooleanAttrName(this.$$element[0], key),\n            $$observers = this.$$observers,\n            normalizedVal;\n\n        if (booleanKey) {\n          this.$$element.prop(key, value);\n          attrName = booleanKey;\n        }\n\n        this[key] = value;\n\n        // translate normalized key to actual key\n        if (attrName) {\n          this.$attr[key] = attrName;\n        } else {\n          attrName = this.$attr[key];\n          if (!attrName) {\n            this.$attr[key] = attrName = snake_case(key, '-');\n          }\n        }\n\n\n        // sanitize a[href] values\n        if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {\n          urlSanitizationNode.setAttribute('href', value);\n\n          // href property always returns normalized absolute url, so we can match against that\n          normalizedVal = urlSanitizationNode.href;\n          if (normalizedVal !== '' && !normalizedVal.match(urlSanitizationWhitelist)) {\n            this[key] = value = 'unsafe:' + normalizedVal;\n          }\n        }\n\n\n        if (writeAttr !== false) {\n          if (value === null || value === undefined) {\n            this.$$element.removeAttr(attrName);\n          } else {\n            this.$$element.attr(attrName, value);\n          }\n        }\n\n        // fire observers\n        $$observers && forEach($$observers[key], function(fn) {\n          try {\n            fn(value);\n          } catch (e) {\n            $exceptionHandler(e);\n          }\n        });\n      },\n\n\n      /**\n       * Observe an interpolated attribute.\n       * The observer will never be called, if given attribute is not interpolated.\n       *\n       * @param {string} key Normalized key. (ie ngAttribute) .\n       * @param {function(*)} fn Function that will be called whenever the attribute value changes.\n       * @returns {function(*)} the `fn` Function passed in.\n       */\n      $observe: function(key, fn) {\n        var attrs = this,\n            $$observers = (attrs.$$observers || (attrs.$$observers = {})),\n            listeners = ($$observers[key] || ($$observers[key] = []));\n\n        listeners.push(fn);\n        $rootScope.$evalAsync(function() {\n          if (!listeners.$$inter) {\n            // no one registered attribute interpolation function, so lets call it manually\n            fn(attrs[key]);\n          }\n        });\n        return fn;\n      }\n    };\n\n    var urlSanitizationNode = $document[0].createElement('a'),\n        startSymbol = $interpolate.startSymbol(),\n        endSymbol = $interpolate.endSymbol(),\n        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')\n            ? identity\n            : function denormalizeTemplate(template) {\n              return template.replace(/\\{\\{/g, startSymbol).replace(/}}/g, endSymbol);\n            };\n\n\n    return compile;\n\n    //================================\n\n    function compile($compileNodes, transcludeFn, maxPriority) {\n      if (!($compileNodes instanceof jqLite)) {\n        // jquery always rewraps, whereas we need to preserve the original selector so that we can modify it.\n        $compileNodes = jqLite($compileNodes);\n      }\n      // We can not compile top level text elements since text nodes can be merged and we will\n      // not be able to attach scope data to them, so we will wrap them in <span>\n      forEach($compileNodes, function(node, index){\n        if (node.nodeType == 3 /* text node */ && node.nodeValue.match(/\\S+/) /* non-empty */ ) {\n          $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];\n        }\n      });\n      var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);\n      return function publicLinkFn(scope, cloneConnectFn){\n        assertArg(scope, 'scope');\n        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart\n        // and sometimes changes the structure of the DOM.\n        var $linkNode = cloneConnectFn\n          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!\n          : $compileNodes;\n\n        // Attach scope only to non-text nodes.\n        for(var i = 0, ii = $linkNode.length; i<ii; i++) {\n          var node = $linkNode[i];\n          if (node.nodeType == 1 /* element */ || node.nodeType == 9 /* document */) {\n            $linkNode.eq(i).data('$scope', scope);\n          }\n        }\n        safeAddClass($linkNode, 'ng-scope');\n        if (cloneConnectFn) cloneConnectFn($linkNode, scope);\n        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);\n        return $linkNode;\n      };\n    }\n\n    function wrongMode(localName, mode) {\n      throw Error(\"Unsupported '\" + mode + \"' for '\" + localName + \"'.\");\n    }\n\n    function safeAddClass($element, className) {\n      try {\n        $element.addClass(className);\n      } catch(e) {\n        // ignore, since it means that we are trying to set class on\n        // SVG element, where class name is read-only.\n      }\n    }\n\n    /**\n     * Compile function matches each node in nodeList against the directives. Once all directives\n     * for a particular node are collected their compile functions are executed. The compile\n     * functions return values - the linking functions - are combined into a composite linking\n     * function, which is the a linking function for the node.\n     *\n     * @param {NodeList} nodeList an array of nodes or NodeList to compile\n     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the\n     *        scope argument is auto-generated to the new child of the transcluded parent scope.\n     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then the\n     *        rootElement must be set the jqLite collection of the compile root. This is\n     *        needed so that the jqLite collection items can be replaced with widgets.\n     * @param {number=} max directive priority\n     * @returns {?function} A composite linking function of all of the matched directives or null.\n     */\n    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {\n      var linkFns = [],\n          nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;\n\n      for(var i = 0; i < nodeList.length; i++) {\n        attrs = new Attributes();\n\n        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.\n        directives = collectDirectives(nodeList[i], [], attrs, maxPriority);\n\n        nodeLinkFn = (directives.length)\n            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement)\n            : null;\n\n        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length)\n            ? null\n            : compileNodes(nodeList[i].childNodes,\n                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);\n\n        linkFns.push(nodeLinkFn);\n        linkFns.push(childLinkFn);\n        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);\n      }\n\n      // return a linking function if we have found anything, null otherwise\n      return linkFnFound ? compositeLinkFn : null;\n\n      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {\n        var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;\n\n        // copy nodeList so that linking doesn't break due to live list updates.\n        var stableNodeList = [];\n        for (i = 0, ii = nodeList.length; i < ii; i++) {\n          stableNodeList.push(nodeList[i]);\n        }\n\n        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {\n          node = stableNodeList[n];\n          nodeLinkFn = linkFns[i++];\n          childLinkFn = linkFns[i++];\n\n          if (nodeLinkFn) {\n            if (nodeLinkFn.scope) {\n              childScope = scope.$new(isObject(nodeLinkFn.scope));\n              jqLite(node).data('$scope', childScope);\n            } else {\n              childScope = scope;\n            }\n            childTranscludeFn = nodeLinkFn.transclude;\n            if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {\n              nodeLinkFn(childLinkFn, childScope, node, $rootElement,\n                  (function(transcludeFn) {\n                    return function(cloneFn) {\n                      var transcludeScope = scope.$new();\n                      transcludeScope.$$transcluded = true;\n\n                      return transcludeFn(transcludeScope, cloneFn).\n                          bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));\n                    };\n                  })(childTranscludeFn || transcludeFn)\n              );\n            } else {\n              nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);\n            }\n          } else if (childLinkFn) {\n            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);\n          }\n        }\n      }\n    }\n\n\n    /**\n     * Looks for directives on the given node and adds them to the directive collection which is\n     * sorted.\n     *\n     * @param node Node to search.\n     * @param directives An array to which the directives are added to. This array is sorted before\n     *        the function returns.\n     * @param attrs The shared attrs object which is used to populate the normalized attributes.\n     * @param {number=} maxPriority Max directive priority.\n     */\n    function collectDirectives(node, directives, attrs, maxPriority) {\n      var nodeType = node.nodeType,\n          attrsMap = attrs.$attr,\n          match,\n          className;\n\n      switch(nodeType) {\n        case 1: /* Element */\n          // use the node name: <directive>\n          addDirective(directives,\n              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);\n\n          // iterate over the attributes\n          for (var attr, name, nName, value, nAttrs = node.attributes,\n                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {\n            attr = nAttrs[j];\n            if (!msie || msie >= 8 || attr.specified) {\n              name = attr.name;\n              nName = directiveNormalize(name.toLowerCase());\n              attrsMap[nName] = name;\n              attrs[nName] = value = trim((msie && name == 'href')\n                ? decodeURIComponent(node.getAttribute(name, 2))\n                : attr.value);\n              if (getBooleanAttrName(node, nName)) {\n                attrs[nName] = true; // presence means true\n              }\n              addAttrInterpolateDirective(node, directives, value, nName);\n              addDirective(directives, nName, 'A', maxPriority);\n            }\n          }\n\n          // use class as directive\n          className = node.className;\n          if (isString(className) && className !== '') {\n            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {\n              nName = directiveNormalize(match[2]);\n              if (addDirective(directives, nName, 'C', maxPriority)) {\n                attrs[nName] = trim(match[3]);\n              }\n              className = className.substr(match.index + match[0].length);\n            }\n          }\n          break;\n        case 3: /* Text Node */\n          addTextInterpolateDirective(directives, node.nodeValue);\n          break;\n        case 8: /* Comment */\n          try {\n            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);\n            if (match) {\n              nName = directiveNormalize(match[1]);\n              if (addDirective(directives, nName, 'M', maxPriority)) {\n                attrs[nName] = trim(match[2]);\n              }\n            }\n          } catch (e) {\n            // turns out that under some circumstances IE9 throws errors when one attempts to read comment's node value.\n            // Just ignore it and continue. (Can't seem to reproduce in test case.)\n          }\n          break;\n      }\n\n      directives.sort(byPriority);\n      return directives;\n    }\n\n\n    /**\n     * Once the directives have been collected, their compile functions are executed. This method\n     * is responsible for inlining directive templates as well as terminating the application\n     * of the directives if the terminal directive has been reached.\n     *\n     * @param {Array} directives Array of collected directives to execute their compile function.\n     *        this needs to be pre-sorted by priority order.\n     * @param {Node} compileNode The raw DOM node to apply the compile functions to\n     * @param {Object} templateAttrs The shared attribute function\n     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the\n     *        scope argument is auto-generated to the new child of the transcluded parent scope.\n     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this\n     *        argument has the root jqLite array so that we can replace nodes on it.\n     * @returns linkFn\n     */\n    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {\n      var terminalPriority = -Number.MAX_VALUE,\n          preLinkFns = [],\n          postLinkFns = [],\n          newScopeDirective = null,\n          newIsolateScopeDirective = null,\n          templateDirective = null,\n          $compileNode = templateAttrs.$$element = jqLite(compileNode),\n          directive,\n          directiveName,\n          $template,\n          transcludeDirective,\n          childTranscludeFn = transcludeFn,\n          controllerDirectives,\n          linkFn,\n          directiveValue;\n\n      // executes all directives on the current element\n      for(var i = 0, ii = directives.length; i < ii; i++) {\n        directive = directives[i];\n        $template = undefined;\n\n        if (terminalPriority > directive.priority) {\n          break; // prevent further processing of directives\n        }\n\n        if (directiveValue = directive.scope) {\n          assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);\n          if (isObject(directiveValue)) {\n            safeAddClass($compileNode, 'ng-isolate-scope');\n            newIsolateScopeDirective = directive;\n          }\n          safeAddClass($compileNode, 'ng-scope');\n          newScopeDirective = newScopeDirective || directive;\n        }\n\n        directiveName = directive.name;\n\n        if (directiveValue = directive.controller) {\n          controllerDirectives = controllerDirectives || {};\n          assertNoDuplicate(\"'\" + directiveName + \"' controller\",\n              controllerDirectives[directiveName], directive, $compileNode);\n          controllerDirectives[directiveName] = directive;\n        }\n\n        if (directiveValue = directive.transclude) {\n          assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);\n          transcludeDirective = directive;\n          terminalPriority = directive.priority;\n          if (directiveValue == 'element') {\n            $template = jqLite(compileNode);\n            $compileNode = templateAttrs.$$element =\n                jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));\n            compileNode = $compileNode[0];\n            replaceWith(jqCollection, jqLite($template[0]), compileNode);\n            childTranscludeFn = compile($template, transcludeFn, terminalPriority);\n          } else {\n            $template = jqLite(JQLiteClone(compileNode)).contents();\n            $compileNode.html(''); // clear contents\n            childTranscludeFn = compile($template, transcludeFn);\n          }\n        }\n\n        if ((directiveValue = directive.template)) {\n          assertNoDuplicate('template', templateDirective, directive, $compileNode);\n          templateDirective = directive;\n          directiveValue = denormalizeTemplate(directiveValue);\n\n          if (directive.replace) {\n            $template = jqLite('<div>' +\n                                 trim(directiveValue) +\n                               '</div>').contents();\n            compileNode = $template[0];\n\n            if ($template.length != 1 || compileNode.nodeType !== 1) {\n              throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);\n            }\n\n            replaceWith(jqCollection, $compileNode, compileNode);\n\n            var newTemplateAttrs = {$attr: {}};\n\n            // combine directives from the original node and from the template:\n            // - take the array of directives for this element\n            // - split it into two parts, those that were already applied and those that weren't\n            // - collect directives from the template, add them to the second group and sort them\n            // - append the second group with new directives to the first group\n            directives = directives.concat(\n                collectDirectives(\n                    compileNode,\n                    directives.splice(i + 1, directives.length - (i + 1)),\n                    newTemplateAttrs\n                )\n            );\n            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);\n\n            ii = directives.length;\n          } else {\n            $compileNode.html(directiveValue);\n          }\n        }\n\n        if (directive.templateUrl) {\n          assertNoDuplicate('template', templateDirective, directive, $compileNode);\n          templateDirective = directive;\n          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i),\n              nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace,\n              childTranscludeFn);\n          ii = directives.length;\n        } else if (directive.compile) {\n          try {\n            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);\n            if (isFunction(linkFn)) {\n              addLinkFns(null, linkFn);\n            } else if (linkFn) {\n              addLinkFns(linkFn.pre, linkFn.post);\n            }\n          } catch (e) {\n            $exceptionHandler(e, startingTag($compileNode));\n          }\n        }\n\n        if (directive.terminal) {\n          nodeLinkFn.terminal = true;\n          terminalPriority = Math.max(terminalPriority, directive.priority);\n        }\n\n      }\n\n      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;\n      nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;\n\n      // might be normal or delayed nodeLinkFn depending on if templateUrl is present\n      return nodeLinkFn;\n\n      ////////////////////\n\n      function addLinkFns(pre, post) {\n        if (pre) {\n          pre.require = directive.require;\n          preLinkFns.push(pre);\n        }\n        if (post) {\n          post.require = directive.require;\n          postLinkFns.push(post);\n        }\n      }\n\n\n      function getControllers(require, $element) {\n        var value, retrievalMethod = 'data', optional = false;\n        if (isString(require)) {\n          while((value = require.charAt(0)) == '^' || value == '?') {\n            require = require.substr(1);\n            if (value == '^') {\n              retrievalMethod = 'inheritedData';\n            }\n            optional = optional || value == '?';\n          }\n          value = $element[retrievalMethod]('$' + require + 'Controller');\n          if (!value && !optional) {\n            throw Error(\"No controller: \" + require);\n          }\n          return value;\n        } else if (isArray(require)) {\n          value = [];\n          forEach(require, function(require) {\n            value.push(getControllers(require, $element));\n          });\n        }\n        return value;\n      }\n\n\n      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {\n        var attrs, $element, i, ii, linkFn, controller;\n\n        if (compileNode === linkNode) {\n          attrs = templateAttrs;\n        } else {\n          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));\n        }\n        $element = attrs.$$element;\n\n        if (newIsolateScopeDirective) {\n          var LOCAL_REGEXP = /^\\s*([@=&])\\s*(\\w*)\\s*$/;\n\n          var parentScope = scope.$parent || scope;\n\n          forEach(newIsolateScopeDirective.scope, function(definiton, scopeName) {\n            var match = definiton.match(LOCAL_REGEXP) || [],\n                attrName = match[2]|| scopeName,\n                mode = match[1], // @, =, or &\n                lastValue,\n                parentGet, parentSet;\n\n            scope.$$isolateBindings[scopeName] = mode + attrName;\n\n            switch (mode) {\n\n              case '@': {\n                attrs.$observe(attrName, function(value) {\n                  scope[scopeName] = value;\n                });\n                attrs.$$observers[attrName].$$scope = parentScope;\n                break;\n              }\n\n              case '=': {\n                parentGet = $parse(attrs[attrName]);\n                parentSet = parentGet.assign || function() {\n                  // reset the change, or we will throw this exception on every $digest\n                  lastValue = scope[scopeName] = parentGet(parentScope);\n                  throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] +\n                      ' (directive: ' + newIsolateScopeDirective.name + ')');\n                };\n                lastValue = scope[scopeName] = parentGet(parentScope);\n                scope.$watch(function parentValueWatch() {\n                  var parentValue = parentGet(parentScope);\n\n                  if (parentValue !== scope[scopeName]) {\n                    // we are out of sync and need to copy\n                    if (parentValue !== lastValue) {\n                      // parent changed and it has precedence\n                      lastValue = scope[scopeName] = parentValue;\n                    } else {\n                      // if the parent can be assigned then do so\n                      parentSet(parentScope, parentValue = lastValue = scope[scopeName]);\n                    }\n                  }\n                  return parentValue;\n                });\n                break;\n              }\n\n              case '&': {\n                parentGet = $parse(attrs[attrName]);\n                scope[scopeName] = function(locals) {\n                  return parentGet(parentScope, locals);\n                };\n                break;\n              }\n\n              default: {\n                throw Error('Invalid isolate scope definition for directive ' +\n                    newIsolateScopeDirective.name + ': ' + definiton);\n              }\n            }\n          });\n        }\n\n        if (controllerDirectives) {\n          forEach(controllerDirectives, function(directive) {\n            var locals = {\n              $scope: scope,\n              $element: $element,\n              $attrs: attrs,\n              $transclude: boundTranscludeFn\n            };\n\n            controller = directive.controller;\n            if (controller == '@') {\n              controller = attrs[directive.name];\n            }\n\n            $element.data(\n                '$' + directive.name + 'Controller',\n                $controller(controller, locals));\n          });\n        }\n\n        // PRELINKING\n        for(i = 0, ii = preLinkFns.length; i < ii; i++) {\n          try {\n            linkFn = preLinkFns[i];\n            linkFn(scope, $element, attrs,\n                linkFn.require && getControllers(linkFn.require, $element));\n          } catch (e) {\n            $exceptionHandler(e, startingTag($element));\n          }\n        }\n\n        // RECURSION\n        childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);\n\n        // POSTLINKING\n        for(i = 0, ii = postLinkFns.length; i < ii; i++) {\n          try {\n            linkFn = postLinkFns[i];\n            linkFn(scope, $element, attrs,\n                linkFn.require && getControllers(linkFn.require, $element));\n          } catch (e) {\n            $exceptionHandler(e, startingTag($element));\n          }\n        }\n      }\n    }\n\n\n    /**\n     * looks up the directive and decorates it with exception handling and proper parameters. We\n     * call this the boundDirective.\n     *\n     * @param {string} name name of the directive to look up.\n     * @param {string} location The directive must be found in specific format.\n     *   String containing any of theses characters:\n     *\n     *   * `E`: element name\n     *   * `A': attribute\n     *   * `C`: class\n     *   * `M`: comment\n     * @returns true if directive was added.\n     */\n    function addDirective(tDirectives, name, location, maxPriority) {\n      var match = false;\n      if (hasDirectives.hasOwnProperty(name)) {\n        for(var directive, directives = $injector.get(name + Suffix),\n            i = 0, ii = directives.length; i<ii; i++) {\n          try {\n            directive = directives[i];\n            if ( (maxPriority === undefined || maxPriority > directive.priority) &&\n                 directive.restrict.indexOf(location) != -1) {\n              tDirectives.push(directive);\n              match = true;\n            }\n          } catch(e) { $exceptionHandler(e); }\n        }\n      }\n      return match;\n    }\n\n\n    /**\n     * When the element is replaced with HTML template then the new attributes\n     * on the template need to be merged with the existing attributes in the DOM.\n     * The desired effect is to have both of the attributes present.\n     *\n     * @param {object} dst destination attributes (original DOM)\n     * @param {object} src source attributes (from the directive template)\n     */\n    function mergeTemplateAttributes(dst, src) {\n      var srcAttr = src.$attr,\n          dstAttr = dst.$attr,\n          $element = dst.$$element;\n\n      // reapply the old attributes to the new element\n      forEach(dst, function(value, key) {\n        if (key.charAt(0) != '$') {\n          if (src[key]) {\n            value += (key === 'style' ? ';' : ' ') + src[key];\n          }\n          dst.$set(key, value, true, srcAttr[key]);\n        }\n      });\n\n      // copy the new attributes on the old attrs object\n      forEach(src, function(value, key) {\n        if (key == 'class') {\n          safeAddClass($element, value);\n          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;\n        } else if (key == 'style') {\n          $element.attr('style', $element.attr('style') + ';' + value);\n        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {\n          dst[key] = value;\n          dstAttr[key] = srcAttr[key];\n        }\n      });\n    }\n\n\n    function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs,\n        $rootElement, replace, childTranscludeFn) {\n      var linkQueue = [],\n          afterTemplateNodeLinkFn,\n          afterTemplateChildLinkFn,\n          beforeTemplateCompileNode = $compileNode[0],\n          origAsyncDirective = directives.shift(),\n          // The fact that we have to copy and patch the directive seems wrong!\n          derivedSyncDirective = extend({}, origAsyncDirective, {\n            controller: null, templateUrl: null, transclude: null, scope: null\n          });\n\n      $compileNode.html('');\n\n      $http.get(origAsyncDirective.templateUrl, {cache: $templateCache}).\n        success(function(content) {\n          var compileNode, tempTemplateAttrs, $template;\n\n          content = denormalizeTemplate(content);\n\n          if (replace) {\n            $template = jqLite('<div>' + trim(content) + '</div>').contents();\n            compileNode = $template[0];\n\n            if ($template.length != 1 || compileNode.nodeType !== 1) {\n              throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);\n            }\n\n            tempTemplateAttrs = {$attr: {}};\n            replaceWith($rootElement, $compileNode, compileNode);\n            collectDirectives(compileNode, directives, tempTemplateAttrs);\n            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);\n          } else {\n            compileNode = beforeTemplateCompileNode;\n            $compileNode.html(content);\n          }\n\n          directives.unshift(derivedSyncDirective);\n          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);\n          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);\n\n\n          while(linkQueue.length) {\n            var controller = linkQueue.pop(),\n                linkRootElement = linkQueue.pop(),\n                beforeTemplateLinkNode = linkQueue.pop(),\n                scope = linkQueue.pop(),\n                linkNode = compileNode;\n\n            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {\n              // it was cloned therefore we have to clone as well.\n              linkNode = JQLiteClone(compileNode);\n              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);\n            }\n\n            afterTemplateNodeLinkFn(function() {\n              beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);\n            }, scope, linkNode, $rootElement, controller);\n          }\n          linkQueue = null;\n        }).\n        error(function(response, code, headers, config) {\n          throw Error('Failed to load template: ' + config.url);\n        });\n\n      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {\n        if (linkQueue) {\n          linkQueue.push(scope);\n          linkQueue.push(node);\n          linkQueue.push(rootElement);\n          linkQueue.push(controller);\n        } else {\n          afterTemplateNodeLinkFn(function() {\n            beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);\n          }, scope, node, rootElement, controller);\n        }\n      };\n    }\n\n\n    /**\n     * Sorting function for bound directives.\n     */\n    function byPriority(a, b) {\n      return b.priority - a.priority;\n    }\n\n\n    function assertNoDuplicate(what, previousDirective, directive, element) {\n      if (previousDirective) {\n        throw Error('Multiple directives [' + previousDirective.name + ', ' +\n          directive.name + '] asking for ' + what + ' on: ' +  startingTag(element));\n      }\n    }\n\n\n    function addTextInterpolateDirective(directives, text) {\n      var interpolateFn = $interpolate(text, true);\n      if (interpolateFn) {\n        directives.push({\n          priority: 0,\n          compile: valueFn(function textInterpolateLinkFn(scope, node) {\n            var parent = node.parent(),\n                bindings = parent.data('$binding') || [];\n            bindings.push(interpolateFn);\n            safeAddClass(parent.data('$binding', bindings), 'ng-binding');\n            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {\n              node[0].nodeValue = value;\n            });\n          })\n        });\n      }\n    }\n\n\n    function addAttrInterpolateDirective(node, directives, value, name) {\n      var interpolateFn = $interpolate(value, true);\n\n      // no interpolation found -> ignore\n      if (!interpolateFn) return;\n\n\n      directives.push({\n        priority: 100,\n        compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {\n          var $$observers = (attr.$$observers || (attr.$$observers = {}));\n\n          if (name === 'class') {\n            // we need to interpolate classes again, in the case the element was replaced\n            // and therefore the two class attrs got merged - we want to interpolate the result\n            interpolateFn = $interpolate(attr[name], true);\n          }\n\n          attr[name] = undefined;\n          ($$observers[name] || ($$observers[name] = [])).$$inter = true;\n          (attr.$$observers && attr.$$observers[name].$$scope || scope).\n            $watch(interpolateFn, function interpolateFnWatchAction(value) {\n              attr.$set(name, value);\n            });\n        })\n      });\n    }\n\n\n    /**\n     * This is a special jqLite.replaceWith, which can replace items which\n     * have no parents, provided that the containing jqLite collection is provided.\n     *\n     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes\n     *    in the root of the tree.\n     * @param {JqLite} $element The jqLite element which we are going to replace. We keep the shell,\n     *    but replace its DOM node reference.\n     * @param {Node} newNode The new DOM node.\n     */\n    function replaceWith($rootElement, $element, newNode) {\n      var oldNode = $element[0],\n          parent = oldNode.parentNode,\n          i, ii;\n\n      if ($rootElement) {\n        for(i = 0, ii = $rootElement.length; i < ii; i++) {\n          if ($rootElement[i] == oldNode) {\n            $rootElement[i] = newNode;\n            break;\n          }\n        }\n      }\n\n      if (parent) {\n        parent.replaceChild(newNode, oldNode);\n      }\n\n      newNode[jqLite.expando] = oldNode[jqLite.expando];\n      $element[0] = newNode;\n    }\n  }];\n}\n\nvar PREFIX_REGEXP = /^(x[\\:\\-_]|data[\\:\\-_])/i;\n/**\n * Converts all accepted directives format into proper directive name.\n * All of these will become 'myDirective':\n *   my:DiRective\n *   my-directive\n *   x-my-directive\n *   data-my:directive\n *\n * Also there is special case for Moz prefix starting with upper case letter.\n * @param name Name to normalize\n */\nfunction directiveNormalize(name) {\n  return camelCase(name.replace(PREFIX_REGEXP, ''));\n}\n\n/**\n * @ngdoc object\n * @name ng.$compile.directive.Attributes\n * @description\n *\n * A shared object between directive compile / linking functions which contains normalized DOM element\n * attributes. The the values reflect current binding state `{{ }}`. The normalization is needed\n * since all of these are treated as equivalent in Angular:\n *\n *          <span ng:bind=\"a\" ng-bind=\"a\" data-ng-bind=\"a\" x-ng-bind=\"a\">\n */\n\n/**\n * @ngdoc property\n * @name ng.$compile.directive.Attributes#$attr\n * @propertyOf ng.$compile.directive.Attributes\n * @returns {object} A map of DOM element attribute names to the normalized name. This is\n *          needed to do reverse lookup from normalized name back to actual name.\n */\n\n\n/**\n * @ngdoc function\n * @name ng.$compile.directive.Attributes#$set\n * @methodOf ng.$compile.directive.Attributes\n * @function\n *\n * @description\n * Set DOM element attribute value.\n *\n *\n * @param {string} name Normalized element attribute name of the property to modify. The name is\n *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}\n *          property to the original name.\n * @param {string} value Value to set the attribute to.\n */\n\n\n\n/**\n * Closure compiler type information\n */\n\nfunction nodesetLinkingFn(\n  /* angular.Scope */ scope,\n  /* NodeList */ nodeList,\n  /* Element */ rootElement,\n  /* function(Function) */ boundTranscludeFn\n){}\n\nfunction directiveLinkingFn(\n  /* nodesetLinkingFn */ nodesetLinkingFn,\n  /* angular.Scope */ scope,\n  /* Node */ node,\n  /* Element */ rootElement,\n  /* function(Function) */ boundTranscludeFn\n){}\n\n/**\n * @ngdoc object\n * @name ng.$controllerProvider\n * @description\n * The {@link ng.$controller $controller service} is used by Angular to create new\n * controllers.\n *\n * This provider allows controller registration via the\n * {@link ng.$controllerProvider#register register} method.\n */\nfunction $ControllerProvider() {\n  var controllers = {};\n\n\n  /**\n   * @ngdoc function\n   * @name ng.$controllerProvider#register\n   * @methodOf ng.$controllerProvider\n   * @param {string} name Controller name\n   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI\n   *    annotations in the array notation).\n   */\n  this.register = function(name, constructor) {\n    if (isObject(name)) {\n      extend(controllers, name)\n    } else {\n      controllers[name] = constructor;\n    }\n  };\n\n\n  this.$get = ['$injector', '$window', function($injector, $window) {\n\n    /**\n     * @ngdoc function\n     * @name ng.$controller\n     * @requires $injector\n     *\n     * @param {Function|string} constructor If called with a function then it's considered to be the\n     *    controller constructor function. Otherwise it's considered to be a string which is used\n     *    to retrieve the controller constructor using the following steps:\n     *\n     *    * check if a controller with given name is registered via `$controllerProvider`\n     *    * check if evaluating the string on the current scope returns a constructor\n     *    * check `window[constructor]` on the global `window` object\n     *\n     * @param {Object} locals Injection locals for Controller.\n     * @return {Object} Instance of given controller.\n     *\n     * @description\n     * `$controller` service is responsible for instantiating controllers.\n     *\n     * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into\n     * a service, so that one can override this service with {@link https://gist.github.com/1649788\n     * BC version}.\n     */\n    return function(constructor, locals) {\n      if(isString(constructor)) {\n        var name = constructor;\n        constructor = controllers.hasOwnProperty(name)\n            ? controllers[name]\n            : getter(locals.$scope, name, true) || getter($window, name, true);\n\n        assertArgFn(constructor, name, true);\n      }\n\n      return $injector.instantiate(constructor, locals);\n    };\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$document\n * @requires $window\n *\n * @description\n * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`\n * element.\n */\nfunction $DocumentProvider(){\n  this.$get = ['$window', function(window){\n    return jqLite(window.document);\n  }];\n}\n\n/**\n * @ngdoc function\n * @name ng.$exceptionHandler\n * @requires $log\n *\n * @description\n * Any uncaught exception in angular expressions is delegated to this service.\n * The default implementation simply delegates to `$log.error` which logs it into\n * the browser console.\n *\n * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by\n * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.\n *\n * @param {Error} exception Exception associated with the error.\n * @param {string=} cause optional information about the context in which\n *       the error was thrown.\n *\n */\nfunction $ExceptionHandlerProvider() {\n  this.$get = ['$log', function($log) {\n    return function(exception, cause) {\n      $log.error.apply($log, arguments);\n    };\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$interpolateProvider\n * @function\n *\n * @description\n *\n * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.\n */\nfunction $InterpolateProvider() {\n  var startSymbol = '{{';\n  var endSymbol = '}}';\n\n  /**\n   * @ngdoc method\n   * @name ng.$interpolateProvider#startSymbol\n   * @methodOf ng.$interpolateProvider\n   * @description\n   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.\n   *\n   * @param {string=} value new value to set the starting symbol to.\n   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.\n   */\n  this.startSymbol = function(value){\n    if (value) {\n      startSymbol = value;\n      return this;\n    } else {\n      return startSymbol;\n    }\n  };\n\n  /**\n   * @ngdoc method\n   * @name ng.$interpolateProvider#endSymbol\n   * @methodOf ng.$interpolateProvider\n   * @description\n   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n   *\n   * @param {string=} value new value to set the ending symbol to.\n   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.\n   */\n  this.endSymbol = function(value){\n    if (value) {\n      endSymbol = value;\n      return this;\n    } else {\n      return endSymbol;\n    }\n  };\n\n\n  this.$get = ['$parse', function($parse) {\n    var startSymbolLength = startSymbol.length,\n        endSymbolLength = endSymbol.length;\n\n    /**\n     * @ngdoc function\n     * @name ng.$interpolate\n     * @function\n     *\n     * @requires $parse\n     *\n     * @description\n     *\n     * Compiles a string with markup into an interpolation function. This service is used by the\n     * HTML {@link ng.$compile $compile} service for data binding. See\n     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the\n     * interpolation markup.\n     *\n     *\n       <pre>\n         var $interpolate = ...; // injected\n         var exp = $interpolate('Hello {{name}}!');\n         expect(exp({name:'Angular'}).toEqual('Hello Angular!');\n       </pre>\n     *\n     *\n     * @param {string} text The text with markup to interpolate.\n     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have\n     *    embedded expression in order to return an interpolation function. Strings with no\n     *    embedded expression will return null for the interpolation function.\n     * @returns {function(context)} an interpolation function which is used to compute the interpolated\n     *    string. The function has these parameters:\n     *\n     *    * `context`: an object against which any expressions embedded in the strings are evaluated\n     *      against.\n     *\n     */\n    function $interpolate(text, mustHaveExpression) {\n      var startIndex,\n          endIndex,\n          index = 0,\n          parts = [],\n          length = text.length,\n          hasInterpolation = false,\n          fn,\n          exp,\n          concat = [];\n\n      while(index < length) {\n        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&\n             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {\n          (index != startIndex) && parts.push(text.substring(index, startIndex));\n          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));\n          fn.exp = exp;\n          index = endIndex + endSymbolLength;\n          hasInterpolation = true;\n        } else {\n          // we did not find anything, so we have to add the remainder to the parts array\n          (index != length) && parts.push(text.substring(index));\n          index = length;\n        }\n      }\n\n      if (!(length = parts.length)) {\n        // we added, nothing, must have been an empty string.\n        parts.push('');\n        length = 1;\n      }\n\n      if (!mustHaveExpression  || hasInterpolation) {\n        concat.length = length;\n        fn = function(context) {\n          for(var i = 0, ii = length, part; i<ii; i++) {\n            if (typeof (part = parts[i]) == 'function') {\n              part = part(context);\n              if (part == null || part == undefined) {\n                part = '';\n              } else if (typeof part != 'string') {\n                part = toJson(part);\n              }\n            }\n            concat[i] = part;\n          }\n          return concat.join('');\n        };\n        fn.exp = text;\n        fn.parts = parts;\n        return fn;\n      }\n    }\n\n\n    /**\n     * @ngdoc method\n     * @name ng.$interpolate#startSymbol\n     * @methodOf ng.$interpolate\n     * @description\n     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.\n     *\n     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change\n     * the symbol.\n     *\n     * @returns {string} start symbol.\n     */\n    $interpolate.startSymbol = function() {\n      return startSymbol;\n    }\n\n\n    /**\n     * @ngdoc method\n     * @name ng.$interpolate#endSymbol\n     * @methodOf ng.$interpolate\n     * @description\n     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n     *\n     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change\n     * the symbol.\n     *\n     * @returns {string} start symbol.\n     */\n    $interpolate.endSymbol = function() {\n      return endSymbol;\n    }\n\n    return $interpolate;\n  }];\n}\n\nvar URL_MATCH = /^([^:]+):\\/\\/(\\w+:{0,1}\\w*@)?(\\{?[\\w\\.-]*\\}?)(:([0-9]+))?(\\/[^\\?#]*)?(\\?([^#]*))?(#(.*))?$/,\n    PATH_MATCH = /^([^\\?#]*)?(\\?([^#]*))?(#(.*))?$/,\n    HASH_MATCH = PATH_MATCH,\n    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};\n\n\n/**\n * Encode path using encodeUriSegment, ignoring forward slashes\n *\n * @param {string} path Path to encode\n * @returns {string}\n */\nfunction encodePath(path) {\n  var segments = path.split('/'),\n      i = segments.length;\n\n  while (i--) {\n    segments[i] = encodeUriSegment(segments[i]);\n  }\n\n  return segments.join('/');\n}\n\nfunction stripHash(url) {\n  return url.split('#')[0];\n}\n\n\nfunction matchUrl(url, obj) {\n  var match = URL_MATCH.exec(url);\n\n  match = {\n      protocol: match[1],\n      host: match[3],\n      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,\n      path: match[6] || '/',\n      search: match[8],\n      hash: match[10]\n    };\n\n  if (obj) {\n    obj.$$protocol = match.protocol;\n    obj.$$host = match.host;\n    obj.$$port = match.port;\n  }\n\n  return match;\n}\n\n\nfunction composeProtocolHostPort(protocol, host, port) {\n  return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);\n}\n\n\nfunction pathPrefixFromBase(basePath) {\n  return basePath.substr(0, basePath.lastIndexOf('/'));\n}\n\n\nfunction convertToHtml5Url(url, basePath, hashPrefix) {\n  var match = matchUrl(url);\n\n  // already html5 url\n  if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) ||\n      match.hash.indexOf(hashPrefix) !== 0) {\n    return url;\n  // convert hashbang url -> html5 url\n  } else {\n    return composeProtocolHostPort(match.protocol, match.host, match.port) +\n           pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);\n  }\n}\n\n\nfunction convertToHashbangUrl(url, basePath, hashPrefix) {\n  var match = matchUrl(url);\n\n  // already hashbang url\n  if (decodeURIComponent(match.path) == basePath && !isUndefined(match.hash) &&\n      match.hash.indexOf(hashPrefix) === 0) {\n    return url;\n  // convert html5 url -> hashbang url\n  } else {\n    var search = match.search && '?' + match.search || '',\n        hash = match.hash && '#' + match.hash || '',\n        pathPrefix = pathPrefixFromBase(basePath),\n        path = match.path.substr(pathPrefix.length);\n\n    if (match.path.indexOf(pathPrefix) !== 0) {\n      throw Error('Invalid url \"' + url + '\", missing path prefix \"' + pathPrefix + '\" !');\n    }\n\n    return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath +\n           '#' + hashPrefix + path + search + hash;\n  }\n}\n\n\n/**\n * LocationUrl represents an url\n * This object is exposed as $location service when HTML5 mode is enabled and supported\n *\n * @constructor\n * @param {string} url HTML5 url\n * @param {string} pathPrefix\n */\nfunction LocationUrl(url, pathPrefix, appBaseUrl) {\n  pathPrefix = pathPrefix || '';\n\n  /**\n   * Parse given html5 (regular) url string into properties\n   * @param {string} newAbsoluteUrl HTML5 url\n   * @private\n   */\n  this.$$parse = function(newAbsoluteUrl) {\n    var match = matchUrl(newAbsoluteUrl, this);\n\n    if (match.path.indexOf(pathPrefix) !== 0) {\n      throw Error('Invalid url \"' + newAbsoluteUrl + '\", missing path prefix \"' + pathPrefix + '\" !');\n    }\n\n    this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));\n    this.$$search = parseKeyValue(match.search);\n    this.$$hash = match.hash && decodeURIComponent(match.hash) || '';\n\n    this.$$compose();\n  };\n\n  /**\n   * Compose url and update `absUrl` property\n   * @private\n   */\n  this.$$compose = function() {\n    var search = toKeyValue(this.$$search),\n        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';\n\n    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;\n    this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) +\n                    pathPrefix + this.$$url;\n  };\n\n\n  this.$$rewriteAppUrl = function(absoluteLinkUrl) {\n    if(absoluteLinkUrl.indexOf(appBaseUrl) == 0) {\n      return absoluteLinkUrl;\n    }\n  }\n\n\n  this.$$parse(url);\n}\n\n\n/**\n * LocationHashbangUrl represents url\n * This object is exposed as $location service when html5 history api is disabled or not supported\n *\n * @constructor\n * @param {string} url Legacy url\n * @param {string} hashPrefix Prefix for hash part (containing path and search)\n */\nfunction LocationHashbangUrl(url, hashPrefix, appBaseUrl) {\n  var basePath;\n\n  /**\n   * Parse given hashbang url into properties\n   * @param {string} url Hashbang url\n   * @private\n   */\n  this.$$parse = function(url) {\n    var match = matchUrl(url, this);\n\n\n    if (match.hash && match.hash.indexOf(hashPrefix) !== 0) {\n      throw Error('Invalid url \"' + url + '\", missing hash prefix \"' + hashPrefix + '\" !');\n    }\n\n    basePath = match.path + (match.search ? '?' + match.search : '');\n    match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));\n    if (match[1]) {\n      this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);\n    } else {\n      this.$$path = '';\n    }\n\n    this.$$search = parseKeyValue(match[3]);\n    this.$$hash = match[5] && decodeURIComponent(match[5]) || '';\n\n    this.$$compose();\n  };\n\n  /**\n   * Compose hashbang url and update `absUrl` property\n   * @private\n   */\n  this.$$compose = function() {\n    var search = toKeyValue(this.$$search),\n        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';\n\n    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;\n    this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) +\n                    basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');\n  };\n\n  this.$$rewriteAppUrl = function(absoluteLinkUrl) {\n    if(absoluteLinkUrl.indexOf(appBaseUrl) == 0) {\n      return absoluteLinkUrl;\n    }\n  }\n\n\n  this.$$parse(url);\n}\n\n\nLocationUrl.prototype = {\n\n  /**\n   * Has any change been replacing ?\n   * @private\n   */\n  $$replace: false,\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#absUrl\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return full url representation with all segments encoded according to rules specified in\n   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.\n   *\n   * @return {string} full url\n   */\n  absUrl: locationGetter('$$absUrl'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#url\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.\n   *\n   * Change path, search and hash, when called with parameter and return `$location`.\n   *\n   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)\n   * @return {string} url\n   */\n  url: function(url, replace) {\n    if (isUndefined(url))\n      return this.$$url;\n\n    var match = PATH_MATCH.exec(url);\n    if (match[1]) this.path(decodeURIComponent(match[1]));\n    if (match[2] || match[1]) this.search(match[3] || '');\n    this.hash(match[5] || '', replace);\n\n    return this;\n  },\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#protocol\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return protocol of current url.\n   *\n   * @return {string} protocol of current url\n   */\n  protocol: locationGetter('$$protocol'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#host\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return host of current url.\n   *\n   * @return {string} host of current url.\n   */\n  host: locationGetter('$$host'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#port\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return port of current url.\n   *\n   * @return {Number} port\n   */\n  port: locationGetter('$$port'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#path\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return path of current url when called without any parameter.\n   *\n   * Change path when called with parameter and return `$location`.\n   *\n   * Note: Path should always begin with forward slash (/), this method will add the forward slash\n   * if it is missing.\n   *\n   * @param {string=} path New path\n   * @return {string} path\n   */\n  path: locationGetterSetter('$$path', function(path) {\n    return path.charAt(0) == '/' ? path : '/' + path;\n  }),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#search\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return search part (as object) of current url when called without any parameter.\n   *\n   * Change search part when called with parameter and return `$location`.\n   *\n   * @param {string|object<string,string>=} search New search params - string or hash object\n   * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a\n   *    single search parameter. If the value is `null`, the parameter will be deleted.\n   *\n   * @return {string} search\n   */\n  search: function(search, paramValue) {\n    if (isUndefined(search))\n      return this.$$search;\n\n    if (isDefined(paramValue)) {\n      if (paramValue === null) {\n        delete this.$$search[search];\n      } else {\n        this.$$search[search] = paramValue;\n      }\n    } else {\n      this.$$search = isString(search) ? parseKeyValue(search) : search;\n    }\n\n    this.$$compose();\n    return this;\n  },\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#hash\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return hash fragment when called without any parameter.\n   *\n   * Change hash fragment when called with parameter and return `$location`.\n   *\n   * @param {string=} hash New hash fragment\n   * @return {string} hash\n   */\n  hash: locationGetterSetter('$$hash', identity),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#replace\n   * @methodOf ng.$location\n   *\n   * @description\n   * If called, all changes to $location during current `$digest` will be replacing current history\n   * record, instead of adding new one.\n   */\n  replace: function() {\n    this.$$replace = true;\n    return this;\n  }\n};\n\nLocationHashbangUrl.prototype = inherit(LocationUrl.prototype);\n\nfunction LocationHashbangInHtml5Url(url, hashPrefix, appBaseUrl, baseExtra) {\n  LocationHashbangUrl.apply(this, arguments);\n\n\n  this.$$rewriteAppUrl = function(absoluteLinkUrl) {\n    if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {\n      return appBaseUrl + baseExtra + '#' + hashPrefix  + absoluteLinkUrl.substr(appBaseUrl.length);\n    }\n  }\n}\n\nLocationHashbangInHtml5Url.prototype = inherit(LocationHashbangUrl.prototype);\n\nfunction locationGetter(property) {\n  return function() {\n    return this[property];\n  };\n}\n\n\nfunction locationGetterSetter(property, preprocess) {\n  return function(value) {\n    if (isUndefined(value))\n      return this[property];\n\n    this[property] = preprocess(value);\n    this.$$compose();\n\n    return this;\n  };\n}\n\n\n/**\n * @ngdoc object\n * @name ng.$location\n *\n * @requires $browser\n * @requires $sniffer\n * @requires $rootElement\n *\n * @description\n * The $location service parses the URL in the browser address bar (based on the\n * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL\n * available to your application. Changes to the URL in the address bar are reflected into\n * $location service and changes to $location are reflected into the browser address bar.\n *\n * **The $location service:**\n *\n * - Exposes the current URL in the browser address bar, so you can\n *   - Watch and observe the URL.\n *   - Change the URL.\n * - Synchronizes the URL with the browser when the user\n *   - Changes the address bar.\n *   - Clicks the back or forward button (or clicks a History link).\n *   - Clicks on a link.\n * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).\n *\n * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular\n * Services: Using $location}\n */\n\n/**\n * @ngdoc object\n * @name ng.$locationProvider\n * @description\n * Use the `$locationProvider` to configure how the application deep linking paths are stored.\n */\nfunction $LocationProvider(){\n  var hashPrefix = '',\n      html5Mode = false;\n\n  /**\n   * @ngdoc property\n   * @name ng.$locationProvider#hashPrefix\n   * @methodOf ng.$locationProvider\n   * @description\n   * @param {string=} prefix Prefix for hash part (containing path and search)\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   */\n  this.hashPrefix = function(prefix) {\n    if (isDefined(prefix)) {\n      hashPrefix = prefix;\n      return this;\n    } else {\n      return hashPrefix;\n    }\n  };\n\n  /**\n   * @ngdoc property\n   * @name ng.$locationProvider#html5Mode\n   * @methodOf ng.$locationProvider\n   * @description\n   * @param {string=} mode Use HTML5 strategy if available.\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   */\n  this.html5Mode = function(mode) {\n    if (isDefined(mode)) {\n      html5Mode = mode;\n      return this;\n    } else {\n      return html5Mode;\n    }\n  };\n\n  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',\n      function( $rootScope,   $browser,   $sniffer,   $rootElement) {\n    var $location,\n        basePath,\n        pathPrefix,\n        initUrl = $browser.url(),\n        initUrlParts = matchUrl(initUrl),\n        appBaseUrl;\n\n    if (html5Mode) {\n      basePath = $browser.baseHref() || '/';\n      pathPrefix = pathPrefixFromBase(basePath);\n      appBaseUrl =\n          composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) +\n          pathPrefix + '/';\n\n      if ($sniffer.history) {\n        $location = new LocationUrl(\n          convertToHtml5Url(initUrl, basePath, hashPrefix),\n          pathPrefix, appBaseUrl);\n      } else {\n        $location = new LocationHashbangInHtml5Url(\n          convertToHashbangUrl(initUrl, basePath, hashPrefix),\n          hashPrefix, appBaseUrl, basePath.substr(pathPrefix.length + 1));\n      }\n    } else {\n      appBaseUrl =\n          composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) +\n          (initUrlParts.path || '') +\n          (initUrlParts.search ? ('?' + initUrlParts.search) : '') +\n          '#' + hashPrefix + '/';\n\n      $location = new LocationHashbangUrl(initUrl, hashPrefix, appBaseUrl);\n    }\n\n    $rootElement.bind('click', function(event) {\n      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)\n      // currently we open nice url link and redirect then\n\n      if (event.ctrlKey || event.metaKey || event.which == 2) return;\n\n      var elm = jqLite(event.target);\n\n      // traverse the DOM up to find first A tag\n      while (lowercase(elm[0].nodeName) !== 'a') {\n        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)\n        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;\n      }\n\n      var absHref = elm.prop('href'),\n          rewrittenUrl = $location.$$rewriteAppUrl(absHref);\n\n      if (absHref && !elm.attr('target') && rewrittenUrl) {\n        // update location manually\n        $location.$$parse(rewrittenUrl);\n        $rootScope.$apply();\n        event.preventDefault();\n        // hack to work around FF6 bug 684208 when scenario runner clicks on links\n        window.angular['ff-684208-preventDefault'] = true;\n      }\n    });\n\n\n    // rewrite hashbang url <> html5 url\n    if ($location.absUrl() != initUrl) {\n      $browser.url($location.absUrl(), true);\n    }\n\n    // update $location when $browser url changes\n    $browser.onUrlChange(function(newUrl) {\n      if ($location.absUrl() != newUrl) {\n        if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {\n          $browser.url($location.absUrl());\n          return;\n        }\n        $rootScope.$evalAsync(function() {\n          var oldUrl = $location.absUrl();\n\n          $location.$$parse(newUrl);\n          afterLocationChange(oldUrl);\n        });\n        if (!$rootScope.$$phase) $rootScope.$digest();\n      }\n    });\n\n    // update browser\n    var changeCounter = 0;\n    $rootScope.$watch(function $locationWatch() {\n      var oldUrl = $browser.url();\n      var currentReplace = $location.$$replace;\n\n      if (!changeCounter || oldUrl != $location.absUrl()) {\n        changeCounter++;\n        $rootScope.$evalAsync(function() {\n          if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).\n              defaultPrevented) {\n            $location.$$parse(oldUrl);\n          } else {\n            $browser.url($location.absUrl(), currentReplace);\n            afterLocationChange(oldUrl);\n          }\n        });\n      }\n      $location.$$replace = false;\n\n      return changeCounter;\n    });\n\n    return $location;\n\n    function afterLocationChange(oldUrl) {\n      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);\n    }\n}];\n}\n\n/**\n * @ngdoc object\n * @name ng.$log\n * @requires $window\n *\n * @description\n * Simple service for logging. Default implementation writes the message\n * into the browser's console (if present).\n *\n * The main purpose of this service is to simplify debugging and troubleshooting.\n *\n * @example\n   <example>\n     <file name=\"script.js\">\n       function LogCtrl($scope, $log) {\n         $scope.$log = $log;\n         $scope.message = 'Hello World!';\n       }\n     </file>\n     <file name=\"index.html\">\n       <div ng-controller=\"LogCtrl\">\n         <p>Reload this page with open console, enter text and hit the log button...</p>\n         Message:\n         <input type=\"text\" ng-model=\"message\"/>\n         <button ng-click=\"$log.log(message)\">log</button>\n         <button ng-click=\"$log.warn(message)\">warn</button>\n         <button ng-click=\"$log.info(message)\">info</button>\n         <button ng-click=\"$log.error(message)\">error</button>\n       </div>\n     </file>\n   </example>\n */\n\nfunction $LogProvider(){\n  this.$get = ['$window', function($window){\n    return {\n      /**\n       * @ngdoc method\n       * @name ng.$log#log\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write a log message\n       */\n      log: consoleLog('log'),\n\n      /**\n       * @ngdoc method\n       * @name ng.$log#warn\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write a warning message\n       */\n      warn: consoleLog('warn'),\n\n      /**\n       * @ngdoc method\n       * @name ng.$log#info\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write an information message\n       */\n      info: consoleLog('info'),\n\n      /**\n       * @ngdoc method\n       * @name ng.$log#error\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write an error message\n       */\n      error: consoleLog('error')\n    };\n\n    function formatError(arg) {\n      if (arg instanceof Error) {\n        if (arg.stack) {\n          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)\n              ? 'Error: ' + arg.message + '\\n' + arg.stack\n              : arg.stack;\n        } else if (arg.sourceURL) {\n          arg = arg.message + '\\n' + arg.sourceURL + ':' + arg.line;\n        }\n      }\n      return arg;\n    }\n\n    function consoleLog(type) {\n      var console = $window.console || {},\n          logFn = console[type] || console.log || noop;\n\n      if (logFn.apply) {\n        return function() {\n          var args = [];\n          forEach(arguments, function(arg) {\n            args.push(formatError(arg));\n          });\n          return logFn.apply(console, args);\n        };\n      }\n\n      // we are IE which either doesn't have window.console => this is noop and we do nothing,\n      // or we are IE where console.log doesn't have apply so we log at least first 2 args\n      return function(arg1, arg2) {\n        logFn(arg1, arg2);\n      }\n    }\n  }];\n}\n\nvar OPERATORS = {\n    'null':function(){return null;},\n    'true':function(){return true;},\n    'false':function(){return false;},\n    undefined:noop,\n    '+':function(self, locals, a,b){\n      a=a(self, locals); b=b(self, locals);\n      if (isDefined(a)) {\n        if (isDefined(b)) {\n          return a + b;\n        }\n        return a;\n      }\n      return isDefined(b)?b:undefined;},\n    '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},\n    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},\n    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},\n    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},\n    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},\n    '=':noop,\n    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},\n    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},\n    '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},\n    '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},\n    '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},\n    '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},\n    '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},\n    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},\n    '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},\n//    '|':function(self, locals, a,b){return a|b;},\n    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},\n    '!':function(self, locals, a){return !a(self, locals);}\n};\nvar ESCAPE = {\"n\":\"\\n\", \"f\":\"\\f\", \"r\":\"\\r\", \"t\":\"\\t\", \"v\":\"\\v\", \"'\":\"'\", '\"':'\"'};\n\nfunction lex(text, csp){\n  var tokens = [],\n      token,\n      index = 0,\n      json = [],\n      ch,\n      lastCh = ':'; // can start regexp\n\n  while (index < text.length) {\n    ch = text.charAt(index);\n    if (is('\"\\'')) {\n      readString(ch);\n    } else if (isNumber(ch) || is('.') && isNumber(peek())) {\n      readNumber();\n    } else if (isIdent(ch)) {\n      readIdent();\n      // identifiers can only be if the preceding char was a { or ,\n      if (was('{,') && json[0]=='{' &&\n         (token=tokens[tokens.length-1])) {\n        token.json = token.text.indexOf('.') == -1;\n      }\n    } else if (is('(){}[].,;:')) {\n      tokens.push({\n        index:index,\n        text:ch,\n        json:(was(':[,') && is('{[')) || is('}]:,')\n      });\n      if (is('{[')) json.unshift(ch);\n      if (is('}]')) json.shift();\n      index++;\n    } else if (isWhitespace(ch)) {\n      index++;\n      continue;\n    } else {\n      var ch2 = ch + peek(),\n          fn = OPERATORS[ch],\n          fn2 = OPERATORS[ch2];\n      if (fn2) {\n        tokens.push({index:index, text:ch2, fn:fn2});\n        index += 2;\n      } else if (fn) {\n        tokens.push({index:index, text:ch, fn:fn, json: was('[,:') && is('+-')});\n        index += 1;\n      } else {\n        throwError(\"Unexpected next character \", index, index+1);\n      }\n    }\n    lastCh = ch;\n  }\n  return tokens;\n\n  function is(chars) {\n    return chars.indexOf(ch) != -1;\n  }\n\n  function was(chars) {\n    return chars.indexOf(lastCh) != -1;\n  }\n\n  function peek() {\n    return index + 1 < text.length ? text.charAt(index + 1) : false;\n  }\n  function isNumber(ch) {\n    return '0' <= ch && ch <= '9';\n  }\n  function isWhitespace(ch) {\n    return ch == ' ' || ch == '\\r' || ch == '\\t' ||\n           ch == '\\n' || ch == '\\v' || ch == '\\u00A0'; // IE treats non-breaking space as \\u00A0\n  }\n  function isIdent(ch) {\n    return 'a' <= ch && ch <= 'z' ||\n           'A' <= ch && ch <= 'Z' ||\n           '_' == ch || ch == '$';\n  }\n  function isExpOperator(ch) {\n    return ch == '-' || ch == '+' || isNumber(ch);\n  }\n\n  function throwError(error, start, end) {\n    end = end || index;\n    throw Error(\"Lexer Error: \" + error + \" at column\" +\n        (isDefined(start)\n            ? \"s \" + start +  \"-\" + index + \" [\" + text.substring(start, end) + \"]\"\n            : \" \" + end) +\n        \" in expression [\" + text + \"].\");\n  }\n\n  function readNumber() {\n    var number = \"\";\n    var start = index;\n    while (index < text.length) {\n      var ch = lowercase(text.charAt(index));\n      if (ch == '.' || isNumber(ch)) {\n        number += ch;\n      } else {\n        var peekCh = peek();\n        if (ch == 'e' && isExpOperator(peekCh)) {\n          number += ch;\n        } else if (isExpOperator(ch) &&\n            peekCh && isNumber(peekCh) &&\n            number.charAt(number.length - 1) == 'e') {\n          number += ch;\n        } else if (isExpOperator(ch) &&\n            (!peekCh || !isNumber(peekCh)) &&\n            number.charAt(number.length - 1) == 'e') {\n          throwError('Invalid exponent');\n        } else {\n          break;\n        }\n      }\n      index++;\n    }\n    number = 1 * number;\n    tokens.push({index:start, text:number, json:true,\n      fn:function() {return number;}});\n  }\n  function readIdent() {\n    var ident = \"\",\n        start = index,\n        lastDot, peekIndex, methodName, ch;\n\n    while (index < text.length) {\n      ch = text.charAt(index);\n      if (ch == '.' || isIdent(ch) || isNumber(ch)) {\n        if (ch == '.') lastDot = index;\n        ident += ch;\n      } else {\n        break;\n      }\n      index++;\n    }\n\n    //check if this is not a method invocation and if it is back out to last dot\n    if (lastDot) {\n      peekIndex = index;\n      while(peekIndex < text.length) {\n        ch = text.charAt(peekIndex);\n        if (ch == '(') {\n          methodName = ident.substr(lastDot - start + 1);\n          ident = ident.substr(0, lastDot - start);\n          index = peekIndex;\n          break;\n        }\n        if(isWhitespace(ch)) {\n          peekIndex++;\n        } else {\n          break;\n        }\n      }\n    }\n\n\n    var token = {\n      index:start,\n      text:ident\n    };\n\n    if (OPERATORS.hasOwnProperty(ident)) {\n      token.fn = token.json = OPERATORS[ident];\n    } else {\n      var getter = getterFn(ident, csp);\n      token.fn = extend(function(self, locals) {\n        return (getter(self, locals));\n      }, {\n        assign: function(self, value) {\n          return setter(self, ident, value);\n        }\n      });\n    }\n\n    tokens.push(token);\n\n    if (methodName) {\n      tokens.push({\n        index:lastDot,\n        text: '.',\n        json: false\n      });\n      tokens.push({\n        index: lastDot + 1,\n        text: methodName,\n        json: false\n      });\n    }\n  }\n\n  function readString(quote) {\n    var start = index;\n    index++;\n    var string = \"\";\n    var rawString = quote;\n    var escape = false;\n    while (index < text.length) {\n      var ch = text.charAt(index);\n      rawString += ch;\n      if (escape) {\n        if (ch == 'u') {\n          var hex = text.substring(index + 1, index + 5);\n          if (!hex.match(/[\\da-f]{4}/i))\n            throwError( \"Invalid unicode escape [\\\\u\" + hex + \"]\");\n          index += 4;\n          string += String.fromCharCode(parseInt(hex, 16));\n        } else {\n          var rep = ESCAPE[ch];\n          if (rep) {\n            string += rep;\n          } else {\n            string += ch;\n          }\n        }\n        escape = false;\n      } else if (ch == '\\\\') {\n        escape = true;\n      } else if (ch == quote) {\n        index++;\n        tokens.push({\n          index:start,\n          text:rawString,\n          string:string,\n          json:true,\n          fn:function() { return string; }\n        });\n        return;\n      } else {\n        string += ch;\n      }\n      index++;\n    }\n    throwError(\"Unterminated quote\", start);\n  }\n}\n\n/////////////////////////////////////////\n\nfunction parser(text, json, $filter, csp){\n  var ZERO = valueFn(0),\n      value,\n      tokens = lex(text, csp),\n      assignment = _assignment,\n      functionCall = _functionCall,\n      fieldAccess = _fieldAccess,\n      objectIndex = _objectIndex,\n      filterChain = _filterChain;\n\n  if(json){\n    // The extra level of aliasing is here, just in case the lexer misses something, so that\n    // we prevent any accidental execution in JSON.\n    assignment = logicalOR;\n    functionCall =\n      fieldAccess =\n      objectIndex =\n      filterChain =\n        function() { throwError(\"is not valid json\", {text:text, index:0}); };\n    value = primary();\n  } else {\n    value = statements();\n  }\n  if (tokens.length !== 0) {\n    throwError(\"is an unexpected token\", tokens[0]);\n  }\n  return value;\n\n  ///////////////////////////////////\n  function throwError(msg, token) {\n    throw Error(\"Syntax Error: Token '\" + token.text +\n      \"' \" + msg + \" at column \" +\n      (token.index + 1) + \" of the expression [\" +\n      text + \"] starting at [\" + text.substring(token.index) + \"].\");\n  }\n\n  function peekToken() {\n    if (tokens.length === 0)\n      throw Error(\"Unexpected end of expression: \" + text);\n    return tokens[0];\n  }\n\n  function peek(e1, e2, e3, e4) {\n    if (tokens.length > 0) {\n      var token = tokens[0];\n      var t = token.text;\n      if (t==e1 || t==e2 || t==e3 || t==e4 ||\n          (!e1 && !e2 && !e3 && !e4)) {\n        return token;\n      }\n    }\n    return false;\n  }\n\n  function expect(e1, e2, e3, e4){\n    var token = peek(e1, e2, e3, e4);\n    if (token) {\n      if (json && !token.json) {\n        throwError(\"is not valid json\", token);\n      }\n      tokens.shift();\n      return token;\n    }\n    return false;\n  }\n\n  function consume(e1){\n    if (!expect(e1)) {\n      throwError(\"is unexpected, expecting [\" + e1 + \"]\", peek());\n    }\n  }\n\n  function unaryFn(fn, right) {\n    return function(self, locals) {\n      return fn(self, locals, right);\n    };\n  }\n\n  function binaryFn(left, fn, right) {\n    return function(self, locals) {\n      return fn(self, locals, left, right);\n    };\n  }\n\n  function statements() {\n    var statements = [];\n    while(true) {\n      if (tokens.length > 0 && !peek('}', ')', ';', ']'))\n        statements.push(filterChain());\n      if (!expect(';')) {\n        // optimize for the common case where there is only one statement.\n        // TODO(size): maybe we should not support multiple statements?\n        return statements.length == 1\n          ? statements[0]\n          : function(self, locals){\n            var value;\n            for ( var i = 0; i < statements.length; i++) {\n              var statement = statements[i];\n              if (statement)\n                value = statement(self, locals);\n            }\n            return value;\n          };\n      }\n    }\n  }\n\n  function _filterChain() {\n    var left = expression();\n    var token;\n    while(true) {\n      if ((token = expect('|'))) {\n        left = binaryFn(left, token.fn, filter());\n      } else {\n        return left;\n      }\n    }\n  }\n\n  function filter() {\n    var token = expect();\n    var fn = $filter(token.text);\n    var argsFn = [];\n    while(true) {\n      if ((token = expect(':'))) {\n        argsFn.push(expression());\n      } else {\n        var fnInvoke = function(self, locals, input){\n          var args = [input];\n          for ( var i = 0; i < argsFn.length; i++) {\n            args.push(argsFn[i](self, locals));\n          }\n          return fn.apply(self, args);\n        };\n        return function() {\n          return fnInvoke;\n        };\n      }\n    }\n  }\n\n  function expression() {\n    return assignment();\n  }\n\n  function _assignment() {\n    var left = logicalOR();\n    var right;\n    var token;\n    if ((token = expect('='))) {\n      if (!left.assign) {\n        throwError(\"implies assignment but [\" +\n          text.substring(0, token.index) + \"] can not be assigned to\", token);\n      }\n      right = logicalOR();\n      return function(scope, locals){\n        return left.assign(scope, right(scope, locals), locals);\n      };\n    } else {\n      return left;\n    }\n  }\n\n  function logicalOR() {\n    var left = logicalAND();\n    var token;\n    while(true) {\n      if ((token = expect('||'))) {\n        left = binaryFn(left, token.fn, logicalAND());\n      } else {\n        return left;\n      }\n    }\n  }\n\n  function logicalAND() {\n    var left = equality();\n    var token;\n    if ((token = expect('&&'))) {\n      left = binaryFn(left, token.fn, logicalAND());\n    }\n    return left;\n  }\n\n  function equality() {\n    var left = relational();\n    var token;\n    if ((token = expect('==','!='))) {\n      left = binaryFn(left, token.fn, equality());\n    }\n    return left;\n  }\n\n  function relational() {\n    var left = additive();\n    var token;\n    if ((token = expect('<', '>', '<=', '>='))) {\n      left = binaryFn(left, token.fn, relational());\n    }\n    return left;\n  }\n\n  function additive() {\n    var left = multiplicative();\n    var token;\n    while ((token = expect('+','-'))) {\n      left = binaryFn(left, token.fn, multiplicative());\n    }\n    return left;\n  }\n\n  function multiplicative() {\n    var left = unary();\n    var token;\n    while ((token = expect('*','/','%'))) {\n      left = binaryFn(left, token.fn, unary());\n    }\n    return left;\n  }\n\n  function unary() {\n    var token;\n    if (expect('+')) {\n      return primary();\n    } else if ((token = expect('-'))) {\n      return binaryFn(ZERO, token.fn, unary());\n    } else if ((token = expect('!'))) {\n      return unaryFn(token.fn, unary());\n    } else {\n      return primary();\n    }\n  }\n\n\n  function primary() {\n    var primary;\n    if (expect('(')) {\n      primary = filterChain();\n      consume(')');\n    } else if (expect('[')) {\n      primary = arrayDeclaration();\n    } else if (expect('{')) {\n      primary = object();\n    } else {\n      var token = expect();\n      primary = token.fn;\n      if (!primary) {\n        throwError(\"not a primary expression\", token);\n      }\n    }\n\n    var next, context;\n    while ((next = expect('(', '[', '.'))) {\n      if (next.text === '(') {\n        primary = functionCall(primary, context);\n        context = null;\n      } else if (next.text === '[') {\n        context = primary;\n        primary = objectIndex(primary);\n      } else if (next.text === '.') {\n        context = primary;\n        primary = fieldAccess(primary);\n      } else {\n        throwError(\"IMPOSSIBLE\");\n      }\n    }\n    return primary;\n  }\n\n  function _fieldAccess(object) {\n    var field = expect().text;\n    var getter = getterFn(field, csp);\n    return extend(\n        function(scope, locals, self) {\n          return getter(self || object(scope, locals), locals);\n        },\n        {\n          assign:function(scope, value, locals) {\n            return setter(object(scope, locals), field, value);\n          }\n        }\n    );\n  }\n\n  function _objectIndex(obj) {\n    var indexFn = expression();\n    consume(']');\n    return extend(\n      function(self, locals){\n        var o = obj(self, locals),\n            i = indexFn(self, locals),\n            v, p;\n\n        if (!o) return undefined;\n        v = o[i];\n        if (v && v.then) {\n          p = v;\n          if (!('$$v' in v)) {\n            p.$$v = undefined;\n            p.then(function(val) { p.$$v = val; });\n          }\n          v = v.$$v;\n        }\n        return v;\n      }, {\n        assign:function(self, value, locals){\n          return obj(self, locals)[indexFn(self, locals)] = value;\n        }\n      });\n  }\n\n  function _functionCall(fn, contextGetter) {\n    var argsFn = [];\n    if (peekToken().text != ')') {\n      do {\n        argsFn.push(expression());\n      } while (expect(','));\n    }\n    consume(')');\n    return function(scope, locals){\n      var args = [],\n          context = contextGetter ? contextGetter(scope, locals) : scope;\n\n      for ( var i = 0; i < argsFn.length; i++) {\n        args.push(argsFn[i](scope, locals));\n      }\n      var fnPtr = fn(scope, locals, context) || noop;\n      // IE stupidity!\n      return fnPtr.apply\n          ? fnPtr.apply(context, args)\n          : fnPtr(args[0], args[1], args[2], args[3], args[4]);\n    };\n  }\n\n  // This is used with json array declaration\n  function arrayDeclaration () {\n    var elementFns = [];\n    if (peekToken().text != ']') {\n      do {\n        elementFns.push(expression());\n      } while (expect(','));\n    }\n    consume(']');\n    return function(self, locals){\n      var array = [];\n      for ( var i = 0; i < elementFns.length; i++) {\n        array.push(elementFns[i](self, locals));\n      }\n      return array;\n    };\n  }\n\n  function object () {\n    var keyValues = [];\n    if (peekToken().text != '}') {\n      do {\n        var token = expect(),\n        key = token.string || token.text;\n        consume(\":\");\n        var value = expression();\n        keyValues.push({key:key, value:value});\n      } while (expect(','));\n    }\n    consume('}');\n    return function(self, locals){\n      var object = {};\n      for ( var i = 0; i < keyValues.length; i++) {\n        var keyValue = keyValues[i];\n        object[keyValue.key] = keyValue.value(self, locals);\n      }\n      return object;\n    };\n  }\n}\n\n//////////////////////////////////////////////////\n// Parser helper functions\n//////////////////////////////////////////////////\n\nfunction setter(obj, path, setValue) {\n  var element = path.split('.');\n  for (var i = 0; element.length > 1; i++) {\n    var key = element.shift();\n    var propertyObj = obj[key];\n    if (!propertyObj) {\n      propertyObj = {};\n      obj[key] = propertyObj;\n    }\n    obj = propertyObj;\n  }\n  obj[element.shift()] = setValue;\n  return setValue;\n}\n\nvar getterFnCache = {};\n\n/**\n * Implementation of the \"Black Hole\" variant from:\n * - http://jsperf.com/angularjs-parse-getter/4\n * - http://jsperf.com/path-evaluation-simplified/7\n */\nfunction cspSafeGetterFn(key0, key1, key2, key3, key4) {\n  return function(scope, locals) {\n    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,\n        promise;\n\n    if (pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key0];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key1];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key2];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key3];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key4];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    return pathVal;\n  };\n}\n\nfunction getterFn(path, csp) {\n  if (getterFnCache.hasOwnProperty(path)) {\n    return getterFnCache[path];\n  }\n\n  var pathKeys = path.split('.'),\n      pathKeysLength = pathKeys.length,\n      fn;\n\n  if (csp) {\n    fn = (pathKeysLength < 6)\n        ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4])\n        : function(scope, locals) {\n          var i = 0, val;\n          do {\n            val = cspSafeGetterFn(\n                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++]\n                  )(scope, locals);\n\n            locals = undefined; // clear after first iteration\n            scope = val;\n          } while (i < pathKeysLength);\n          return val;\n        }\n  } else {\n    var code = 'var l, fn, p;\\n';\n    forEach(pathKeys, function(key, index) {\n      code += 'if(s === null || s === undefined) return s;\\n' +\n              'l=s;\\n' +\n              's='+ (index\n                      // we simply dereference 's' on any .dot notation\n                      ? 's'\n                      // but if we are first then we check locals first, and if so read it first\n                      : '((k&&k.hasOwnProperty(\"' + key + '\"))?k:s)') + '[\"' + key + '\"]' + ';\\n' +\n              'if (s && s.then) {\\n' +\n                ' if (!(\"$$v\" in s)) {\\n' +\n                  ' p=s;\\n' +\n                  ' p.$$v = undefined;\\n' +\n                  ' p.then(function(v) {p.$$v=v;});\\n' +\n                  '}\\n' +\n                ' s=s.$$v\\n' +\n              '}\\n';\n    });\n    code += 'return s;';\n    fn = Function('s', 'k', code); // s=scope, k=locals\n    fn.toString = function() { return code; };\n  }\n\n  return getterFnCache[path] = fn;\n}\n\n///////////////////////////////////\n\n/**\n * @ngdoc function\n * @name ng.$parse\n * @function\n *\n * @description\n *\n * Converts Angular {@link guide/expression expression} into a function.\n *\n * <pre>\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'angular'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('angular');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * </pre>\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n *      are evaluated against (tipically a scope object).\n *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The return function also has an `assign` property, if the expression is assignable, which\n *    allows one to set values to expressions.\n *\n */\nfunction $ParseProvider() {\n  var cache = {};\n  this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {\n    return function(exp) {\n      switch(typeof exp) {\n        case 'string':\n          return cache.hasOwnProperty(exp)\n            ? cache[exp]\n            : cache[exp] =  parser(exp, false, $filter, $sniffer.csp);\n        case 'function':\n          return exp;\n        default:\n          return noop;\n      }\n    };\n  }];\n}\n\n/**\n * @ngdoc service\n * @name ng.$q\n * @requires $rootScope\n *\n * @description\n * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).\n *\n * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an\n * interface for interacting with an object that represents the result of an action that is\n * performed asynchronously, and may or may not be finished at any given point in time.\n *\n * From the perspective of dealing with error handling, deferred and promise APIs are to\n * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.\n *\n * <pre>\n *   // for the purpose of this example let's assume that variables `$q` and `scope` are\n *   // available in the current lexical scope (they could have been injected or passed in).\n *\n *   function asyncGreet(name) {\n *     var deferred = $q.defer();\n *\n *     setTimeout(function() {\n *       // since this fn executes async in a future turn of the event loop, we need to wrap\n *       // our code into an $apply call so that the model changes are properly observed.\n *       scope.$apply(function() {\n *         if (okToGreet(name)) {\n *           deferred.resolve('Hello, ' + name + '!');\n *         } else {\n *           deferred.reject('Greeting ' + name + ' is not allowed.');\n *         }\n *       });\n *     }, 1000);\n *\n *     return deferred.promise;\n *   }\n *\n *   var promise = asyncGreet('Robin Hood');\n *   promise.then(function(greeting) {\n *     alert('Success: ' + greeting);\n *   }, function(reason) {\n *     alert('Failed: ' + reason);\n *   });\n * </pre>\n *\n * At first it might not be obvious why this extra complexity is worth the trouble. The payoff\n * comes in the way of\n * [guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).\n *\n * Additionally the promise api allows for composition that is very hard to do with the\n * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.\n * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the\n * section on serial or parallel joining of promises.\n *\n *\n * # The Deferred API\n *\n * A new instance of deferred is constructed by calling `$q.defer()`.\n *\n * The purpose of the deferred object is to expose the associated Promise instance as well as APIs\n * that can be used for signaling the successful or unsuccessful completion of the task.\n *\n * **Methods**\n *\n * - `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection\n *   constructed via `$q.reject`, the promise will be rejected instead.\n * - `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to\n *   resolving it with a rejection constructed via `$q.reject`.\n *\n * **Properties**\n *\n * - promise – `{Promise}` – promise object associated with this deferred.\n *\n *\n * # The Promise API\n *\n * A new promise instance is created when a deferred instance is created and can be retrieved by\n * calling `deferred.promise`.\n *\n * The purpose of the promise object is to allow for interested parties to get access to the result\n * of the deferred task when it completes.\n *\n * **Methods**\n *\n * - `then(successCallback, errorCallback)` – regardless of when the promise was or will be resolved\n *   or rejected, `then` calls one of the success or error callbacks asynchronously as soon as the result\n *   is available. The callbacks are called with a single argument: the result or rejection reason.\n *\n *   This method *returns a new promise* which is resolved or rejected via the return value of the\n *   `successCallback` or `errorCallback`.\n *\n *\n * # Chaining promises\n *\n * Because calling the `then` method of a promise returns a new derived promise, it is easily possible\n * to create a chain of promises:\n *\n * <pre>\n *   promiseB = promiseA.then(function(result) {\n *     return result + 1;\n *   });\n *\n *   // promiseB will be resolved immediately after promiseA is resolved and its value\n *   // will be the result of promiseA incremented by 1\n * </pre>\n *\n * It is possible to create chains of any length and since a promise can be resolved with another\n * promise (which will defer its resolution further), it is possible to pause/defer resolution of\n * the promises at any point in the chain. This makes it possible to implement powerful APIs like\n * $http's response interceptors.\n *\n *\n * # Differences between Kris Kowal's Q and $q\n *\n *  There are three main differences:\n *\n * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation\n *   mechanism in angular, which means faster propagation of resolution or rejection into your\n *   models and avoiding unnecessary browser repaints, which would result in flickering UI.\n * - $q promises are recognized by the templating engine in angular, which means that in templates\n *   you can treat promises attached to a scope as if they were the resulting values.\n * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains\n *   all the important functionality needed for common async tasks.\n * \n *  # Testing\n * \n *  <pre>\n *    it('should simulate promise', inject(function($q, $rootScope) {\n *      var deferred = $q.defer();\n *      var promise = deferred.promise;\n *      var resolvedValue;\n * \n *      promise.then(function(value) { resolvedValue = value; });\n *      expect(resolvedValue).toBeUndefined();\n * \n *      // Simulate resolving of promise\n *      deferred.resolve(123);\n *      // Note that the 'then' function does not get called synchronously.\n *      // This is because we want the promise API to always be async, whether or not\n *      // it got called synchronously or asynchronously.\n *      expect(resolvedValue).toBeUndefined();\n * \n *      // Propagate promise resolution to 'then' functions using $apply().\n *      $rootScope.$apply();\n *      expect(resolvedValue).toEqual(123);\n *    });\n *  </pre>\n */\nfunction $QProvider() {\n\n  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {\n    return qFactory(function(callback) {\n      $rootScope.$evalAsync(callback);\n    }, $exceptionHandler);\n  }];\n}\n\n\n/**\n * Constructs a promise manager.\n *\n * @param {function(function)} nextTick Function for executing functions in the next turn.\n * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for\n *     debugging purposes.\n * @returns {object} Promise manager.\n */\nfunction qFactory(nextTick, exceptionHandler) {\n\n  /**\n   * @ngdoc\n   * @name ng.$q#defer\n   * @methodOf ng.$q\n   * @description\n   * Creates a `Deferred` object which represents a task which will finish in the future.\n   *\n   * @returns {Deferred} Returns a new instance of deferred.\n   */\n  var defer = function() {\n    var pending = [],\n        value, deferred;\n\n    deferred = {\n\n      resolve: function(val) {\n        if (pending) {\n          var callbacks = pending;\n          pending = undefined;\n          value = ref(val);\n\n          if (callbacks.length) {\n            nextTick(function() {\n              var callback;\n              for (var i = 0, ii = callbacks.length; i < ii; i++) {\n                callback = callbacks[i];\n                value.then(callback[0], callback[1]);\n              }\n            });\n          }\n        }\n      },\n\n\n      reject: function(reason) {\n        deferred.resolve(reject(reason));\n      },\n\n\n      promise: {\n        then: function(callback, errback) {\n          var result = defer();\n\n          var wrappedCallback = function(value) {\n            try {\n              result.resolve((callback || defaultCallback)(value));\n            } catch(e) {\n              result.reject(e);\n              exceptionHandler(e);\n            }\n          };\n\n          var wrappedErrback = function(reason) {\n            try {\n              result.resolve((errback || defaultErrback)(reason));\n            } catch(e) {\n              result.reject(e);\n              exceptionHandler(e);\n            }\n          };\n\n          if (pending) {\n            pending.push([wrappedCallback, wrappedErrback]);\n          } else {\n            value.then(wrappedCallback, wrappedErrback);\n          }\n\n          return result.promise;\n        }\n      }\n    };\n\n    return deferred;\n  };\n\n\n  var ref = function(value) {\n    if (value && value.then) return value;\n    return {\n      then: function(callback) {\n        var result = defer();\n        nextTick(function() {\n          result.resolve(callback(value));\n        });\n        return result.promise;\n      }\n    };\n  };\n\n\n  /**\n   * @ngdoc\n   * @name ng.$q#reject\n   * @methodOf ng.$q\n   * @description\n   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be\n   * used to forward rejection in a chain of promises. If you are dealing with the last promise in\n   * a promise chain, you don't need to worry about it.\n   *\n   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of\n   * `reject` as the `throw` keyword in JavaScript. This also means that if you \"catch\" an error via\n   * a promise error callback and you want to forward the error to the promise derived from the\n   * current promise, you have to \"rethrow\" the error by returning a rejection constructed via\n   * `reject`.\n   *\n   * <pre>\n   *   promiseB = promiseA.then(function(result) {\n   *     // success: do something and resolve promiseB\n   *     //          with the old or a new result\n   *     return result;\n   *   }, function(reason) {\n   *     // error: handle the error if possible and\n   *     //        resolve promiseB with newPromiseOrValue,\n   *     //        otherwise forward the rejection to promiseB\n   *     if (canHandle(reason)) {\n   *      // handle the error and recover\n   *      return newPromiseOrValue;\n   *     }\n   *     return $q.reject(reason);\n   *   });\n   * </pre>\n   *\n   * @param {*} reason Constant, message, exception or an object representing the rejection reason.\n   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.\n   */\n  var reject = function(reason) {\n    return {\n      then: function(callback, errback) {\n        var result = defer();\n        nextTick(function() {\n          result.resolve((errback || defaultErrback)(reason));\n        });\n        return result.promise;\n      }\n    };\n  };\n\n\n  /**\n   * @ngdoc\n   * @name ng.$q#when\n   * @methodOf ng.$q\n   * @description\n   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.\n   * This is useful when you are dealing with an object that might or might not be a promise, or if\n   * the promise comes from a source that can't be trusted.\n   *\n   * @param {*} value Value or a promise\n   * @returns {Promise} Returns a promise of the passed value or promise\n   */\n  var when = function(value, callback, errback) {\n    var result = defer(),\n        done;\n\n    var wrappedCallback = function(value) {\n      try {\n        return (callback || defaultCallback)(value);\n      } catch (e) {\n        exceptionHandler(e);\n        return reject(e);\n      }\n    };\n\n    var wrappedErrback = function(reason) {\n      try {\n        return (errback || defaultErrback)(reason);\n      } catch (e) {\n        exceptionHandler(e);\n        return reject(e);\n      }\n    };\n\n    nextTick(function() {\n      ref(value).then(function(value) {\n        if (done) return;\n        done = true;\n        result.resolve(ref(value).then(wrappedCallback, wrappedErrback));\n      }, function(reason) {\n        if (done) return;\n        done = true;\n        result.resolve(wrappedErrback(reason));\n      });\n    });\n\n    return result.promise;\n  };\n\n\n  function defaultCallback(value) {\n    return value;\n  }\n\n\n  function defaultErrback(reason) {\n    return reject(reason);\n  }\n\n\n  /**\n   * @ngdoc\n   * @name ng.$q#all\n   * @methodOf ng.$q\n   * @description\n   * Combines multiple promises into a single promise that is resolved when all of the input\n   * promises are resolved.\n   *\n   * @param {Array.<Promise>} promises An array of promises.\n   * @returns {Promise} Returns a single promise that will be resolved with an array of values,\n   *   each value corresponding to the promise at the same index in the `promises` array. If any of\n   *   the promises is resolved with a rejection, this resulting promise will be resolved with the\n   *   same rejection.\n   */\n  function all(promises) {\n    var deferred = defer(),\n        counter = promises.length,\n        results = [];\n\n    if (counter) {\n      forEach(promises, function(promise, index) {\n        ref(promise).then(function(value) {\n          if (index in results) return;\n          results[index] = value;\n          if (!(--counter)) deferred.resolve(results);\n        }, function(reason) {\n          if (index in results) return;\n          deferred.reject(reason);\n        });\n      });\n    } else {\n      deferred.resolve(results);\n    }\n\n    return deferred.promise;\n  }\n\n  return {\n    defer: defer,\n    reject: reject,\n    when: when,\n    all: all\n  };\n}\n\n/**\n * @ngdoc object\n * @name ng.$routeProvider\n * @function\n *\n * @description\n *\n * Used for configuring routes. See {@link ng.$route $route} for an example.\n */\nfunction $RouteProvider(){\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name ng.$routeProvider#when\n   * @methodOf ng.$routeProvider\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *    `path` can contain named groups starting with a colon (`:name`). All characters up to the\n   *    next slash are matched and stored in `$routeParams` under the given `name` after the route\n   *    is resolved.\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller` – `{(string|function()=}` – Controller fn that should be associated with newly\n   *      created scope or the name of a {@link angular.Module#controller registered controller}\n   *      if passed as a string.\n   *    - `template` – `{string=}` –  html template as a string that should be used by\n   *      {@link ng.directive:ngView ngView} or\n   *      {@link ng.directive:ngInclude ngInclude} directives.\n   *      this property takes precedence over `templateUrl`.\n   *    - `templateUrl` – `{string=}` – path to an html template that should be used by\n   *      {@link ng.directive:ngView ngView}.\n   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, they will be\n   *      resolved and converted to a value before the controller is instantiated and the\n   *      `$routeChangeSuccess` event is fired. The map object is:\n   *\n   *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is resolved\n   *        before its value is injected into the controller. Be aware that `ngRoute.$routeParams` will\n   *        still refer to the previous route within these resolve functions.  Use `$route.current.params`\n   *        to access the new route parameters, instead.\n   *\n   *    - `redirectTo` – {(string|function())=} – value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.path()` and `$location.search()`.\n   *\n   *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()\n   *    changes.\n   *\n   *      If the option is set to `false` and url in the browser changes, then\n   *      `$routeUpdate` event is broadcasted on the root scope.\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    routes[path] = extend({reloadOnSearch: true}, route);\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length-1] == '/')\n          ? path.substr(0, path.length-1)\n          : path +'/';\n\n      routes[redirectPath] = {redirectTo: path};\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @name ng.$routeProvider#otherwise\n   * @methodOf ng.$routeProvider\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object} params Mapping information to be assigned to `$route.current`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    this.when(null, params);\n    return this;\n  };\n\n\n  this.$get = ['$rootScope', '$location', '$routeParams', '$q', '$injector', '$http', '$templateCache',\n      function( $rootScope,   $location,   $routeParams,   $q,   $injector,   $http,   $templateCache) {\n\n    /**\n     * @ngdoc object\n     * @name ng.$route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as define in route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     * @property {Array.<Object>} routes Array of all configured routes.\n     *\n     * @description\n     * Is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * You can define routes through {@link ng.$routeProvider $routeProvider}'s API.\n     *\n     * The `$route` service is typically used in conjunction with {@link ng.directive:ngView ngView}\n     * directive and the {@link ng.$routeParams $routeParams} service.\n     *\n     * @example\n       This example shows how changing the URL hash causes the `$route` to match a route against the\n       URL, and the `ngView` pulls in the partial.\n\n       Note that this example is using {@link ng.directive:script inlined templates}\n       to get it working on jsfiddle as well.\n\n     <example module=\"ngView\">\n       <file name=\"index.html\">\n         <div ng-controller=\"MainCntl\">\n           Choose:\n           <a href=\"Book/Moby\">Moby</a> |\n           <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n           <a href=\"Book/Gatsby\">Gatsby</a> |\n           <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n           <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n           <div ng-view></div>\n           <hr />\n\n           <pre>$location.path() = {{$location.path()}}</pre>\n           <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n           <pre>$route.current.params = {{$route.current.params}}</pre>\n           <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n           <pre>$routeParams = {{$routeParams}}</pre>\n         </div>\n       </file>\n\n       <file name=\"book.html\">\n         controller: {{name}}<br />\n         Book Id: {{params.bookId}}<br />\n       </file>\n\n       <file name=\"chapter.html\">\n         controller: {{name}}<br />\n         Book Id: {{params.bookId}}<br />\n         Chapter Id: {{params.chapterId}}\n       </file>\n\n       <file name=\"script.js\">\n         angular.module('ngView', [], function($routeProvider, $locationProvider) {\n           $routeProvider.when('/Book/:bookId', {\n             templateUrl: 'book.html',\n             controller: BookCntl,\n             resolve: {\n               // I will cause a 1 second delay\n               delay: function($q, $timeout) {\n                 var delay = $q.defer();\n                 $timeout(delay.resolve, 1000);\n                 return delay.promise;\n               }\n             }\n           });\n           $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n             templateUrl: 'chapter.html',\n             controller: ChapterCntl\n           });\n\n           // configure html5 to get links working on jsfiddle\n           $locationProvider.html5Mode(true);\n         });\n\n         function MainCntl($scope, $route, $routeParams, $location) {\n           $scope.$route = $route;\n           $scope.$location = $location;\n           $scope.$routeParams = $routeParams;\n         }\n\n         function BookCntl($scope, $routeParams) {\n           $scope.name = \"BookCntl\";\n           $scope.params = $routeParams;\n         }\n\n         function ChapterCntl($scope, $routeParams) {\n           $scope.name = \"ChapterCntl\";\n           $scope.params = $routeParams;\n         }\n       </file>\n\n       <file name=\"scenario.js\">\n         it('should load and compile correct template', function() {\n           element('a:contains(\"Moby: Ch1\")').click();\n           var content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: ChapterCntl/);\n           expect(content).toMatch(/Book Id\\: Moby/);\n           expect(content).toMatch(/Chapter Id\\: 1/);\n\n           element('a:contains(\"Scarlet\")').click();\n           sleep(2); // promises are not part of scenario waiting\n           content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: BookCntl/);\n           expect(content).toMatch(/Book Id\\: Scarlet/);\n         });\n       </file>\n     </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name ng.$route#$routeChangeStart\n     * @eventOf ng.$route\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occurs.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name ng.$route#$routeChangeSuccess\n     * @eventOf ng.$route\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route dependencies are resolved.\n     * {@link ng.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name ng.$route#$routeChangeError\n     * @eventOf ng.$route\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if any of the resolve promises are rejected.\n     *\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.\n     */\n\n    /**\n     * @ngdoc event\n     * @name ng.$route#$routeUpdate\n     * @eventOf ng.$route\n     * @eventType broadcast on root scope\n     * @description\n     *\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\n     * instance of the Controller.\n     */\n\n    var forceReload = false,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name ng.$route#reload\n           * @methodOf ng.$route\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn't changed.\n           *\n           * As a result of that, {@link ng.directive:ngView ngView}\n           * creates new scope, reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n            $rootScope.$evalAsync(updateRoute);\n          }\n        };\n\n    $rootScope.$on('$locationChangeSuccess', updateRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param when {string} route when template to match the url against\n     * @return {?Object}\n     */\n    function switchRouteMatcher(on, when) {\n      // TODO(i): this code is convoluted and inefficient, we should construct the route matching\n      //   regex only once and then reuse it\n\n      // Escape regexp special characters.\n      when = '^' + when.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\") + '$';\n      var regex = '',\n          params = [],\n          dst = {};\n\n      var re = /:(\\w+)/g,\n          paramMatch,\n          lastMatchedIndex = 0;\n\n      while ((paramMatch = re.exec(when)) !== null) {\n        // Find each :param in `when` and replace it with a capturing group.\n        // Append all other sections of when unchanged.\n        regex += when.slice(lastMatchedIndex, paramMatch.index);\n        regex += '([^\\\\/]*)';\n        params.push(paramMatch[1]);\n        lastMatchedIndex = re.lastIndex;\n      }\n      // Append trailing path part.\n      regex += when.substr(lastMatchedIndex);\n\n      var match = on.match(new RegExp(regex));\n      if (match) {\n        forEach(params, function(name, index) {\n          dst[name] = match[index + 1];\n        });\n      }\n      return match ? dst : null;\n    }\n\n    function updateRoute() {\n      var next = parseRoute(),\n          last = $route.current;\n\n      if (next && last && next.$$route === last.$$route\n          && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {\n        last.params = next.params;\n        copy(last.params, $routeParams);\n        $rootScope.$broadcast('$routeUpdate', last);\n      } else if (next || last) {\n        forceReload = false;\n        $rootScope.$broadcast('$routeChangeStart', next, last);\n        $route.current = next;\n        if (next) {\n          if (next.redirectTo) {\n            if (isString(next.redirectTo)) {\n              $location.path(interpolate(next.redirectTo, next.params)).search(next.params)\n                       .replace();\n            } else {\n              $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))\n                       .replace();\n            }\n          }\n        }\n\n        $q.when(next).\n          then(function() {\n            if (next) {\n              var keys = [],\n                  values = [],\n                  template;\n\n              forEach(next.resolve || {}, function(value, key) {\n                keys.push(key);\n                values.push(isString(value) ? $injector.get(value) : $injector.invoke(value));\n              });\n              if (isDefined(template = next.template)) {\n              } else if (isDefined(template = next.templateUrl)) {\n                template = $http.get(template, {cache: $templateCache}).\n                    then(function(response) { return response.data; });\n              }\n              if (isDefined(template)) {\n                keys.push('$template');\n                values.push(template);\n              }\n              return $q.all(values).then(function(values) {\n                var locals = {};\n                forEach(values, function(value, index) {\n                  locals[keys[index]] = value;\n                });\n                return locals;\n              });\n            }\n          }).\n          // after route change\n          then(function(locals) {\n            if (next == $route.current) {\n              if (next) {\n                next.locals = locals;\n                copy(next.params, $routeParams);\n              }\n              $rootScope.$broadcast('$routeChangeSuccess', next, last);\n            }\n          }, function(error) {\n            if (next == $route.current) {\n              $rootScope.$broadcast('$routeChangeError', next, last, error);\n            }\n          });\n      }\n    }\n\n\n    /**\n     * @returns the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), path))) {\n          match = inherit(route, {\n            params: extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to \"otherwise\" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @returns interpolation of the redirect path with the parametrs\n     */\n    function interpolate(string, params) {\n      var result = [];\n      forEach((string||'').split(':'), function(segment, i) {\n        if (i == 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || '');\n          delete params[key];\n        }\n      });\n      return result.join('');\n    }\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$routeParams\n * @requires $route\n *\n * @description\n * Current set of route parameters. The route parameters are a combination of the\n * {@link ng.$location $location} `search()`, and `path()`. The `path` parameters\n * are extracted when the {@link ng.$route $route} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route's parameters.\n *\n * @example\n * <pre>\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}\n * </pre>\n */\nfunction $RouteParamsProvider() {\n  this.$get = valueFn({});\n}\n\n/**\n * DESIGN NOTES\n *\n * The design decisions behind the scope are heavily favored for speed and memory consumption.\n *\n * The typical use of scope is to watch the expressions, which most of the time return the same\n * value as last time so we optimize the operation.\n *\n * Closures construction is expensive in terms of speed as well as memory:\n *   - No closures, instead use prototypical inheritance for API\n *   - Internal state needs to be stored on scope directly, which means that private state is\n *     exposed as $$____ properties\n *\n * Loop operations are optimized by using while(count--) { ... }\n *   - this means that in order to keep the same order of execution as addition we have to add\n *     items to the array at the beginning (shift) instead of at the end (push)\n *\n * Child scopes are created and removed often\n *   - Using an array would be slow since inserts in middle are expensive so we use linked list\n *\n * There are few watches then a lot of observers. This is why you don't want the observer to be\n * implemented in the same way as watch. Watch requires return of initialization function which\n * are expensive to construct.\n */\n\n\n/**\n * @ngdoc object\n * @name ng.$rootScopeProvider\n * @description\n *\n * Provider for the $rootScope service.\n */\n\n/**\n * @ngdoc function\n * @name ng.$rootScopeProvider#digestTtl\n * @methodOf ng.$rootScopeProvider\n * @description\n *\n * Sets the number of digest iterations the scope should attempt to execute before giving up and\n * assuming that the model is unstable.\n *\n * The current default is 10 iterations.\n *\n * @param {number} limit The number of digest iterations.\n */\n\n\n/**\n * @ngdoc object\n * @name ng.$rootScope\n * @description\n *\n * Every application has a single root {@link ng.$rootScope.Scope scope}.\n * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide\n * event processing life-cycle. See {@link guide/scope developer guide on scopes}.\n */\nfunction $RootScopeProvider(){\n  var TTL = 10;\n\n  this.digestTtl = function(value) {\n    if (arguments.length) {\n      TTL = value;\n    }\n    return TTL;\n  };\n\n  this.$get = ['$injector', '$exceptionHandler', '$parse',\n      function( $injector,   $exceptionHandler,   $parse) {\n\n    /**\n     * @ngdoc function\n     * @name ng.$rootScope.Scope\n     *\n     * @description\n     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the\n     * {@link AUTO.$injector $injector}. Child scopes are created using the\n     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when\n     * compiled HTML template is executed.)\n     *\n     * Here is a simple scope snippet to show how you can interact with the scope.\n     * <pre>\n        angular.injector(['ng']).invoke(function($rootScope) {\n           var scope = $rootScope.$new();\n           scope.salutation = 'Hello';\n           scope.name = 'World';\n\n           expect(scope.greeting).toEqual(undefined);\n\n           scope.$watch('name', function() {\n             scope.greeting = scope.salutation + ' ' + scope.name + '!';\n           }); // initialize the watch\n\n           expect(scope.greeting).toEqual(undefined);\n           scope.name = 'Misko';\n           // still old value, since watches have not been called yet\n           expect(scope.greeting).toEqual(undefined);\n\n           scope.$digest(); // fire all  the watches\n           expect(scope.greeting).toEqual('Hello Misko!');\n        });\n     * </pre>\n     *\n     * # Inheritance\n     * A scope can inherit from a parent scope, as in this example:\n     * <pre>\n         var parent = $rootScope;\n         var child = parent.$new();\n\n         parent.salutation = \"Hello\";\n         child.name = \"World\";\n         expect(child.salutation).toEqual('Hello');\n\n         child.salutation = \"Welcome\";\n         expect(child.salutation).toEqual('Welcome');\n         expect(parent.salutation).toEqual('Hello');\n     * </pre>\n     *\n     *\n     * @param {Object.<string, function()>=} providers Map of service factory which need to be provided\n     *     for the current scope. Defaults to {@link ng}.\n     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should\n     *     append/override services provided by `providers`. This is handy when unit-testing and having\n     *     the need to override a default service.\n     * @returns {Object} Newly created scope.\n     *\n     */\n    function Scope() {\n      this.$id = nextUid();\n      this.$$phase = this.$parent = this.$$watchers =\n                     this.$$nextSibling = this.$$prevSibling =\n                     this.$$childHead = this.$$childTail = null;\n      this['this'] = this.$root =  this;\n      this.$$destroyed = false;\n      this.$$asyncQueue = [];\n      this.$$listeners = {};\n      this.$$isolateBindings = {};\n    }\n\n    /**\n     * @ngdoc property\n     * @name ng.$rootScope.Scope#$id\n     * @propertyOf ng.$rootScope.Scope\n     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for\n     *   debugging.\n     */\n\n\n    Scope.prototype = {\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$new\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Creates a new child {@link ng.$rootScope.Scope scope}.\n       *\n       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and\n       * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope\n       * hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.\n       *\n       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for\n       * the scope and its child scopes to be permanently detached from the parent and thus stop\n       * participating in model change detection and listener notification by invoking.\n       *\n       * @param {boolean} isolate if true then the scope does not prototypically inherit from the\n       *         parent scope. The scope is isolated, as it can not see parent scope properties.\n       *         When creating widgets it is useful for the widget to not accidentally read parent\n       *         state.\n       *\n       * @returns {Object} The newly created child scope.\n       *\n       */\n      $new: function(isolate) {\n        var Child,\n            child;\n\n        if (isFunction(isolate)) {\n          // TODO: remove at some point\n          throw Error('API-CHANGE: Use $controller to instantiate controllers.');\n        }\n        if (isolate) {\n          child = new Scope();\n          child.$root = this.$root;\n        } else {\n          Child = function() {}; // should be anonymous; This is so that when the minifier munges\n            // the name it does not become random set of chars. These will then show up as class\n            // name in the debugger.\n          Child.prototype = this;\n          child = new Child();\n          child.$id = nextUid();\n        }\n        child['this'] = child;\n        child.$$listeners = {};\n        child.$parent = this;\n        child.$$asyncQueue = [];\n        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;\n        child.$$prevSibling = this.$$childTail;\n        if (this.$$childHead) {\n          this.$$childTail.$$nextSibling = child;\n          this.$$childTail = child;\n        } else {\n          this.$$childHead = this.$$childTail = child;\n        }\n        return child;\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$watch\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.\n       *\n       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and\n       *   should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}\n       *   reruns when it detects changes the `watchExpression` can execute multiple times per\n       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)\n       * - The `listener` is called only when the value from the current `watchExpression` and the\n       *   previous call to `watchExpression` are not equal (with the exception of the initial run,\n       *   see below). The inequality is determined according to\n       *   {@link angular.equals} function. To save the value of the object for later comparison, the\n       *   {@link angular.copy} function is used. It also means that watching complex options will\n       *   have adverse memory and performance implications.\n       * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This\n       *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration\n       *   limit is 10 to prevent an infinite loop deadlock.\n       *\n       *\n       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,\n       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`\n       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is\n       * detected, be prepared for multiple calls to your listener.)\n       *\n       * After a watcher is registered with the scope, the `listener` fn is called asynchronously\n       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the\n       * watcher. In rare cases, this is undesirable because the listener is called when the result\n       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you\n       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the\n       * listener was called due to initialization.\n       *\n       *\n       * # Example\n       * <pre>\n           // let's assume that scope was dependency injected as the $rootScope\n           var scope = $rootScope;\n           scope.name = 'misko';\n           scope.counter = 0;\n\n           expect(scope.counter).toEqual(0);\n           scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; });\n           expect(scope.counter).toEqual(0);\n\n           scope.$digest();\n           // no variable change\n           expect(scope.counter).toEqual(0);\n\n           scope.name = 'adam';\n           scope.$digest();\n           expect(scope.counter).toEqual(1);\n       * </pre>\n       *\n       *\n       *\n       * @param {(function()|string)} watchExpression Expression that is evaluated on each\n       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a\n       *    call to the `listener`.\n       *\n       *    - `string`: Evaluated as {@link guide/expression expression}\n       *    - `function(scope)`: called with current `scope` as a parameter.\n       * @param {(function()|string)=} listener Callback called whenever the return value of\n       *   the `watchExpression` changes.\n       *\n       *    - `string`: Evaluated as {@link guide/expression expression}\n       *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.\n       *\n       * @param {boolean=} objectEquality Compare object for equality rather than for reference.\n       * @returns {function()} Returns a deregistration function for this listener.\n       */\n      $watch: function(watchExp, listener, objectEquality) {\n        var scope = this,\n            get = compileToFn(watchExp, 'watch'),\n            array = scope.$$watchers,\n            watcher = {\n              fn: listener,\n              last: initWatchVal,\n              get: get,\n              exp: watchExp,\n              eq: !!objectEquality\n            };\n\n        // in the case user pass string, we need to compile it, do we really need this ?\n        if (!isFunction(listener)) {\n          var listenFn = compileToFn(listener || noop, 'listener');\n          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};\n        }\n\n        if (!array) {\n          array = scope.$$watchers = [];\n        }\n        // we use unshift since we use a while loop in $digest for speed.\n        // the while loop reads in reverse order.\n        array.unshift(watcher);\n\n        return function() {\n          arrayRemove(array, watcher);\n        };\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$digest\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.\n       * Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the\n       * `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are\n       * firing. This means that it is possible to get into an infinite loop. This function will throw\n       * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 10.\n       *\n       * Usually you don't call `$digest()` directly in\n       * {@link ng.directive:ngController controllers} or in\n       * {@link ng.$compileProvider#directive directives}.\n       * Instead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a\n       * {@link ng.$compileProvider#directive directives}) will force a `$digest()`.\n       *\n       * If you want to be notified whenever `$digest()` is called,\n       * you can register a `watchExpression` function  with {@link ng.$rootScope.Scope#$watch $watch()}\n       * with no `listener`.\n       *\n       * You may have a need to call `$digest()` from within unit-tests, to simulate the scope\n       * life-cycle.\n       *\n       * # Example\n       * <pre>\n           var scope = ...;\n           scope.name = 'misko';\n           scope.counter = 0;\n\n           expect(scope.counter).toEqual(0);\n           scope.$watch('name', function(newValue, oldValue) {\n             scope.counter = scope.counter + 1;\n           });\n           expect(scope.counter).toEqual(0);\n\n           scope.$digest();\n           // no variable change\n           expect(scope.counter).toEqual(0);\n\n           scope.name = 'adam';\n           scope.$digest();\n           expect(scope.counter).toEqual(1);\n       * </pre>\n       *\n       */\n      $digest: function() {\n        var watch, value, last,\n            watchers,\n            asyncQueue,\n            length,\n            dirty, ttl = TTL,\n            next, current, target = this,\n            watchLog = [],\n            logIdx, logMsg;\n\n        beginPhase('$digest');\n\n        do {\n          dirty = false;\n          current = target;\n          do {\n            asyncQueue = current.$$asyncQueue;\n            while(asyncQueue.length) {\n              try {\n                current.$eval(asyncQueue.shift());\n              } catch (e) {\n                $exceptionHandler(e);\n              }\n            }\n            if ((watchers = current.$$watchers)) {\n              // process our watches\n              length = watchers.length;\n              while (length--) {\n                try {\n                  watch = watchers[length];\n                  // Most common watches are on primitives, in which case we can short\n                  // circuit it with === operator, only when === fails do we use .equals\n                  if (watch && (value = watch.get(current)) !== (last = watch.last) &&\n                      !(watch.eq\n                          ? equals(value, last)\n                          : (typeof value == 'number' && typeof last == 'number'\n                             && isNaN(value) && isNaN(last)))) {\n                    dirty = true;\n                    watch.last = watch.eq ? copy(value) : value;\n                    watch.fn(value, ((last === initWatchVal) ? value : last), current);\n                    if (ttl < 5) {\n                      logIdx = 4 - ttl;\n                      if (!watchLog[logIdx]) watchLog[logIdx] = [];\n                      logMsg = (isFunction(watch.exp))\n                          ? 'fn: ' + (watch.exp.name || watch.exp.toString())\n                          : watch.exp;\n                      logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);\n                      watchLog[logIdx].push(logMsg);\n                    }\n                  }\n                } catch (e) {\n                  $exceptionHandler(e);\n                }\n              }\n            }\n\n            // Insanity Warning: scope depth-first traversal\n            // yes, this code is a bit crazy, but it works and we have tests to prove it!\n            // this piece should be kept in sync with the traversal in $broadcast\n            if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {\n              while(current !== target && !(next = current.$$nextSibling)) {\n                current = current.$parent;\n              }\n            }\n          } while ((current = next));\n\n          if(dirty && !(ttl--)) {\n            clearPhase();\n            throw Error(TTL + ' $digest() iterations reached. Aborting!\\n' +\n                'Watchers fired in the last 5 iterations: ' + toJson(watchLog));\n          }\n        } while (dirty || asyncQueue.length);\n\n        clearPhase();\n      },\n\n\n      /**\n       * @ngdoc event\n       * @name ng.$rootScope.Scope#$destroy\n       * @eventOf ng.$rootScope.Scope\n       * @eventType broadcast on scope being destroyed\n       *\n       * @description\n       * Broadcasted when a scope and its children are being destroyed.\n       * \n       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to\n       * clean up DOM bindings before an element is removed from the DOM.\n       */\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$destroy\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Removes the current scope (and all of its children) from the parent scope. Removal implies\n       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer\n       * propagate to the current scope and its children. Removal also implies that the current\n       * scope is eligible for garbage collection.\n       *\n       * The `$destroy()` is usually used by directives such as\n       * {@link ng.directive:ngRepeat ngRepeat} for managing the\n       * unrolling of the loop.\n       *\n       * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.\n       * Application code can register a `$destroy` event handler that will give it chance to\n       * perform any necessary cleanup.\n       * \n       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to\n       * clean up DOM bindings before an element is removed from the DOM.\n       */\n      $destroy: function() {\n        // we can't destroy the root scope or a scope that has been already destroyed\n        if ($rootScope == this || this.$$destroyed) return;\n        var parent = this.$parent;\n\n        this.$broadcast('$destroy');\n        this.$$destroyed = true;\n\n        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;\n        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;\n        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;\n        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;\n\n        // This is bogus code that works around Chrome's GC leak\n        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451\n        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =\n            this.$$childTail = null;\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$eval\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Executes the `expression` on the current scope returning the result. Any exceptions in the\n       * expression are propagated (uncaught). This is useful when evaluating Angular expressions.\n       *\n       * # Example\n       * <pre>\n           var scope = ng.$rootScope.Scope();\n           scope.a = 1;\n           scope.b = 2;\n\n           expect(scope.$eval('a+b')).toEqual(3);\n           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);\n       * </pre>\n       *\n       * @param {(string|function())=} expression An angular expression to be executed.\n       *\n       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.\n       *    - `function(scope)`: execute the function with the current `scope` parameter.\n       *\n       * @returns {*} The result of evaluating the expression.\n       */\n      $eval: function(expr, locals) {\n        return $parse(expr)(this, locals);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$evalAsync\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Executes the expression on the current scope at a later point in time.\n       *\n       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:\n       *\n       *   - it will execute in the current script execution context (before any DOM rendering).\n       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after\n       *     `expression` execution.\n       *\n       * Any exceptions from the execution of the expression are forwarded to the\n       * {@link ng.$exceptionHandler $exceptionHandler} service.\n       *\n       * @param {(string|function())=} expression An angular expression to be executed.\n       *\n       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.\n       *    - `function(scope)`: execute the function with the current `scope` parameter.\n       *\n       */\n      $evalAsync: function(expr) {\n        this.$$asyncQueue.push(expr);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$apply\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * `$apply()` is used to execute an expression in angular from outside of the angular framework.\n       * (For example from browser DOM events, setTimeout, XHR or third party libraries).\n       * Because we are calling into the angular framework we need to perform proper scope life-cycle\n       * of {@link ng.$exceptionHandler exception handling},\n       * {@link ng.$rootScope.Scope#$digest executing watches}.\n       *\n       * ## Life cycle\n       *\n       * # Pseudo-Code of `$apply()`\n       * <pre>\n           function $apply(expr) {\n             try {\n               return $eval(expr);\n             } catch (e) {\n               $exceptionHandler(e);\n             } finally {\n               $root.$digest();\n             }\n           }\n       * </pre>\n       *\n       *\n       * Scope's `$apply()` method transitions through the following stages:\n       *\n       * 1. The {@link guide/expression expression} is executed using the\n       *    {@link ng.$rootScope.Scope#$eval $eval()} method.\n       * 2. Any exceptions from the execution of the expression are forwarded to the\n       *    {@link ng.$exceptionHandler $exceptionHandler} service.\n       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression\n       *    was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.\n       *\n       *\n       * @param {(string|function())=} exp An angular expression to be executed.\n       *\n       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.\n       *    - `function(scope)`: execute the function with current `scope` parameter.\n       *\n       * @returns {*} The result of evaluating the expression.\n       */\n      $apply: function(expr) {\n        try {\n          beginPhase('$apply');\n          return this.$eval(expr);\n        } catch (e) {\n          $exceptionHandler(e);\n        } finally {\n          clearPhase();\n          try {\n            $rootScope.$digest();\n          } catch (e) {\n            $exceptionHandler(e);\n            throw e;\n          }\n        }\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$on\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of\n       * event life cycle.\n       *\n       * The event listener function format is: `function(event, args...)`. The `event` object\n       * passed into the listener has the following attributes:\n       *\n       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or `$broadcast`-ed.\n       *   - `currentScope` - `{Scope}`: the current scope which is handling the event.\n       *   - `name` - `{string}`: Name of the event.\n       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel further event\n       *     propagation (available only for events that were `$emit`-ed).\n       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag to true.\n       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.\n       *\n       * @param {string} name Event name to listen on.\n       * @param {function(event, args...)} listener Function to call when the event is emitted.\n       * @returns {function()} Returns a deregistration function for this listener.\n       */\n      $on: function(name, listener) {\n        var namedListeners = this.$$listeners[name];\n        if (!namedListeners) {\n          this.$$listeners[name] = namedListeners = [];\n        }\n        namedListeners.push(listener);\n\n        return function() {\n          namedListeners[indexOf(namedListeners, listener)] = null;\n        };\n      },\n\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$emit\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Dispatches an event `name` upwards through the scope hierarchy notifying the\n       * registered {@link ng.$rootScope.Scope#$on} listeners.\n       *\n       * The event life cycle starts at the scope on which `$emit` was called. All\n       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\n       * Afterwards, the event traverses upwards toward the root scope and calls all registered\n       * listeners along the way. The event will stop propagating if one of the listeners cancels it.\n       *\n       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed\n       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.\n       *\n       * @param {string} name Event name to emit.\n       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.\n       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}\n       */\n      $emit: function(name, args) {\n        var empty = [],\n            namedListeners,\n            scope = this,\n            stopPropagation = false,\n            event = {\n              name: name,\n              targetScope: scope,\n              stopPropagation: function() {stopPropagation = true;},\n              preventDefault: function() {\n                event.defaultPrevented = true;\n              },\n              defaultPrevented: false\n            },\n            listenerArgs = concat([event], arguments, 1),\n            i, length;\n\n        do {\n          namedListeners = scope.$$listeners[name] || empty;\n          event.currentScope = scope;\n          for (i=0, length=namedListeners.length; i<length; i++) {\n\n            // if listeners were deregistered, defragment the array\n            if (!namedListeners[i]) {\n              namedListeners.splice(i, 1);\n              i--;\n              length--;\n              continue;\n            }\n            try {\n              namedListeners[i].apply(null, listenerArgs);\n              if (stopPropagation) return event;\n            } catch (e) {\n              $exceptionHandler(e);\n            }\n          }\n          //traverse upwards\n          scope = scope.$parent;\n        } while (scope);\n\n        return event;\n      },\n\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$broadcast\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the\n       * registered {@link ng.$rootScope.Scope#$on} listeners.\n       *\n       * The event life cycle starts at the scope on which `$broadcast` was called. All\n       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\n       * Afterwards, the event propagates to all direct and indirect scopes of the current scope and\n       * calls all registered listeners along the way. The event cannot be canceled.\n       *\n       * Any exception emmited from the {@link ng.$rootScope.Scope#$on listeners} will be passed\n       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.\n       *\n       * @param {string} name Event name to broadcast.\n       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.\n       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}\n       */\n      $broadcast: function(name, args) {\n        var target = this,\n            current = target,\n            next = target,\n            event = {\n              name: name,\n              targetScope: target,\n              preventDefault: function() {\n                event.defaultPrevented = true;\n              },\n              defaultPrevented: false\n            },\n            listenerArgs = concat([event], arguments, 1),\n            listeners, i, length;\n\n        //down while you can, then up and next sibling or up and next sibling until back at root\n        do {\n          current = next;\n          event.currentScope = current;\n          listeners = current.$$listeners[name] || [];\n          for (i=0, length = listeners.length; i<length; i++) {\n            // if listeners were deregistered, defragment the array\n            if (!listeners[i]) {\n              listeners.splice(i, 1);\n              i--;\n              length--;\n              continue;\n            }\n\n            try {\n              listeners[i].apply(null, listenerArgs);\n            } catch(e) {\n              $exceptionHandler(e);\n            }\n          }\n\n          // Insanity Warning: scope depth-first traversal\n          // yes, this code is a bit crazy, but it works and we have tests to prove it!\n          // this piece should be kept in sync with the traversal in $digest\n          if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {\n            while(current !== target && !(next = current.$$nextSibling)) {\n              current = current.$parent;\n            }\n          }\n        } while ((current = next));\n\n        return event;\n      }\n    };\n\n    var $rootScope = new Scope();\n\n    return $rootScope;\n\n\n    function beginPhase(phase) {\n      if ($rootScope.$$phase) {\n        throw Error($rootScope.$$phase + ' already in progress');\n      }\n\n      $rootScope.$$phase = phase;\n    }\n\n    function clearPhase() {\n      $rootScope.$$phase = null;\n    }\n\n    function compileToFn(exp, name) {\n      var fn = $parse(exp);\n      assertArgFn(fn, name);\n      return fn;\n    }\n\n    /**\n     * function used as an initial value for watchers.\n     * because it's unique we can easily tell it apart from other values\n     */\n    function initWatchVal() {}\n  }];\n}\n\n/**\n * !!! This is an undocumented \"private\" service !!!\n *\n * @name ng.$sniffer\n * @requires $window\n *\n * @property {boolean} history Does the browser support html5 history api ?\n * @property {boolean} hashchange Does the browser support hashchange event ?\n *\n * @description\n * This is very simple implementation of testing browser's features.\n */\nfunction $SnifferProvider() {\n  this.$get = ['$window', function($window) {\n    var eventSupport = {},\n        android = int((/android (\\d+)/.exec(lowercase($window.navigator.userAgent)) || [])[1]);\n\n    return {\n      // Android has history.pushState, but it does not update location correctly\n      // so let's not use the history API at all.\n      // http://code.google.com/p/android/issues/detail?id=17471\n      // https://github.com/angular/angular.js/issues/904\n      history: !!($window.history && $window.history.pushState && !(android < 4)),\n      hashchange: 'onhashchange' in $window &&\n                  // IE8 compatible mode lies\n                  (!$window.document.documentMode || $window.document.documentMode > 7),\n      hasEvent: function(event) {\n        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have\n        // it. In particular the event is not fired when backspace or delete key are pressed or\n        // when cut operation is performed.\n        if (event == 'input' && msie == 9) return false;\n\n        if (isUndefined(eventSupport[event])) {\n          var divElm = $window.document.createElement('div');\n          eventSupport[event] = 'on' + event in divElm;\n        }\n\n        return eventSupport[event];\n      },\n      // TODO(i): currently there is no way to feature detect CSP without triggering alerts\n      csp: false\n    };\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$window\n *\n * @description\n * A reference to the browser's `window` object. While `window`\n * is globally available in JavaScript, it causes testability problems, because\n * it is a global variable. In angular we always refer to it through the\n * `$window` service, so it may be overriden, removed or mocked for testing.\n *\n * Expressions, like the one defined for the `ngClick` directive in the example\n * below, are evaluated with respect to the current scope.  Therefore, there is\n * no risk of inadvertently coding in a dependency on a global value in such an\n * expression.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope, $window) {\n           $scope.$window = $window;\n           $scope.greeting = 'Hello, World!';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <input type=\"text\" ng-model=\"greeting\" />\n         <button ng-click=\"$window.alert(greeting)\">ALERT</button>\n       </div>\n     </doc:source>\n     <doc:scenario>\n      it('should display the greeting in the input box', function() {\n       input('greeting').enter('Hello, E2E Tests');\n       // If we click the button it will block the test runner\n       // element(':button').click();\n      });\n     </doc:scenario>\n   </doc:example>\n */\nfunction $WindowProvider(){\n  this.$get = valueFn(window);\n}\n\n/**\n * Parse headers into key value object\n *\n * @param {string} headers Raw headers as a string\n * @returns {Object} Parsed headers as key value object\n */\nfunction parseHeaders(headers) {\n  var parsed = {}, key, val, i;\n\n  if (!headers) return parsed;\n\n  forEach(headers.split('\\n'), function(line) {\n    i = line.indexOf(':');\n    key = lowercase(trim(line.substr(0, i)));\n    val = trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key]) {\n        parsed[key] += ', ' + val;\n      } else {\n        parsed[key] = val;\n      }\n    }\n  });\n\n  return parsed;\n}\n\n\n/**\n * Returns a function that provides access to parsed headers.\n *\n * Headers are lazy parsed when first requested.\n * @see parseHeaders\n *\n * @param {(string|Object)} headers Headers to provide access to.\n * @returns {function(string=)} Returns a getter function which if called with:\n *\n *   - if called with single an argument returns a single header value or null\n *   - if called with no arguments returns an object containing all headers.\n */\nfunction headersGetter(headers) {\n  var headersObj = isObject(headers) ? headers : undefined;\n\n  return function(name) {\n    if (!headersObj) headersObj =  parseHeaders(headers);\n\n    if (name) {\n      return headersObj[lowercase(name)] || null;\n    }\n\n    return headersObj;\n  };\n}\n\n\n/**\n * Chain all given functions\n *\n * This function is used for both request and response transforming\n *\n * @param {*} data Data to transform.\n * @param {function(string=)} headers Http headers getter fn.\n * @param {(function|Array.<function>)} fns Function or an array of functions.\n * @returns {*} Transformed data.\n */\nfunction transformData(data, headers, fns) {\n  if (isFunction(fns))\n    return fns(data, headers);\n\n  forEach(fns, function(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n}\n\n\nfunction isSuccess(status) {\n  return 200 <= status && status < 300;\n}\n\n\nfunction $HttpProvider() {\n  var JSON_START = /^\\s*(\\[|\\{[^\\{])/,\n      JSON_END = /[\\}\\]]\\s*$/,\n      PROTECTION_PREFIX = /^\\)\\]\\}',?\\n/;\n\n  var $config = this.defaults = {\n    // transform incoming response data\n    transformResponse: [function(data) {\n      if (isString(data)) {\n        // strip json vulnerability protection prefix\n        data = data.replace(PROTECTION_PREFIX, '');\n        if (JSON_START.test(data) && JSON_END.test(data))\n          data = fromJson(data, true);\n      }\n      return data;\n    }],\n\n    // transform outgoing request data\n    transformRequest: [function(d) {\n      return isObject(d) && !isFile(d) ? toJson(d) : d;\n    }],\n\n    // default headers\n    headers: {\n      common: {\n        'Accept': 'application/json, text/plain, */*',\n        'X-Requested-With': 'XMLHttpRequest'\n      },\n      post: {'Content-Type': 'application/json;charset=utf-8'},\n      put:  {'Content-Type': 'application/json;charset=utf-8'}\n    }\n  };\n\n  var providerResponseInterceptors = this.responseInterceptors = [];\n\n  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',\n      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {\n\n    var defaultCache = $cacheFactory('$http'),\n        responseInterceptors = [];\n\n    forEach(providerResponseInterceptors, function(interceptor) {\n      responseInterceptors.push(\n          isString(interceptor)\n              ? $injector.get(interceptor)\n              : $injector.invoke(interceptor)\n      );\n    });\n\n\n    /**\n     * @ngdoc function\n     * @name ng.$http\n     * @requires $httpBackend\n     * @requires $browser\n     * @requires $cacheFactory\n     * @requires $rootScope\n     * @requires $q\n     * @requires $injector\n     *\n     * @description\n     * The `$http` service is a core Angular service that facilitates communication with the remote\n     * HTTP servers via the browser's {@link https://developer.mozilla.org/en/xmlhttprequest\n     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.\n     *\n     * For unit testing applications that use `$http` service, see\n     * {@link ngMock.$httpBackend $httpBackend mock}.\n     *\n     * For a higher level of abstraction, please check out the {@link ngResource.$resource\n     * $resource} service.\n     *\n     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by\n     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage\n     * it is important to familiarize yourself with these APIs and the guarantees they provide.\n     *\n     *\n     * # General usage\n     * The `$http` service is a function which takes a single argument — a configuration object —\n     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}\n     * with two $http specific methods: `success` and `error`.\n     *\n     * <pre>\n     *   $http({method: 'GET', url: '/someUrl'}).\n     *     success(function(data, status, headers, config) {\n     *       // this callback will be called asynchronously\n     *       // when the response is available\n     *     }).\n     *     error(function(data, status, headers, config) {\n     *       // called asynchronously if an error occurs\n     *       // or server returns response with an error status.\n     *     });\n     * </pre>\n     *\n     * Since the returned value of calling the $http function is a `promise`, you can also use\n     * the `then` method to register callbacks, and these callbacks will receive a single argument –\n     * an object representing the response. See the API signature and type info below for more\n     * details.\n     *\n     * A response status code between 200 and 299 is considered a success status and\n     * will result in the success callback being called. Note that if the response is a redirect,\n     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be\n     * called for such responses.\n     *\n     * # Shortcut methods\n     *\n     * Since all invocations of the $http service require passing in an HTTP method and URL, and\n     * POST/PUT requests require request data to be provided as well, shortcut methods\n     * were created:\n     *\n     * <pre>\n     *   $http.get('/someUrl').success(successCallback);\n     *   $http.post('/someUrl', data).success(successCallback);\n     * </pre>\n     *\n     * Complete list of shortcut methods:\n     *\n     * - {@link ng.$http#get $http.get}\n     * - {@link ng.$http#head $http.head}\n     * - {@link ng.$http#post $http.post}\n     * - {@link ng.$http#put $http.put}\n     * - {@link ng.$http#delete $http.delete}\n     * - {@link ng.$http#jsonp $http.jsonp}\n     *\n     *\n     * # Setting HTTP Headers\n     *\n     * The $http service will automatically add certain HTTP headers to all requests. These defaults\n     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration\n     * object, which currently contains this default configuration:\n     *\n     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):\n     *   - `Accept: application/json, text/plain, * / *`\n     *   - `X-Requested-With: XMLHttpRequest`\n     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)\n     *   - `Content-Type: application/json`\n     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)\n     *   - `Content-Type: application/json`\n     *\n     * To add or overwrite these defaults, simply add or remove a property from these configuration\n     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object\n     * with the lowercased HTTP method name as the key, e.g.\n     * `$httpProvider.defaults.headers.get['My-Header']='value'`.\n     *\n     * Additionally, the defaults can be set at runtime via the `$http.defaults` object in the same\n     * fashion.\n     *\n     *\n     * # Transforming Requests and Responses\n     *\n     * Both requests and responses can be transformed using transform functions. By default, Angular\n     * applies these transformations:\n     *\n     * Request transformations:\n     *\n     * - If the `data` property of the request configuration object contains an object, serialize it into\n     *   JSON format.\n     *\n     * Response transformations:\n     *\n     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).\n     *  - If JSON response is detected, deserialize it using a JSON parser.\n     *\n     * To globally augment or override the default transforms, modify the `$httpProvider.defaults.transformRequest` and\n     * `$httpProvider.defaults.transformResponse` properties. These properties are by default an\n     * array of transform functions, which allows you to `push` or `unshift` a new transformation function into the\n     * transformation chain. You can also decide to completely override any default transformations by assigning your\n     * transformation functions to these properties directly without the array wrapper.\n     *\n     * Similarly, to locally override the request/response transforms, augment the `transformRequest` and/or\n     * `transformResponse` properties of the configuration object passed into `$http`.\n     *\n     *\n     * # Caching\n     *\n     * To enable caching, set the configuration property `cache` to `true`. When the cache is\n     * enabled, `$http` stores the response from the server in local cache. Next time the\n     * response is served from the cache without sending a request to the server.\n     *\n     * Note that even if the response is served from cache, delivery of the data is asynchronous in\n     * the same way that real requests are.\n     *\n     * If there are multiple GET requests for the same URL that should be cached using the same\n     * cache, but the cache is not populated yet, only one request to the server will be made and\n     * the remaining requests will be fulfilled using the response from the first request.\n     *\n     *\n     * # Response interceptors\n     *\n     * Before you start creating interceptors, be sure to understand the\n     * {@link ng.$q $q and deferred/promise APIs}.\n     *\n     * For purposes of global error handling, authentication or any kind of synchronous or\n     * asynchronous preprocessing of received responses, it is desirable to be able to intercept\n     * responses for http requests before they are handed over to the application code that\n     * initiated these requests. The response interceptors leverage the {@link ng.$q\n     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.\n     *\n     * The interceptors are service factories that are registered with the $httpProvider by\n     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and\n     * injected with dependencies (if specified) and returns the interceptor  — a function that\n     * takes a {@link ng.$q promise} and returns the original or a new promise.\n     *\n     * <pre>\n     *   // register the interceptor as a service\n     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {\n     *     return function(promise) {\n     *       return promise.then(function(response) {\n     *         // do something on success\n     *         return response;\n     *       }, function(response) {\n     *         // do something on error\n     *         if (canRecover(response)) {\n     *           return responseOrNewPromise\n     *         }\n     *         return $q.reject(response);\n     *       });\n     *     }\n     *   });\n     *\n     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');\n     *\n     *\n     *   // register the interceptor via an anonymous factory\n     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {\n     *     return function(promise) {\n     *       // same as above\n     *     }\n     *   });\n     * </pre>\n     *\n     *\n     * # Security Considerations\n     *\n     * When designing web applications, consider security threats from:\n     *\n     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\n     *   JSON vulnerability}\n     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}\n     *\n     * Both server and the client must cooperate in order to eliminate these threats. Angular comes\n     * pre-configured with strategies that address these issues, but for this to work backend server\n     * cooperation is required.\n     *\n     * ## JSON Vulnerability Protection\n     *\n     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\n     * JSON vulnerability} allows third party website to turn your JSON resource URL into\n     * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To\n     * counter this your server can prefix all JSON requests with following string `\")]}',\\n\"`.\n     * Angular will automatically strip the prefix before processing it as JSON.\n     *\n     * For example if your server needs to return:\n     * <pre>\n     * ['one','two']\n     * </pre>\n     *\n     * which is vulnerable to attack, your server can return:\n     * <pre>\n     * )]}',\n     * ['one','two']\n     * </pre>\n     *\n     * Angular will strip the prefix, before processing the JSON.\n     *\n     *\n     * ## Cross Site Request Forgery (XSRF) Protection\n     *\n     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which\n     * an unauthorized site can gain your user's private data. Angular provides a mechanism\n     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie\n     * called `XSRF-TOKEN` and sets it as the HTTP header `X-XSRF-TOKEN`. Since only JavaScript that\n     * runs on your domain could read the cookie, your server can be assured that the XHR came from\n     * JavaScript running on your domain.\n     *\n     * To take advantage of this, your server needs to set a token in a JavaScript readable session\n     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the\n     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure\n     * that only JavaScript running on your domain could have sent the request. The token must be\n     * unique for each user and must be verifiable by the server (to prevent the JavaScript from making\n     * up its own tokens). We recommend that the token is a digest of your site's authentication\n     * cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt} for added security.\n     *\n     *\n     * @param {object} config Object describing the request to be made and how it should be\n     *    processed. The object has following properties:\n     *\n     *    - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)\n     *    - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.\n     *    - **params** – `{Object.<string|Object>}` – Map of strings or objects which will be turned to\n     *      `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.\n     *    - **data** – `{string|Object}` – Data to be sent as the request message data.\n     *    - **headers** – `{Object}` – Map of strings representing HTTP headers to send to the server.\n     *    - **transformRequest** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n     *      transform function or an array of such functions. The transform function takes the http\n     *      request body and headers and returns its transformed (typically serialized) version.\n     *    - **transformResponse** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n     *      transform function or an array of such functions. The transform function takes the http\n     *      response body and headers and returns its transformed (typically deserialized) version.\n     *    - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n     *      GET request, otherwise if a cache instance built with\n     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n     *      caching.\n     *    - **timeout** – `{number}` – timeout in milliseconds.\n     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the\n     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5\n     *      requests with credentials} for more information.\n     *\n     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the\n     *   standard `then` method and two http specific methods: `success` and `error`. The `then`\n     *   method takes two arguments a success and an error callback which will be called with a\n     *   response object. The `success` and `error` methods take a single argument - a function that\n     *   will be called when the request succeeds or fails respectively. The arguments passed into\n     *   these functions are destructured representation of the response object passed into the\n     *   `then` method. The response object has these properties:\n     *\n     *   - **data** – `{string|Object}` – The response body transformed with the transform functions.\n     *   - **status** – `{number}` – HTTP status code of the response.\n     *   - **headers** – `{function([headerName])}` – Header getter function.\n     *   - **config** – `{Object}` – The configuration object that was used to generate the request.\n     *\n     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending\n     *   requests. This is primarily meant to be used for debugging purposes.\n     *\n     *\n     * @example\n      <example>\n        <file name=\"index.html\">\n          <div ng-controller=\"FetchCtrl\">\n            <select ng-model=\"method\">\n              <option>GET</option>\n              <option>JSONP</option>\n            </select>\n            <input type=\"text\" ng-model=\"url\" size=\"80\"/>\n            <button ng-click=\"fetch()\">fetch</button><br>\n            <button ng-click=\"updateModel('GET', 'http-hello.html')\">Sample GET</button>\n            <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')\">Sample JSONP</button>\n            <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')\">Invalid JSONP</button>\n            <pre>http status code: {{status}}</pre>\n            <pre>http response data: {{data}}</pre>\n          </div>\n        </file>\n        <file name=\"script.js\">\n          function FetchCtrl($scope, $http, $templateCache) {\n            $scope.method = 'GET';\n            $scope.url = 'http-hello.html';\n\n            $scope.fetch = function() {\n              $scope.code = null;\n              $scope.response = null;\n\n              $http({method: $scope.method, url: $scope.url, cache: $templateCache}).\n                success(function(data, status) {\n                  $scope.status = status;\n                  $scope.data = data;\n                }).\n                error(function(data, status) {\n                  $scope.data = data || \"Request failed\";\n                  $scope.status = status;\n              });\n            };\n\n            $scope.updateModel = function(method, url) {\n              $scope.method = method;\n              $scope.url = url;\n            };\n          }\n        </file>\n        <file name=\"http-hello.html\">\n          Hello, $http!\n        </file>\n        <file name=\"scenario.js\">\n          it('should make an xhr GET request', function() {\n            element(':button:contains(\"Sample GET\")').click();\n            element(':button:contains(\"fetch\")').click();\n            expect(binding('status')).toBe('200');\n            expect(binding('data')).toMatch(/Hello, \\$http!/);\n          });\n\n          it('should make a JSONP request to angularjs.org', function() {\n            element(':button:contains(\"Sample JSONP\")').click();\n            element(':button:contains(\"fetch\")').click();\n            expect(binding('status')).toBe('200');\n            expect(binding('data')).toMatch(/Super Hero!/);\n          });\n\n          it('should make JSONP request to invalid URL and invoke the error handler',\n              function() {\n            element(':button:contains(\"Invalid JSONP\")').click();\n            element(':button:contains(\"fetch\")').click();\n            expect(binding('status')).toBe('0');\n            expect(binding('data')).toBe('Request failed');\n          });\n        </file>\n      </example>\n     */\n    function $http(config) {\n      config.method = uppercase(config.method);\n\n      var reqTransformFn = config.transformRequest || $config.transformRequest,\n          respTransformFn = config.transformResponse || $config.transformResponse,\n          reqHeaders = extend({}, config.headers),\n          defHeaders = extend(\n            {'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN']},\n            $config.headers.common,\n            $config.headers[lowercase(config.method)]\n          ),\n          reqData,\n          defHeaderName, lowercaseDefHeaderName, headerName,\n          promise;\n\n      // using for-in instead of forEach to avoid unecessary iteration after header has been found\n      defaultHeadersIteration:\n      for(defHeaderName in defHeaders) {\n        lowercaseDefHeaderName = lowercase(defHeaderName);\n        for(headerName in config.headers) {\n          if (lowercase(headerName) === lowercaseDefHeaderName) {\n            continue defaultHeadersIteration;\n          }\n        }\n        reqHeaders[defHeaderName] = defHeaders[defHeaderName];\n      }\n\n      // strip content-type if data is undefined\n      if (isUndefined(config.data)) {\n        for(var header in reqHeaders) {\n          if (lowercase(header) === 'content-type') {\n            delete reqHeaders[header];\n            break;\n          }\n        }\n      }\n\n      reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn);\n\n      // send request\n      promise = sendReq(config, reqData, reqHeaders);\n\n\n      // transform future response\n      promise = promise.then(transformResponse, transformResponse);\n\n      // apply interceptors\n      forEach(responseInterceptors, function(interceptor) {\n        promise = interceptor(promise);\n      });\n\n      promise.success = function(fn) {\n        promise.then(function(response) {\n          fn(response.data, response.status, response.headers, config);\n        });\n        return promise;\n      };\n\n      promise.error = function(fn) {\n        promise.then(null, function(response) {\n          fn(response.data, response.status, response.headers, config);\n        });\n        return promise;\n      };\n\n      return promise;\n\n      function transformResponse(response) {\n        // make a copy since the response must be cacheable\n        var resp = extend({}, response, {\n          data: transformData(response.data, response.headers, respTransformFn)\n        });\n        return (isSuccess(response.status))\n          ? resp\n          : $q.reject(resp);\n      }\n    }\n\n    $http.pendingRequests = [];\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#get\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `GET` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#delete\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `DELETE` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#head\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `HEAD` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#jsonp\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `JSONP` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request.\n     *                     Should contain `JSON_CALLBACK` string.\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n    createShortMethods('get', 'delete', 'head', 'jsonp');\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#post\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `POST` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {*} data Request content\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#put\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `PUT` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {*} data Request content\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n    createShortMethodsWithData('post', 'put');\n\n        /**\n         * @ngdoc property\n         * @name ng.$http#defaults\n         * @propertyOf ng.$http\n         *\n         * @description\n         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of\n         * default headers as well as request and response transformations.\n         *\n         * See \"Setting HTTP Headers\" and \"Transforming Requests and Responses\" sections above.\n         */\n    $http.defaults = $config;\n\n\n    return $http;\n\n\n    function createShortMethods(names) {\n      forEach(arguments, function(name) {\n        $http[name] = function(url, config) {\n          return $http(extend(config || {}, {\n            method: name,\n            url: url\n          }));\n        };\n      });\n    }\n\n\n    function createShortMethodsWithData(name) {\n      forEach(arguments, function(name) {\n        $http[name] = function(url, data, config) {\n          return $http(extend(config || {}, {\n            method: name,\n            url: url,\n            data: data\n          }));\n        };\n      });\n    }\n\n\n    /**\n     * Makes the request.\n     *\n     * !!! ACCESSES CLOSURE VARS:\n     * $httpBackend, $config, $log, $rootScope, defaultCache, $http.pendingRequests\n     */\n    function sendReq(config, reqData, reqHeaders) {\n      var deferred = $q.defer(),\n          promise = deferred.promise,\n          cache,\n          cachedResp,\n          url = buildUrl(config.url, config.params);\n\n      $http.pendingRequests.push(config);\n      promise.then(removePendingReq, removePendingReq);\n\n\n      if (config.cache && config.method == 'GET') {\n        cache = isObject(config.cache) ? config.cache : defaultCache;\n      }\n\n      if (cache) {\n        cachedResp = cache.get(url);\n        if (cachedResp) {\n          if (cachedResp.then) {\n            // cached request has already been sent, but there is no response yet\n            cachedResp.then(removePendingReq, removePendingReq);\n            return cachedResp;\n          } else {\n            // serving from cache\n            if (isArray(cachedResp)) {\n              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));\n            } else {\n              resolvePromise(cachedResp, 200, {});\n            }\n          }\n        } else {\n          // put the promise for the non-transformed response into cache as a placeholder\n          cache.put(url, promise);\n        }\n      }\n\n      // if we won't have the response in cache, send the request to the backend\n      if (!cachedResp) {\n        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,\n            config.withCredentials);\n      }\n\n      return promise;\n\n\n      /**\n       * Callback registered to $httpBackend():\n       *  - caches the response if desired\n       *  - resolves the raw $http promise\n       *  - calls $apply\n       */\n      function done(status, response, headersString) {\n        if (cache) {\n          if (isSuccess(status)) {\n            cache.put(url, [status, response, parseHeaders(headersString)]);\n          } else {\n            // remove promise from the cache\n            cache.remove(url);\n          }\n        }\n\n        resolvePromise(response, status, headersString);\n        $rootScope.$apply();\n      }\n\n\n      /**\n       * Resolves the raw $http promise.\n       */\n      function resolvePromise(response, status, headers) {\n        // normalize internal statuses to 0\n        status = Math.max(status, 0);\n\n        (isSuccess(status) ? deferred.resolve : deferred.reject)({\n          data: response,\n          status: status,\n          headers: headersGetter(headers),\n          config: config\n        });\n      }\n\n\n      function removePendingReq() {\n        var idx = indexOf($http.pendingRequests, config);\n        if (idx !== -1) $http.pendingRequests.splice(idx, 1);\n      }\n    }\n\n\n    function buildUrl(url, params) {\n          if (!params) return url;\n          var parts = [];\n          forEachSorted(params, function(value, key) {\n            if (value == null || value == undefined) return;\n            if (isObject(value)) {\n              value = toJson(value);\n            }\n            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n          });\n          return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');\n        }\n\n\n  }];\n}\n\nvar XHR = window.XMLHttpRequest || function() {\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\"); } catch (e1) {}\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\"); } catch (e2) {}\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP\"); } catch (e3) {}\n  throw new Error(\"This browser does not support XMLHttpRequest.\");\n};\n\n\n/**\n * @ngdoc object\n * @name ng.$httpBackend\n * @requires $browser\n * @requires $window\n * @requires $document\n *\n * @description\n * HTTP backend used by the {@link ng.$http service} that delegates to\n * XMLHttpRequest object or JSONP and deals with browser incompatibilities.\n *\n * You should never need to use this service directly, instead use the higher-level abstractions:\n * {@link ng.$http $http} or {@link ngResource.$resource $resource}.\n *\n * During testing this implementation is swapped with {@link ngMock.$httpBackend mock\n * $httpBackend} which can be trained with responses.\n */\nfunction $HttpBackendProvider() {\n  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {\n    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,\n        $document[0], $window.location.protocol.replace(':', ''));\n  }];\n}\n\nfunction createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {\n  // TODO(vojta): fix the signature\n  return function(method, url, post, callback, headers, timeout, withCredentials) {\n    $browser.$$incOutstandingRequestCount();\n    url = url || $browser.url();\n\n    if (lowercase(method) == 'jsonp') {\n      var callbackId = '_' + (callbacks.counter++).toString(36);\n      callbacks[callbackId] = function(data) {\n        callbacks[callbackId].data = data;\n      };\n\n      jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),\n          function() {\n        if (callbacks[callbackId].data) {\n          completeRequest(callback, 200, callbacks[callbackId].data);\n        } else {\n          completeRequest(callback, -2);\n        }\n        delete callbacks[callbackId];\n      });\n    } else {\n      var xhr = new XHR();\n      xhr.open(method, url, true);\n      forEach(headers, function(value, key) {\n        if (value) xhr.setRequestHeader(key, value);\n      });\n\n      var status;\n\n      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the\n      // response is in the cache. the promise api will ensure that to the app code the api is\n      // always async\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState == 4) {\n          var responseHeaders = xhr.getAllResponseHeaders();\n\n          // TODO(vojta): remove once Firefox 21 gets released.\n          // begin: workaround to overcome Firefox CORS http response headers bug\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735\n          // Firefox already patched in nightly. Should land in Firefox 21.\n\n          // CORS \"simple response headers\" http://www.w3.org/TR/cors/\n          var value,\n              simpleHeaders = [\"Cache-Control\", \"Content-Language\", \"Content-Type\",\n                                  \"Expires\", \"Last-Modified\", \"Pragma\"];\n          if (!responseHeaders) {\n            responseHeaders = \"\";\n            forEach(simpleHeaders, function (header) {\n              var value = xhr.getResponseHeader(header);\n              if (value) {\n                  responseHeaders += header + \": \" + value + \"\\n\";\n              }\n            });\n          }\n          // end of the workaround.\n\n          completeRequest(callback, status || xhr.status, xhr.responseText,\n                          responseHeaders);\n        }\n      };\n\n      if (withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      xhr.send(post || '');\n\n      if (timeout > 0) {\n        $browserDefer(function() {\n          status = -1;\n          xhr.abort();\n        }, timeout);\n      }\n    }\n\n\n    function completeRequest(callback, status, response, headersString) {\n      // URL_MATCH is defined in src/service/location.js\n      var protocol = (url.match(URL_MATCH) || ['', locationProtocol])[1];\n\n      // fix status code for file protocol (it's always 0)\n      status = (protocol == 'file') ? (response ? 200 : 404) : status;\n\n      // normalize IE bug (http://bugs.jquery.com/ticket/1450)\n      status = status == 1223 ? 204 : status;\n\n      callback(status, response, headersString);\n      $browser.$$completeOutstandingRequest(noop);\n    }\n  };\n\n  function jsonpReq(url, done) {\n    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:\n    // - fetches local scripts via XHR and evals them\n    // - adds and immediately removes script elements from the document\n    var script = rawDocument.createElement('script'),\n        doneWrapper = function() {\n          rawDocument.body.removeChild(script);\n          if (done) done();\n        };\n\n    script.type = 'text/javascript';\n    script.src = url;\n\n    if (msie) {\n      script.onreadystatechange = function() {\n        if (/loaded|complete/.test(script.readyState)) doneWrapper();\n      };\n    } else {\n      script.onload = script.onerror = doneWrapper;\n    }\n\n    rawDocument.body.appendChild(script);\n  }\n}\n\n/**\n * @ngdoc object\n * @name ng.$locale\n *\n * @description\n * $locale service provides localization rules for various Angular components. As of right now the\n * only public api is:\n *\n * * `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)\n */\nfunction $LocaleProvider(){\n  this.$get = function() {\n    return {\n      id: 'en-us',\n\n      NUMBER_FORMATS: {\n        DECIMAL_SEP: '.',\n        GROUP_SEP: ',',\n        PATTERNS: [\n          { // Decimal Pattern\n            minInt: 1,\n            minFrac: 0,\n            maxFrac: 3,\n            posPre: '',\n            posSuf: '',\n            negPre: '-',\n            negSuf: '',\n            gSize: 3,\n            lgSize: 3\n          },{ //Currency Pattern\n            minInt: 1,\n            minFrac: 2,\n            maxFrac: 2,\n            posPre: '\\u00A4',\n            posSuf: '',\n            negPre: '(\\u00A4',\n            negSuf: ')',\n            gSize: 3,\n            lgSize: 3\n          }\n        ],\n        CURRENCY_SYM: '$'\n      },\n\n      DATETIME_FORMATS: {\n        MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'\n                .split(','),\n        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),\n        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),\n        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),\n        AMPMS: ['AM','PM'],\n        medium: 'MMM d, y h:mm:ss a',\n        short: 'M/d/yy h:mm a',\n        fullDate: 'EEEE, MMMM d, y',\n        longDate: 'MMMM d, y',\n        mediumDate: 'MMM d, y',\n        shortDate: 'M/d/yy',\n        mediumTime: 'h:mm:ss a',\n        shortTime: 'h:mm a'\n      },\n\n      pluralCat: function(num) {\n        if (num === 1) {\n          return 'one';\n        }\n        return 'other';\n      }\n    };\n  };\n}\n\nfunction $TimeoutProvider() {\n  this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',\n       function($rootScope,   $browser,   $q,   $exceptionHandler) {\n    var deferreds = {};\n\n\n     /**\n      * @ngdoc function\n      * @name ng.$timeout\n      * @requires $browser\n      *\n      * @description\n      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch\n      * block and delegates any exceptions to\n      * {@link ng.$exceptionHandler $exceptionHandler} service.\n      *\n      * The return value of registering a timeout function is a promise, which will be resolved when\n      * the timeout is reached and the timeout function is executed.\n      *\n      * To cancel a timeout request, call `$timeout.cancel(promise)`.\n      *\n      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to\n      * synchronously flush the queue of deferred functions.\n      *\n      * @param {function()} fn A function, whose execution should be delayed.\n      * @param {number=} [delay=0] Delay in milliseconds.\n      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise\n      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.\n      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this\n      *   promise will be resolved with is the return value of the `fn` function.\n      */\n    function timeout(fn, delay, invokeApply) {\n      var deferred = $q.defer(),\n          promise = deferred.promise,\n          skipApply = (isDefined(invokeApply) && !invokeApply),\n          timeoutId, cleanup;\n\n      timeoutId = $browser.defer(function() {\n        try {\n          deferred.resolve(fn());\n        } catch(e) {\n          deferred.reject(e);\n          $exceptionHandler(e);\n        }\n        finally {\n          delete deferreds[promise.$$timeoutId];\n        }\n\n        if (!skipApply) $rootScope.$apply();\n      }, delay);\n\n      promise.$$timeoutId = timeoutId;\n      deferreds[timeoutId] = deferred;\n\n      return promise;\n    }\n\n\n     /**\n      * @ngdoc function\n      * @name ng.$timeout#cancel\n      * @methodOf ng.$timeout\n      *\n      * @description\n      * Cancels a task associated with the `promise`. As a result of this, the promise will be\n      * resolved with a rejection.\n      *\n      * @param {Promise=} promise Promise returned by the `$timeout` function.\n      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully\n      *   canceled.\n      */\n    timeout.cancel = function(promise) {\n      if (promise && promise.$$timeoutId in deferreds) {\n        deferreds[promise.$$timeoutId].reject('canceled');\n        delete deferreds[promise.$$timeoutId];\n        return $browser.defer.cancel(promise.$$timeoutId);\n      }\n      return false;\n    };\n\n    return timeout;\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$filterProvider\n * @description\n *\n * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To\n * achieve this a filter definition consists of a factory function which is annotated with dependencies and is\n * responsible for creating a filter function.\n *\n * <pre>\n *   // Filter registration\n *   function MyModule($provide, $filterProvider) {\n *     // create a service to demonstrate injection (not always needed)\n *     $provide.value('greet', function(name){\n *       return 'Hello ' + name + '!';\n *     });\n *\n *     // register a filter factory which uses the\n *     // greet service to demonstrate DI.\n *     $filterProvider.register('greet', function(greet){\n *       // return the filter function which uses the greet service\n *       // to generate salutation\n *       return function(text) {\n *         // filters need to be forgiving so check input validity\n *         return text && greet(text) || text;\n *       };\n *     });\n *   }\n * </pre>\n *\n * The filter function is registered with the `$injector` under the filter name suffixe with `Filter`.\n * <pre>\n *   it('should be the same instance', inject(\n *     function($filterProvider) {\n *       $filterProvider.register('reverse', function(){\n *         return ...;\n *       });\n *     },\n *     function($filter, reverseFilter) {\n *       expect($filter('reverse')).toBe(reverseFilter);\n *     });\n * </pre>\n *\n *\n * For more information about how angular filters work, and how to create your own filters, see\n * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer\n * Guide.\n */\n/**\n * @ngdoc method\n * @name ng.$filterProvider#register\n * @methodOf ng.$filterProvider\n * @description\n * Register filter factory function.\n *\n * @param {String} name Name of the filter.\n * @param {function} fn The filter factory function which is injectable.\n */\n\n\n/**\n * @ngdoc function\n * @name ng.$filter\n * @function\n * @description\n * Filters are used for formatting data displayed to the user.\n *\n * The general syntax in templates is as follows:\n *\n *         {{ expression [| filter_name[:parameter_value] ... ] }}\n *\n * @param {String} name Name of the filter function to retrieve\n * @return {Function} the filter function\n */\n$FilterProvider.$inject = ['$provide'];\nfunction $FilterProvider($provide) {\n  var suffix = 'Filter';\n\n  function register(name, factory) {\n    return $provide.factory(name + suffix, factory);\n  }\n  this.register = register;\n\n  this.$get = ['$injector', function($injector) {\n    return function(name) {\n      return $injector.get(name + suffix);\n    }\n  }];\n\n  ////////////////////////////////////////\n\n  register('currency', currencyFilter);\n  register('date', dateFilter);\n  register('filter', filterFilter);\n  register('json', jsonFilter);\n  register('limitTo', limitToFilter);\n  register('lowercase', lowercaseFilter);\n  register('number', numberFilter);\n  register('orderBy', orderByFilter);\n  register('uppercase', uppercaseFilter);\n}\n\n/**\n * @ngdoc filter\n * @name ng.filter:filter\n * @function\n *\n * @description\n * Selects a subset of items from `array` and returns it as a new array.\n *\n * Note: This function is used to augment the `Array` type in Angular expressions. See\n * {@link ng.$filter} for more information about Angular arrays.\n *\n * @param {Array} array The source array.\n * @param {string|Object|function()} expression The predicate to be used for selecting items from\n *   `array`.\n *\n *   Can be one of:\n *\n *   - `string`: Predicate that results in a substring match using the value of `expression`\n *     string. All strings or objects with string properties in `array` that contain this string\n *     will be returned. The predicate can be negated by prefixing the string with `!`.\n *\n *   - `Object`: A pattern object can be used to filter specific properties on objects contained\n *     by `array`. For example `{name:\"M\", phone:\"1\"}` predicate will return an array of items\n *     which have property `name` containing \"M\" and property `phone` containing \"1\". A special\n *     property name `$` can be used (as in `{$:\"text\"}`) to accept a match against any\n *     property of the object. That's equivalent to the simple substring match with a `string`\n *     as described above.\n *\n *   - `function`: A predicate function can be used to write arbitrary filters. The function is\n *     called for each element of `array`. The final result is an array of those elements that\n *     the predicate returned true for.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <div ng-init=\"friends = [{name:'John', phone:'555-1276'},\n                                {name:'Mary', phone:'800-BIG-MARY'},\n                                {name:'Mike', phone:'555-4321'},\n                                {name:'Adam', phone:'555-5678'},\n                                {name:'Julie', phone:'555-8765'}]\"></div>\n\n       Search: <input ng-model=\"searchText\">\n       <table id=\"searchTextResults\">\n         <tr><th>Name</th><th>Phone</th></tr>\n         <tr ng-repeat=\"friend in friends | filter:searchText\">\n           <td>{{friend.name}}</td>\n           <td>{{friend.phone}}</td>\n         </tr>\n       </table>\n       <hr>\n       Any: <input ng-model=\"search.$\"> <br>\n       Name only <input ng-model=\"search.name\"><br>\n       Phone only <input ng-model=\"search.phone\"><br>\n       <table id=\"searchObjResults\">\n         <tr><th>Name</th><th>Phone</th></tr>\n         <tr ng-repeat=\"friend in friends | filter:search\">\n           <td>{{friend.name}}</td>\n           <td>{{friend.phone}}</td>\n         </tr>\n       </table>\n     </doc:source>\n     <doc:scenario>\n       it('should search across all fields when filtering with a string', function() {\n         input('searchText').enter('m');\n         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\n           toEqual(['Mary', 'Mike', 'Adam']);\n\n         input('searchText').enter('76');\n         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\n           toEqual(['John', 'Julie']);\n       });\n\n       it('should search in specific fields when filtering with a predicate object', function() {\n         input('search.$').enter('i');\n         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).\n           toEqual(['Mary', 'Mike', 'Julie']);\n       });\n     </doc:scenario>\n   </doc:example>\n */\nfunction filterFilter() {\n  return function(array, expression) {\n    if (!isArray(array)) return array;\n    var predicates = [];\n    predicates.check = function(value) {\n      for (var j = 0; j < predicates.length; j++) {\n        if(!predicates[j](value)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    var search = function(obj, text){\n      if (text.charAt(0) === '!') {\n        return !search(obj, text.substr(1));\n      }\n      switch (typeof obj) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          return ('' + obj).toLowerCase().indexOf(text) > -1;\n        case \"object\":\n          for ( var objKey in obj) {\n            if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {\n              return true;\n            }\n          }\n          return false;\n        case \"array\":\n          for ( var i = 0; i < obj.length; i++) {\n            if (search(obj[i], text)) {\n              return true;\n            }\n          }\n          return false;\n        default:\n          return false;\n      }\n    };\n    switch (typeof expression) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        expression = {$:expression};\n      case \"object\":\n        for (var key in expression) {\n          if (key == '$') {\n            (function() {\n              var text = (''+expression[key]).toLowerCase();\n              if (!text) return;\n              predicates.push(function(value) {\n                return search(value, text);\n              });\n            })();\n          } else {\n            (function() {\n              var path = key;\n              var text = (''+expression[key]).toLowerCase();\n              if (!text) return;\n              predicates.push(function(value) {\n                return search(getter(value, path), text);\n              });\n            })();\n          }\n        }\n        break;\n      case 'function':\n        predicates.push(expression);\n        break;\n      default:\n        return array;\n    }\n    var filtered = [];\n    for ( var j = 0; j < array.length; j++) {\n      var value = array[j];\n      if (predicates.check(value)) {\n        filtered.push(value);\n      }\n    }\n    return filtered;\n  }\n}\n\n/**\n * @ngdoc filter\n * @name ng.filter:currency\n * @function\n *\n * @description\n * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default\n * symbol for current locale is used.\n *\n * @param {number} amount Input to filter.\n * @param {string=} symbol Currency symbol or identifier to be displayed.\n * @returns {string} Formatted number.\n *\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.amount = 1234.56;\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <input type=\"number\" ng-model=\"amount\"> <br>\n         default currency symbol ($): {{amount | currency}}<br>\n         custom currency identifier (USD$): {{amount | currency:\"USD$\"}}\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should init with 1234.56', function() {\n         expect(binding('amount | currency')).toBe('$1,234.56');\n         expect(binding('amount | currency:\"USD$\"')).toBe('USD$1,234.56');\n       });\n       it('should update', function() {\n         input('amount').enter('-1234');\n         expect(binding('amount | currency')).toBe('($1,234.00)');\n         expect(binding('amount | currency:\"USD$\"')).toBe('(USD$1,234.00)');\n       });\n     </doc:scenario>\n   </doc:example>\n */\ncurrencyFilter.$inject = ['$locale'];\nfunction currencyFilter($locale) {\n  var formats = $locale.NUMBER_FORMATS;\n  return function(amount, currencySymbol){\n    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;\n    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).\n                replace(/\\u00A4/g, currencySymbol);\n  };\n}\n\n/**\n * @ngdoc filter\n * @name ng.filter:number\n * @function\n *\n * @description\n * Formats a number as text.\n *\n * If the input is not a number an empty string is returned.\n *\n * @param {number|string} number Number to format.\n * @param {(number|string)=} fractionSize Number of decimal places to round the number to.\n * If this is not provided then the fraction size is computed from the current locale's number\n * formatting pattern. In the case of the default locale, it will be 3.\n * @returns {string} Number rounded to decimalPlaces and places a “,” after each third digit.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.val = 1234.56789;\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         Enter number: <input ng-model='val'><br>\n         Default formatting: {{val | number}}<br>\n         No fractions: {{val | number:0}}<br>\n         Negative number: {{-val | number:4}}\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should format numbers', function() {\n         expect(binding('val | number')).toBe('1,234.568');\n         expect(binding('val | number:0')).toBe('1,235');\n         expect(binding('-val | number:4')).toBe('-1,234.5679');\n       });\n\n       it('should update', function() {\n         input('val').enter('3374.333');\n         expect(binding('val | number')).toBe('3,374.333');\n         expect(binding('val | number:0')).toBe('3,374');\n         expect(binding('-val | number:4')).toBe('-3,374.3330');\n       });\n     </doc:scenario>\n   </doc:example>\n */\n\n\nnumberFilter.$inject = ['$locale'];\nfunction numberFilter($locale) {\n  var formats = $locale.NUMBER_FORMATS;\n  return function(number, fractionSize) {\n    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,\n      fractionSize);\n  };\n}\n\nvar DECIMAL_SEP = '.';\nfunction formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {\n  if (isNaN(number) || !isFinite(number)) return '';\n\n  var isNegative = number < 0;\n  number = Math.abs(number);\n  var numStr = number + '',\n      formatedText = '',\n      parts = [];\n\n  var hasExponent = false;\n  if (numStr.indexOf('e') !== -1) {\n    var match = numStr.match(/([\\d\\.]+)e(-?)(\\d+)/);\n    if (match && match[2] == '-' && match[3] > fractionSize + 1) {\n      numStr = '0';\n    } else {\n      formatedText = numStr;\n      hasExponent = true;\n    }\n  }\n\n  if (!hasExponent) {\n    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;\n\n    // determine fractionSize if it is not specified\n    if (isUndefined(fractionSize)) {\n      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);\n    }\n\n    var pow = Math.pow(10, fractionSize);\n    number = Math.round(number * pow) / pow;\n    var fraction = ('' + number).split(DECIMAL_SEP);\n    var whole = fraction[0];\n    fraction = fraction[1] || '';\n\n    var pos = 0,\n        lgroup = pattern.lgSize,\n        group = pattern.gSize;\n\n    if (whole.length >= (lgroup + group)) {\n      pos = whole.length - lgroup;\n      for (var i = 0; i < pos; i++) {\n        if ((pos - i)%group === 0 && i !== 0) {\n          formatedText += groupSep;\n        }\n        formatedText += whole.charAt(i);\n      }\n    }\n\n    for (i = pos; i < whole.length; i++) {\n      if ((whole.length - i)%lgroup === 0 && i !== 0) {\n        formatedText += groupSep;\n      }\n      formatedText += whole.charAt(i);\n    }\n\n    // format fraction part.\n    while(fraction.length < fractionSize) {\n      fraction += '0';\n    }\n\n    if (fractionSize && fractionSize !== \"0\") formatedText += decimalSep + fraction.substr(0, fractionSize);\n  } else {\n\n    if (fractionSize > 0 && number > -1 && number < 1) {\n      formatedText = number.toFixed(fractionSize);\n    }\n  }\n\n  parts.push(isNegative ? pattern.negPre : pattern.posPre);\n  parts.push(formatedText);\n  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);\n  return parts.join('');\n}\n\nfunction padNumber(num, digits, trim) {\n  var neg = '';\n  if (num < 0) {\n    neg =  '-';\n    num = -num;\n  }\n  num = '' + num;\n  while(num.length < digits) num = '0' + num;\n  if (trim)\n    num = num.substr(num.length - digits);\n  return neg + num;\n}\n\n\nfunction dateGetter(name, size, offset, trim) {\n  offset = offset || 0;\n  return function(date) {\n    var value = date['get' + name]();\n    if (offset > 0 || value > -offset)\n      value += offset;\n    if (value === 0 && offset == -12 ) value = 12;\n    return padNumber(value, size, trim);\n  };\n}\n\nfunction dateStrGetter(name, shortForm) {\n  return function(date, formats) {\n    var value = date['get' + name]();\n    var get = uppercase(shortForm ? ('SHORT' + name) : name);\n\n    return formats[get][value];\n  };\n}\n\nfunction timeZoneGetter(date) {\n  var zone = -1 * date.getTimezoneOffset();\n  var paddedZone = (zone >= 0) ? \"+\" : \"\";\n\n  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +\n                padNumber(Math.abs(zone % 60), 2);\n\n  return paddedZone;\n}\n\nfunction ampmGetter(date, formats) {\n  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];\n}\n\nvar DATE_FORMATS = {\n  yyyy: dateGetter('FullYear', 4),\n    yy: dateGetter('FullYear', 2, 0, true),\n     y: dateGetter('FullYear', 1),\n  MMMM: dateStrGetter('Month'),\n   MMM: dateStrGetter('Month', true),\n    MM: dateGetter('Month', 2, 1),\n     M: dateGetter('Month', 1, 1),\n    dd: dateGetter('Date', 2),\n     d: dateGetter('Date', 1),\n    HH: dateGetter('Hours', 2),\n     H: dateGetter('Hours', 1),\n    hh: dateGetter('Hours', 2, -12),\n     h: dateGetter('Hours', 1, -12),\n    mm: dateGetter('Minutes', 2),\n     m: dateGetter('Minutes', 1),\n    ss: dateGetter('Seconds', 2),\n     s: dateGetter('Seconds', 1),\n  EEEE: dateStrGetter('Day'),\n   EEE: dateStrGetter('Day', true),\n     a: ampmGetter,\n     Z: timeZoneGetter\n};\n\nvar DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,\n    NUMBER_STRING = /^\\d+$/;\n\n/**\n * @ngdoc filter\n * @name ng.filter:date\n * @function\n *\n * @description\n *   Formats `date` to a string based on the requested `format`.\n *\n *   `format` string can be composed of the following elements:\n *\n *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)\n *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)\n *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)\n *   * `'MMMM'`: Month in year (January-December)\n *   * `'MMM'`: Month in year (Jan-Dec)\n *   * `'MM'`: Month in year, padded (01-12)\n *   * `'M'`: Month in year (1-12)\n *   * `'dd'`: Day in month, padded (01-31)\n *   * `'d'`: Day in month (1-31)\n *   * `'EEEE'`: Day in Week,(Sunday-Saturday)\n *   * `'EEE'`: Day in Week, (Sun-Sat)\n *   * `'HH'`: Hour in day, padded (00-23)\n *   * `'H'`: Hour in day (0-23)\n *   * `'hh'`: Hour in am/pm, padded (01-12)\n *   * `'h'`: Hour in am/pm, (1-12)\n *   * `'mm'`: Minute in hour, padded (00-59)\n *   * `'m'`: Minute in hour (0-59)\n *   * `'ss'`: Second in minute, padded (00-59)\n *   * `'s'`: Second in minute (0-59)\n *   * `'a'`: am/pm marker\n *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)\n *\n *   `format` string can also be one of the following predefined\n *   {@link guide/i18n localizable formats}:\n *\n *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale\n *     (e.g. Sep 3, 2010 12:05:08 pm)\n *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)\n *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale\n *     (e.g. Friday, September 3, 2010)\n *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)\n *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)\n *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)\n *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)\n *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)\n *\n *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.\n *   `\"h 'in the morning'\"`). In order to output single quote, use two single quotes in a sequence\n *   (e.g. `\"h 'o''clock'\"`).\n *\n * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or\n *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its\n *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is\n *    specified in the string input, the time is considered to be in the local timezone.\n * @param {string=} format Formatting rules (see Description). If not specified,\n *    `mediumDate` is used.\n * @returns {string} Formatted string or the input if input is not recognized as date/millis.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:\n           {{1288323623006 | date:'medium'}}<br>\n       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:\n          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>\n       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:\n          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>\n     </doc:source>\n     <doc:scenario>\n       it('should format date', function() {\n         expect(binding(\"1288323623006 | date:'medium'\")).\n            toMatch(/Oct 2\\d, 2010 \\d{1,2}:\\d{2}:\\d{2} (AM|PM)/);\n         expect(binding(\"1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'\")).\n            toMatch(/2010\\-10\\-2\\d \\d{2}:\\d{2}:\\d{2} (\\-|\\+)?\\d{4}/);\n         expect(binding(\"'1288323623006' | date:'MM/dd/yyyy @ h:mma'\")).\n            toMatch(/10\\/2\\d\\/2010 @ \\d{1,2}:\\d{2}(AM|PM)/);\n       });\n     </doc:scenario>\n   </doc:example>\n */\ndateFilter.$inject = ['$locale'];\nfunction dateFilter($locale) {\n\n\n  var R_ISO8601_STR = /^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;\n  function jsonStringToDate(string){\n    var match;\n    if (match = string.match(R_ISO8601_STR)) {\n      var date = new Date(0),\n          tzHour = 0,\n          tzMin  = 0;\n      if (match[9]) {\n        tzHour = int(match[9] + match[10]);\n        tzMin = int(match[9] + match[11]);\n      }\n      date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));\n      date.setUTCHours(int(match[4]||0) - tzHour, int(match[5]||0) - tzMin, int(match[6]||0), int(match[7]||0));\n      return date;\n    }\n    return string;\n  }\n\n\n  return function(date, format) {\n    var text = '',\n        parts = [],\n        fn, match;\n\n    format = format || 'mediumDate';\n    format = $locale.DATETIME_FORMATS[format] || format;\n    if (isString(date)) {\n      if (NUMBER_STRING.test(date)) {\n        date = int(date);\n      } else {\n        date = jsonStringToDate(date);\n      }\n    }\n\n    if (isNumber(date)) {\n      date = new Date(date);\n    }\n\n    if (!isDate(date)) {\n      return date;\n    }\n\n    while(format) {\n      match = DATE_FORMATS_SPLIT.exec(format);\n      if (match) {\n        parts = concat(parts, match, 1);\n        format = parts.pop();\n      } else {\n        parts.push(format);\n        format = null;\n      }\n    }\n\n    forEach(parts, function(value){\n      fn = DATE_FORMATS[value];\n      text += fn ? fn(date, $locale.DATETIME_FORMATS)\n                 : value.replace(/(^'|'$)/g, '').replace(/''/g, \"'\");\n    });\n\n    return text;\n  };\n}\n\n\n/**\n * @ngdoc filter\n * @name ng.filter:json\n * @function\n *\n * @description\n *   Allows you to convert a JavaScript object into JSON string.\n *\n *   This filter is mostly useful for debugging. When using the double curly {{value}} notation\n *   the binding is automatically converted to JSON.\n *\n * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.\n * @returns {string} JSON string.\n *\n *\n * @example:\n   <doc:example>\n     <doc:source>\n       <pre>{{ {'name':'value'} | json }}</pre>\n     </doc:source>\n     <doc:scenario>\n       it('should jsonify filtered objects', function() {\n         expect(binding(\"{'name':'value'}\")).toMatch(/\\{\\n  \"name\": ?\"value\"\\n}/);\n       });\n     </doc:scenario>\n   </doc:example>\n *\n */\nfunction jsonFilter() {\n  return function(object) {\n    return toJson(object, true);\n  };\n}\n\n\n/**\n * @ngdoc filter\n * @name ng.filter:lowercase\n * @function\n * @description\n * Converts string to lowercase.\n * @see angular.lowercase\n */\nvar lowercaseFilter = valueFn(lowercase);\n\n\n/**\n * @ngdoc filter\n * @name ng.filter:uppercase\n * @function\n * @description\n * Converts string to uppercase.\n * @see angular.uppercase\n */\nvar uppercaseFilter = valueFn(uppercase);\n\n/**\n * @ngdoc function\n * @name ng.filter:limitTo\n * @function\n *\n * @description\n * Creates a new array containing only a specified number of elements in an array. The elements\n * are taken from either the beginning or the end of the source array, as specified by the\n * value and sign (positive or negative) of `limit`.\n *\n * Note: This function is used to augment the `Array` type in Angular expressions. See\n * {@link ng.$filter} for more information about Angular arrays.\n *\n * @param {Array} array Source array to be limited.\n * @param {string|Number} limit The length of the returned array. If the `limit` number is\n *     positive, `limit` number of items from the beginning of the source array are copied.\n *     If the number is negative, `limit` number  of items from the end of the source array are\n *     copied. The `limit` will be trimmed if it exceeds `array.length`\n * @returns {Array} A new sub-array of length `limit` or less if input array had less than `limit`\n *     elements.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.numbers = [1,2,3,4,5,6,7,8,9];\n           $scope.limit = 3;\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         Limit {{numbers}} to: <input type=\"integer\" ng-model=\"limit\">\n         <p>Output: {{ numbers | limitTo:limit }}</p>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should limit the numer array to first three items', function() {\n         expect(element('.doc-example-live input[ng-model=limit]').val()).toBe('3');\n         expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3]');\n       });\n\n       it('should update the output when -3 is entered', function() {\n         input('limit').enter(-3);\n         expect(binding('numbers | limitTo:limit')).toEqual('[7,8,9]');\n       });\n\n       it('should not exceed the maximum size of input array', function() {\n         input('limit').enter(100);\n         expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3,4,5,6,7,8,9]');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nfunction limitToFilter(){\n  return function(array, limit) {\n    if (!(array instanceof Array)) return array;\n    limit = int(limit);\n    var out = [],\n      i, n;\n\n    // check that array is iterable\n    if (!array || !(array instanceof Array))\n      return out;\n\n    // if abs(limit) exceeds maximum length, trim it\n    if (limit > array.length)\n      limit = array.length;\n    else if (limit < -array.length)\n      limit = -array.length;\n\n    if (limit > 0) {\n      i = 0;\n      n = limit;\n    } else {\n      i = array.length + limit;\n      n = array.length;\n    }\n\n    for (; i<n; i++) {\n      out.push(array[i]);\n    }\n\n    return out;\n  }\n}\n\n/**\n * @ngdoc function\n * @name ng.filter:orderBy\n * @function\n *\n * @description\n * Orders a specified `array` by the `expression` predicate.\n *\n * Note: this function is used to augment the `Array` type in Angular expressions. See\n * {@link ng.$filter} for more informaton about Angular arrays.\n *\n * @param {Array} array The array to sort.\n * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be\n *    used by the comparator to determine the order of elements.\n *\n *    Can be one of:\n *\n *    - `function`: Getter function. The result of this function will be sorted using the\n *      `<`, `=`, `>` operator.\n *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'\n *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control\n *      ascending or descending sort order (for example, +name or -name).\n *    - `Array`: An array of function or string predicates. The first predicate in the array\n *      is used for sorting, but when two items are equivalent, the next predicate is used.\n *\n * @param {boolean=} reverse Reverse the order the array.\n * @returns {Array} Sorted copy of the source array.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.friends =\n               [{name:'John', phone:'555-1212', age:10},\n                {name:'Mary', phone:'555-9876', age:19},\n                {name:'Mike', phone:'555-4321', age:21},\n                {name:'Adam', phone:'555-5678', age:35},\n                {name:'Julie', phone:'555-8765', age:29}]\n           $scope.predicate = '-age';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>\n         <hr/>\n         [ <a href=\"\" ng-click=\"predicate=''\">unsorted</a> ]\n         <table class=\"friend\">\n           <tr>\n             <th><a href=\"\" ng-click=\"predicate = 'name'; reverse=false\">Name</a>\n                 (<a href ng-click=\"predicate = '-name'; reverse=false\">^</a>)</th>\n             <th><a href=\"\" ng-click=\"predicate = 'phone'; reverse=!reverse\">Phone Number</a></th>\n             <th><a href=\"\" ng-click=\"predicate = 'age'; reverse=!reverse\">Age</a></th>\n           </tr>\n           <tr ng-repeat=\"friend in friends | orderBy:predicate:reverse\">\n             <td>{{friend.name}}</td>\n             <td>{{friend.phone}}</td>\n             <td>{{friend.age}}</td>\n           </tr>\n         </table>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should be reverse ordered by aged', function() {\n         expect(binding('predicate')).toBe('-age');\n         expect(repeater('table.friend', 'friend in friends').column('friend.age')).\n           toEqual(['35', '29', '21', '19', '10']);\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);\n       });\n\n       it('should reorder the table when user selects different predicate', function() {\n         element('.doc-example-live a:contains(\"Name\")').click();\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);\n         expect(repeater('table.friend', 'friend in friends').column('friend.age')).\n           toEqual(['35', '10', '29', '19', '21']);\n\n         element('.doc-example-live a:contains(\"Phone\")').click();\n         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).\n           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);\n       });\n     </doc:scenario>\n   </doc:example>\n */\norderByFilter.$inject = ['$parse'];\nfunction orderByFilter($parse){\n  return function(array, sortPredicate, reverseOrder) {\n    if (!isArray(array)) return array;\n    if (!sortPredicate) return array;\n    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];\n    sortPredicate = map(sortPredicate, function(predicate){\n      var descending = false, get = predicate || identity;\n      if (isString(predicate)) {\n        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {\n          descending = predicate.charAt(0) == '-';\n          predicate = predicate.substring(1);\n        }\n        get = $parse(predicate);\n      }\n      return reverseComparator(function(a,b){\n        return compare(get(a),get(b));\n      }, descending);\n    });\n    var arrayCopy = [];\n    for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }\n    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));\n\n    function comparator(o1, o2){\n      for ( var i = 0; i < sortPredicate.length; i++) {\n        var comp = sortPredicate[i](o1, o2);\n        if (comp !== 0) return comp;\n      }\n      return 0;\n    }\n    function reverseComparator(comp, descending) {\n      return toBoolean(descending)\n          ? function(a,b){return comp(b,a);}\n          : comp;\n    }\n    function compare(v1, v2){\n      var t1 = typeof v1;\n      var t2 = typeof v2;\n      if (t1 == t2) {\n        if (t1 == \"string\") {\n           v1 = v1.toLowerCase();\n           v2 = v2.toLowerCase();\n        }\n        if (v1 === v2) return 0;\n        return v1 < v2 ? -1 : 1;\n      } else {\n        return t1 < t2 ? -1 : 1;\n      }\n    }\n  }\n}\n\nfunction ngDirective(directive) {\n  if (isFunction(directive)) {\n    directive = {\n      link: directive\n    }\n  }\n  directive.restrict = directive.restrict || 'AC';\n  return valueFn(directive);\n}\n\n/**\n * @ngdoc directive\n * @name ng.directive:a\n * @restrict E\n *\n * @description\n * Modifies the default behavior of html A tag, so that the default action is prevented when href\n * attribute is empty.\n *\n * The reasoning for this change is to allow easy creation of action links with `ngClick` directive\n * without changing the location or causing page reloads, e.g.:\n * `<a href=\"\" ng-click=\"model.$save()\">Save</a>`\n */\nvar htmlAnchorDirective = valueFn({\n  restrict: 'E',\n  compile: function(element, attr) {\n\n    if (msie <= 8) {\n\n      // turn <a href ng-click=\"..\">link</a> into a stylable link in IE\n      // but only if it doesn't have name attribute, in which case it's an anchor\n      if (!attr.href && !attr.name) {\n        attr.$set('href', '');\n      }\n\n      // add a comment node to anchors to workaround IE bug that causes element content to be reset\n      // to new attribute content if attribute is updated with value containing @ and element also\n      // contains value with @\n      // see issue #1949\n      element.append(document.createComment('IE fix'));\n    }\n\n    return function(scope, element) {\n      element.bind('click', function(event){\n        // if we have no href url, then don't navigate anywhere.\n        if (!element.attr('href')) {\n          event.preventDefault();\n        }\n      });\n    }\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngHref\n * @restrict A\n *\n * @description\n * Using Angular markup like {{hash}} in an href attribute makes\n * the page open to a wrong URL, if the user clicks that link before\n * angular has a chance to replace the {{hash}} with actual URL, the\n * link will be broken and will most likely return a 404 error.\n * The `ngHref` directive solves this problem.\n *\n * The buggy way to write it:\n * <pre>\n * <a href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * The correct way to write it:\n * <pre>\n * <a ng-href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * @element A\n * @param {template} ngHref any string which can contain `{{}}` markup.\n *\n * @example\n * This example uses `link` variable inside `href` attribute:\n    <doc:example>\n      <doc:source>\n        <input ng-model=\"value\" /><br />\n        <a id=\"link-1\" href ng-click=\"value = 1\">link 1</a> (link, don't reload)<br />\n        <a id=\"link-2\" href=\"\" ng-click=\"value = 2\">link 2</a> (link, don't reload)<br />\n        <a id=\"link-3\" ng-href=\"/{{'123'}}\">link 3</a> (link, reload!)<br />\n        <a id=\"link-4\" href=\"\" name=\"xx\" ng-click=\"value = 4\">anchor</a> (link, don't reload)<br />\n        <a id=\"link-5\" name=\"xxx\" ng-click=\"value = 5\">anchor</a> (no link)<br />\n        <a id=\"link-6\" ng-href=\"{{value}}\">link</a> (link, change location)\n      </doc:source>\n      <doc:scenario>\n        it('should execute ng-click but not reload when href without value', function() {\n          element('#link-1').click();\n          expect(input('value').val()).toEqual('1');\n          expect(element('#link-1').attr('href')).toBe(\"\");\n        });\n\n        it('should execute ng-click but not reload when href empty string', function() {\n          element('#link-2').click();\n          expect(input('value').val()).toEqual('2');\n          expect(element('#link-2').attr('href')).toBe(\"\");\n        });\n\n        it('should execute ng-click and change url when ng-href specified', function() {\n          expect(element('#link-3').attr('href')).toBe(\"/123\");\n\n          element('#link-3').click();\n          expect(browser().window().path()).toEqual('/123');\n        });\n\n        it('should execute ng-click but not reload when href empty string and name specified', function() {\n          element('#link-4').click();\n          expect(input('value').val()).toEqual('4');\n          expect(element('#link-4').attr('href')).toBe('');\n        });\n\n        it('should execute ng-click but not reload when no href but name specified', function() {\n          element('#link-5').click();\n          expect(input('value').val()).toEqual('5');\n          expect(element('#link-5').attr('href')).toBe(undefined);\n        });\n\n        it('should only change url when only ng-href', function() {\n          input('value').enter('6');\n          expect(element('#link-6').attr('href')).toBe('6');\n\n          element('#link-6').click();\n          expect(browser().location().url()).toEqual('/6');\n        });\n      </doc:scenario>\n    </doc:example>\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSrc\n * @restrict A\n *\n * @description\n * Using Angular markup like `{{hash}}` in a `src` attribute doesn't\n * work right: The browser will fetch from the URL with the literal\n * text `{{hash}}` until Angular replaces the expression inside\n * `{{hash}}`. The `ngSrc` directive solves this problem.\n *\n * The buggy way to write it:\n * <pre>\n * <img src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * The correct way to write it:\n * <pre>\n * <img ng-src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * @element IMG\n * @param {template} ngSrc any string which can contain `{{}}` markup.\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngDisabled\n * @restrict A\n *\n * @description\n *\n * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:\n * <pre>\n * <div ng-init=\"scope = { isDisabled: false }\">\n *  <button disabled=\"{{scope.isDisabled}}\">Disabled</button>\n * </div>\n * </pre>\n *\n * The HTML specs do not require browsers to preserve the special attributes such as disabled.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngDisabled` directive.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        Click me to toggle: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n        <button ng-model=\"button\" ng-disabled=\"checked\">Button</button>\n      </doc:source>\n      <doc:scenario>\n        it('should toggle button', function() {\n          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();\n          input('checked').check();\n          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element INPUT\n * @param {expression} ngDisabled Angular expression that will be evaluated.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngChecked\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as checked.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngChecked` directive.\n * @example\n    <doc:example>\n      <doc:source>\n        Check me to check both: <input type=\"checkbox\" ng-model=\"master\"><br/>\n        <input id=\"checkSlave\" type=\"checkbox\" ng-checked=\"master\">\n      </doc:source>\n      <doc:scenario>\n        it('should check both checkBoxes', function() {\n          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();\n          input('master').check();\n          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element INPUT\n * @param {expression} ngChecked Angular expression that will be evaluated.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMultiple\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as multiple.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngMultiple` directive.\n *\n * @example\n     <doc:example>\n       <doc:source>\n         Check me check multiple: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n         <select id=\"select\" ng-multiple=\"checked\">\n           <option>Misko</option>\n           <option>Igor</option>\n           <option>Vojta</option>\n           <option>Di</option>\n         </select>\n       </doc:source>\n       <doc:scenario>\n         it('should toggle multiple', function() {\n           expect(element('.doc-example-live #select').prop('multiple')).toBeFalsy();\n           input('checked').check();\n           expect(element('.doc-example-live #select').prop('multiple')).toBeTruthy();\n         });\n       </doc:scenario>\n     </doc:example>\n *\n * @element SELECT\n * @param {expression} ngMultiple Angular expression that will be evaluated.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngReadonly\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as readonly.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngReadonly` directive.\n * @example\n    <doc:example>\n      <doc:source>\n        Check me to make text readonly: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n        <input type=\"text\" ng-readonly=\"checked\" value=\"I'm Angular\"/>\n      </doc:source>\n      <doc:scenario>\n        it('should toggle readonly attr', function() {\n          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();\n          input('checked').check();\n          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element INPUT\n * @param {string} expression Angular expression that will be evaluated.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSelected\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as selected.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduced the `ngSelected` directive.\n * @example\n    <doc:example>\n      <doc:source>\n        Check me to select: <input type=\"checkbox\" ng-model=\"selected\"><br/>\n        <select>\n          <option>Hello!</option>\n          <option id=\"greet\" ng-selected=\"selected\">Greetings!</option>\n        </select>\n      </doc:source>\n      <doc:scenario>\n        it('should select Greetings!', function() {\n          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();\n          input('selected').check();\n          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element OPTION\n * @param {string} expression Angular expression that will be evaluated.\n */\n\n\nvar ngAttributeAliasDirectives = {};\n\n\n// boolean attrs are evaluated\nforEach(BOOLEAN_ATTR, function(propName, attrName) {\n  var normalized = directiveNormalize('ng-' + attrName);\n  ngAttributeAliasDirectives[normalized] = function() {\n    return {\n      priority: 100,\n      compile: function() {\n        return function(scope, element, attr) {\n          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {\n            attr.$set(attrName, !!value);\n          });\n        };\n      }\n    };\n  };\n});\n\n\n// ng-src, ng-href are interpolated\nforEach(['src', 'href'], function(attrName) {\n  var normalized = directiveNormalize('ng-' + attrName);\n  ngAttributeAliasDirectives[normalized] = function() {\n    return {\n      priority: 99, // it needs to run after the attributes are interpolated\n      link: function(scope, element, attr) {\n        attr.$observe(normalized, function(value) {\n          if (!value)\n             return;\n\n          attr.$set(attrName, value);\n\n          // on IE, if \"ng:src\" directive declaration is used and \"src\" attribute doesn't exist\n          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need\n          // to set the property as well to achieve the desired effect.\n          // we use attr[attrName] value since $set can sanitize the url.\n          if (msie) element.prop(attrName, attr[attrName]);\n        });\n      }\n    };\n  };\n});\n\nvar nullFormCtrl = {\n  $addControl: noop,\n  $removeControl: noop,\n  $setValidity: noop,\n  $setDirty: noop\n};\n\n/**\n * @ngdoc object\n * @name ng.directive:form.FormController\n *\n * @property {boolean} $pristine True if user has not interacted with the form yet.\n * @property {boolean} $dirty True if user has already interacted with the form.\n * @property {boolean} $valid True if all of the containing forms and controls are valid.\n * @property {boolean} $invalid True if at least one containing control or form is invalid.\n *\n * @property {Object} $error Is an object hash, containing references to all invalid controls or\n *  forms, where:\n *\n *  - keys are validation tokens (error names) — such as `required`, `url` or `email`),\n *  - values are arrays of controls or forms that are invalid with given error.\n *\n * @description\n * `FormController` keeps track of all its controls and nested forms as well as state of them,\n * such as being valid/invalid or dirty/pristine.\n *\n * Each {@link ng.directive:form form} directive creates an instance\n * of `FormController`.\n *\n */\n//asks for $scope to fool the BC controller module\nFormController.$inject = ['$element', '$attrs', '$scope'];\nfunction FormController(element, attrs) {\n  var form = this,\n      parentForm = element.parent().controller('form') || nullFormCtrl,\n      invalidCount = 0, // used to easily determine if we are valid\n      errors = form.$error = {};\n\n  // init state\n  form.$name = attrs.name || attrs.ngForm;\n  form.$dirty = false;\n  form.$pristine = true;\n  form.$valid = true;\n  form.$invalid = false;\n\n  parentForm.$addControl(form);\n\n  // Setup initial state of the control\n  element.addClass(PRISTINE_CLASS);\n  toggleValidCss(true);\n\n  // convenience method for easy toggling of classes\n  function toggleValidCss(isValid, validationErrorKey) {\n    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';\n    element.\n      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).\n      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);\n  }\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$addControl\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Register a control with the form.\n   *\n   * Input elements using ngModelController do this automatically when they are linked.\n   */\n  form.$addControl = function(control) {\n    if (control.$name && !form.hasOwnProperty(control.$name)) {\n      form[control.$name] = control;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$removeControl\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Deregister a control from the form.\n   *\n   * Input elements using ngModelController do this automatically when they are destroyed.\n   */\n  form.$removeControl = function(control) {\n    if (control.$name && form[control.$name] === control) {\n      delete form[control.$name];\n    }\n    forEach(errors, function(queue, validationToken) {\n      form.$setValidity(validationToken, true, control);\n    });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$setValidity\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Sets the validity of a form control.\n   *\n   * This method will also propagate to parent forms.\n   */\n  form.$setValidity = function(validationToken, isValid, control) {\n    var queue = errors[validationToken];\n\n    if (isValid) {\n      if (queue) {\n        arrayRemove(queue, control);\n        if (!queue.length) {\n          invalidCount--;\n          if (!invalidCount) {\n            toggleValidCss(isValid);\n            form.$valid = true;\n            form.$invalid = false;\n          }\n          errors[validationToken] = false;\n          toggleValidCss(true, validationToken);\n          parentForm.$setValidity(validationToken, true, form);\n        }\n      }\n\n    } else {\n      if (!invalidCount) {\n        toggleValidCss(isValid);\n      }\n      if (queue) {\n        if (includes(queue, control)) return;\n      } else {\n        errors[validationToken] = queue = [];\n        invalidCount++;\n        toggleValidCss(false, validationToken);\n        parentForm.$setValidity(validationToken, false, form);\n      }\n      queue.push(control);\n\n      form.$valid = false;\n      form.$invalid = true;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$setDirty\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Sets the form to a dirty state.\n   *\n   * This method can be called to add the 'ng-dirty' class and set the form to a dirty\n   * state (ng-dirty class). This method will also propagate to parent forms.\n   */\n  form.$setDirty = function() {\n    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);\n    form.$dirty = true;\n    form.$pristine = false;\n    parentForm.$setDirty();\n  };\n\n}\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngForm\n * @restrict EAC\n *\n * @description\n * Nestable alias of {@link ng.directive:form `form`} directive. HTML\n * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a\n * sub-group of controls needs to be determined.\n *\n * @param {string=} name|ngForm Name of the form. If specified, the form controller will be published into\n *                       related scope, under this name.\n *\n */\n\n /**\n * @ngdoc directive\n * @name ng.directive:form\n * @restrict E\n *\n * @description\n * Directive that instantiates\n * {@link ng.directive:form.FormController FormController}.\n *\n * If `name` attribute is specified, the form controller is published onto the current scope under\n * this name.\n *\n * # Alias: {@link ng.directive:ngForm `ngForm`}\n *\n * In angular forms can be nested. This means that the outer form is valid when all of the child\n * forms are valid as well. However browsers do not allow nesting of `<form>` elements, for this\n * reason angular provides {@link ng.directive:ngForm `ngForm`} alias\n * which behaves identical to `<form>` but allows form nesting.\n *\n *\n * # CSS classes\n *  - `ng-valid` Is set if the form is valid.\n *  - `ng-invalid` Is set if the form is invalid.\n *  - `ng-pristine` Is set if the form is pristine.\n *  - `ng-dirty` Is set if the form is dirty.\n *\n *\n * # Submitting a form and preventing default action\n *\n * Since the role of forms in client-side Angular applications is different than in classical\n * roundtrip apps, it is desirable for the browser not to translate the form submission into a full\n * page reload that sends the data to the server. Instead some javascript logic should be triggered\n * to handle the form submission in application specific way.\n *\n * For this reason, Angular prevents the default action (form submission to the server) unless the\n * `<form>` element has an `action` attribute specified.\n *\n * You can use one of the following two ways to specify what javascript method should be called when\n * a form is submitted:\n *\n * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element\n * - {@link ng.directive:ngClick ngClick} directive on the first\n  *  button or input field of type submit (input[type=submit])\n *\n * To prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This\n * is because of the following form submission rules coming from the html spec:\n *\n * - If a form has only one input field then hitting enter in this field triggers form submit\n * (`ngSubmit`)\n * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter\n * doesn't trigger submit\n * - if a form has one or more input fields and one or more buttons or input[type=submit] then\n * hitting enter in any of the input fields will trigger the click handler on the *first* button or\n * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)\n *\n * @param {string=} name Name of the form. If specified, the form controller will be published into\n *                       related scope, under this name.\n *\n * @example\n    <doc:example>\n      <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.userType = 'guest';\n         }\n       </script>\n       <form name=\"myForm\" ng-controller=\"Ctrl\">\n         userType: <input name=\"input\" ng-model=\"userType\" required>\n         <span class=\"error\" ng-show=\"myForm.input.$error.required\">Required!</span><br>\n         <tt>userType = {{userType}}</tt><br>\n         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>\n         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\n        </form>\n      </doc:source>\n      <doc:scenario>\n        it('should initialize to model', function() {\n         expect(binding('userType')).toEqual('guest');\n         expect(binding('myForm.input.$valid')).toEqual('true');\n        });\n\n        it('should be invalid if empty', function() {\n         input('userType').enter('');\n         expect(binding('userType')).toEqual('');\n         expect(binding('myForm.input.$valid')).toEqual('false');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar formDirectiveFactory = function(isNgForm) {\n  return ['$timeout', function($timeout) {\n    var formDirective = {\n      name: 'form',\n      restrict: 'E',\n      controller: FormController,\n      compile: function() {\n        return {\n          pre: function(scope, formElement, attr, controller) {\n            if (!attr.action) {\n              // we can't use jq events because if a form is destroyed during submission the default\n              // action is not prevented. see #1238\n              //\n              // IE 9 is not affected because it doesn't fire a submit event and try to do a full\n              // page reload if the form was destroyed by submission of the form via a click handler\n              // on a button in the form. Looks like an IE9 specific bug.\n              var preventDefaultListener = function(event) {\n                event.preventDefault\n                  ? event.preventDefault()\n                  : event.returnValue = false; // IE\n              };\n\n              addEventListenerFn(formElement[0], 'submit', preventDefaultListener);\n\n              // unregister the preventDefault listener so that we don't not leak memory but in a\n              // way that will achieve the prevention of the default action.\n              formElement.bind('$destroy', function() {\n                $timeout(function() {\n                  removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);\n                }, 0, false);\n              });\n            }\n\n            var parentFormCtrl = formElement.parent().controller('form'),\n                alias = attr.name || attr.ngForm;\n\n            if (alias) {\n              scope[alias] = controller;\n            }\n            if (parentFormCtrl) {\n              formElement.bind('$destroy', function() {\n                parentFormCtrl.$removeControl(controller);\n                if (alias) {\n                  scope[alias] = undefined;\n                }\n                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards\n              });\n            }\n          }\n        };\n      }\n    };\n\n    return isNgForm ? extend(copy(formDirective), {restrict: 'EAC'}) : formDirective;\n  }];\n};\n\nvar formDirective = formDirectiveFactory();\nvar ngFormDirective = formDirectiveFactory(true);\n\nvar URL_REGEXP = /^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/;\nvar EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$/;\nvar NUMBER_REGEXP = /^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$/;\n\nvar inputType = {\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.text\n   *\n   * @description\n   * Standard HTML text input with angular data binding.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} required Adds `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.text = 'guest';\n             $scope.word = /^\\w*$/;\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           Single word: <input type=\"text\" name=\"input\" ng-model=\"text\"\n                               ng-pattern=\"word\" required>\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n             Required!</span>\n           <span class=\"error\" ng-show=\"myForm.input.$error.pattern\">\n             Single word only!</span>\n\n           <tt>text = {{text}}</tt><br/>\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n            expect(binding('text')).toEqual('guest');\n            expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n            input('text').enter('');\n            expect(binding('text')).toEqual('');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if multi word', function() {\n            input('text').enter('hello world');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'text': textInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.number\n   *\n   * @description\n   * Text input with number validation and transformation. Sets the `number` validation\n   * error if not a valid number.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.\n   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.value = 12;\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           Number: <input type=\"number\" name=\"input\" ng-model=\"value\"\n                          min=\"0\" max=\"99\" required>\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n             Required!</span>\n           <span class=\"error\" ng-show=\"myForm.input.$error.number\">\n             Not valid number!</span>\n           <tt>value = {{value}}</tt><br/>\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n           expect(binding('value')).toEqual('12');\n           expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n           input('value').enter('');\n           expect(binding('value')).toEqual('');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if over max', function() {\n           input('value').enter('123');\n           expect(binding('value')).toEqual('');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'number': numberInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.url\n   *\n   * @description\n   * Text input with URL validation. Sets the `url` validation error key if the content is not a\n   * valid URL.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.text = 'http://google.com';\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           URL: <input type=\"url\" name=\"input\" ng-model=\"text\" required>\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n             Required!</span>\n           <span class=\"error\" ng-show=\"myForm.input.$error.url\">\n             Not valid url!</span>\n           <tt>text = {{text}}</tt><br/>\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n            expect(binding('text')).toEqual('http://google.com');\n            expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n            input('text').enter('');\n            expect(binding('text')).toEqual('');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if not url', function() {\n            input('text').enter('xxx');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'url': urlInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.email\n   *\n   * @description\n   * Text input with email validation. Sets the `email` validation error key if not a valid email\n   * address.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.text = 'me@example.com';\n           }\n         </script>\n           <form name=\"myForm\" ng-controller=\"Ctrl\">\n             Email: <input type=\"email\" name=\"input\" ng-model=\"text\" required>\n             <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n               Required!</span>\n             <span class=\"error\" ng-show=\"myForm.input.$error.email\">\n               Not valid email!</span>\n             <tt>text = {{text}}</tt><br/>\n             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>\n           </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n            expect(binding('text')).toEqual('me@example.com');\n            expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n            input('text').enter('');\n            expect(binding('text')).toEqual('');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if not email', function() {\n            input('text').enter('xxx');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'email': emailInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.radio\n   *\n   * @description\n   * HTML radio button.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string} value The value to which the expression should be set when selected.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.color = 'blue';\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           <input type=\"radio\" ng-model=\"color\" value=\"red\">  Red <br/>\n           <input type=\"radio\" ng-model=\"color\" value=\"green\"> Green <br/>\n           <input type=\"radio\" ng-model=\"color\" value=\"blue\"> Blue <br/>\n           <tt>color = {{color}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should change state', function() {\n            expect(binding('color')).toEqual('blue');\n\n            input('color').select('red');\n            expect(binding('color')).toEqual('red');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'radio': radioInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.checkbox\n   *\n   * @description\n   * HTML checkbox.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} ngTrueValue The value to which the expression should be set when selected.\n   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.value1 = true;\n             $scope.value2 = 'YES'\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           Value1: <input type=\"checkbox\" ng-model=\"value1\"> <br/>\n           Value2: <input type=\"checkbox\" ng-model=\"value2\"\n                          ng-true-value=\"YES\" ng-false-value=\"NO\"> <br/>\n           <tt>value1 = {{value1}}</tt><br/>\n           <tt>value2 = {{value2}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should change state', function() {\n            expect(binding('value1')).toEqual('true');\n            expect(binding('value2')).toEqual('YES');\n\n            input('value1').check();\n            input('value2').check();\n            expect(binding('value1')).toEqual('false');\n            expect(binding('value2')).toEqual('NO');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'checkbox': checkboxInputType,\n\n  'hidden': noop,\n  'button': noop,\n  'submit': noop,\n  'reset': noop\n};\n\n\nfunction isEmpty(value) {\n  return isUndefined(value) || value === '' || value === null || value !== value;\n}\n\n\nfunction textInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n\n  var listener = function() {\n    var value = trim(element.val());\n\n    if (ctrl.$viewValue !== value) {\n      scope.$apply(function() {\n        ctrl.$setViewValue(value);\n      });\n    }\n  };\n\n  // if the browser does support \"input\" event, we are fine - except on IE9 which doesn't fire the\n  // input event on backspace, delete or cut\n  if ($sniffer.hasEvent('input')) {\n    element.bind('input', listener);\n  } else {\n    var timeout;\n\n    var deferListener = function() {\n      if (!timeout) {\n        timeout = $browser.defer(function() {\n          listener();\n          timeout = null;\n        });\n      }\n    };\n\n    element.bind('keydown', function(event) {\n      var key = event.keyCode;\n\n      // ignore\n      //    command            modifiers                   arrows\n      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;\n\n      deferListener();\n    });\n\n    // if user paste into input using mouse, we need \"change\" event to catch it\n    element.bind('change', listener);\n\n    // if user modifies input value using context menu in IE, we need \"paste\" and \"cut\" events to catch it\n    if ($sniffer.hasEvent('paste')) {\n      element.bind('paste cut', deferListener);\n    }\n  }\n\n\n  ctrl.$render = function() {\n    element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);\n  };\n\n  // pattern validator\n  var pattern = attr.ngPattern,\n      patternValidator;\n\n  var validate = function(regexp, value) {\n    if (isEmpty(value) || regexp.test(value)) {\n      ctrl.$setValidity('pattern', true);\n      return value;\n    } else {\n      ctrl.$setValidity('pattern', false);\n      return undefined;\n    }\n  };\n\n  if (pattern) {\n    if (pattern.match(/^\\/(.*)\\/$/)) {\n      pattern = new RegExp(pattern.substr(1, pattern.length - 2));\n      patternValidator = function(value) {\n        return validate(pattern, value)\n      };\n    } else {\n      patternValidator = function(value) {\n        var patternObj = scope.$eval(pattern);\n\n        if (!patternObj || !patternObj.test) {\n          throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);\n        }\n        return validate(patternObj, value);\n      };\n    }\n\n    ctrl.$formatters.push(patternValidator);\n    ctrl.$parsers.push(patternValidator);\n  }\n\n  // min length validator\n  if (attr.ngMinlength) {\n    var minlength = int(attr.ngMinlength);\n    var minLengthValidator = function(value) {\n      if (!isEmpty(value) && value.length < minlength) {\n        ctrl.$setValidity('minlength', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('minlength', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(minLengthValidator);\n    ctrl.$formatters.push(minLengthValidator);\n  }\n\n  // max length validator\n  if (attr.ngMaxlength) {\n    var maxlength = int(attr.ngMaxlength);\n    var maxLengthValidator = function(value) {\n      if (!isEmpty(value) && value.length > maxlength) {\n        ctrl.$setValidity('maxlength', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('maxlength', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(maxLengthValidator);\n    ctrl.$formatters.push(maxLengthValidator);\n  }\n}\n\nfunction numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\n\n  ctrl.$parsers.push(function(value) {\n    var empty = isEmpty(value);\n    if (empty || NUMBER_REGEXP.test(value)) {\n      ctrl.$setValidity('number', true);\n      return value === '' ? null : (empty ? value : parseFloat(value));\n    } else {\n      ctrl.$setValidity('number', false);\n      return undefined;\n    }\n  });\n\n  ctrl.$formatters.push(function(value) {\n    return isEmpty(value) ? '' : '' + value;\n  });\n\n  if (attr.min) {\n    var min = parseFloat(attr.min);\n    var minValidator = function(value) {\n      if (!isEmpty(value) && value < min) {\n        ctrl.$setValidity('min', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('min', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(minValidator);\n    ctrl.$formatters.push(minValidator);\n  }\n\n  if (attr.max) {\n    var max = parseFloat(attr.max);\n    var maxValidator = function(value) {\n      if (!isEmpty(value) && value > max) {\n        ctrl.$setValidity('max', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('max', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(maxValidator);\n    ctrl.$formatters.push(maxValidator);\n  }\n\n  ctrl.$formatters.push(function(value) {\n\n    if (isEmpty(value) || isNumber(value)) {\n      ctrl.$setValidity('number', true);\n      return value;\n    } else {\n      ctrl.$setValidity('number', false);\n      return undefined;\n    }\n  });\n}\n\nfunction urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\n\n  var urlValidator = function(value) {\n    if (isEmpty(value) || URL_REGEXP.test(value)) {\n      ctrl.$setValidity('url', true);\n      return value;\n    } else {\n      ctrl.$setValidity('url', false);\n      return undefined;\n    }\n  };\n\n  ctrl.$formatters.push(urlValidator);\n  ctrl.$parsers.push(urlValidator);\n}\n\nfunction emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\n\n  var emailValidator = function(value) {\n    if (isEmpty(value) || EMAIL_REGEXP.test(value)) {\n      ctrl.$setValidity('email', true);\n      return value;\n    } else {\n      ctrl.$setValidity('email', false);\n      return undefined;\n    }\n  };\n\n  ctrl.$formatters.push(emailValidator);\n  ctrl.$parsers.push(emailValidator);\n}\n\nfunction radioInputType(scope, element, attr, ctrl) {\n  // make the name unique, if not defined\n  if (isUndefined(attr.name)) {\n    element.attr('name', nextUid());\n  }\n\n  element.bind('click', function() {\n    if (element[0].checked) {\n      scope.$apply(function() {\n        ctrl.$setViewValue(attr.value);\n      });\n    }\n  });\n\n  ctrl.$render = function() {\n    var value = attr.value;\n    element[0].checked = (value == ctrl.$viewValue);\n  };\n\n  attr.$observe('value', ctrl.$render);\n}\n\nfunction checkboxInputType(scope, element, attr, ctrl) {\n  var trueValue = attr.ngTrueValue,\n      falseValue = attr.ngFalseValue;\n\n  if (!isString(trueValue)) trueValue = true;\n  if (!isString(falseValue)) falseValue = false;\n\n  element.bind('click', function() {\n    scope.$apply(function() {\n      ctrl.$setViewValue(element[0].checked);\n    });\n  });\n\n  ctrl.$render = function() {\n    element[0].checked = ctrl.$viewValue;\n  };\n\n  ctrl.$formatters.push(function(value) {\n    return value === trueValue;\n  });\n\n  ctrl.$parsers.push(function(value) {\n    return value ? trueValue : falseValue;\n  });\n}\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:textarea\n * @restrict E\n *\n * @description\n * HTML textarea element control with angular data-binding. The data-binding and validation\n * properties of this element are exactly the same as those of the\n * {@link ng.directive:input input element}.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} required Sets `required` validation error key if the value is not entered.\n * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n *    `required` when you want to data-bind to the `required` attribute.\n * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n *    minlength.\n * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n *    maxlength.\n * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n *    patterns defined as scope expressions.\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\n *    interaction with the input element.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:input\n * @restrict E\n *\n * @description\n * HTML input element control with angular data-binding. Input control follows HTML5 input types\n * and polyfills the HTML5 validation behavior for older browsers.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} required Sets `required` validation error key if the value is not entered.\n * @param {boolean=} ngRequired Sets `required` attribute if set to true\n * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n *    minlength.\n * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n *    maxlength.\n * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n *    patterns defined as scope expressions.\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\n *    interaction with the input element.\n *\n * @example\n    <doc:example>\n      <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.user = {name: 'guest', last: 'visitor'};\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <form name=\"myForm\">\n           User name: <input type=\"text\" name=\"userName\" ng-model=\"user.name\" required>\n           <span class=\"error\" ng-show=\"myForm.userName.$error.required\">\n             Required!</span><br>\n           Last name: <input type=\"text\" name=\"lastName\" ng-model=\"user.last\"\n             ng-minlength=\"3\" ng-maxlength=\"10\">\n           <span class=\"error\" ng-show=\"myForm.lastName.$error.minlength\">\n             Too short!</span>\n           <span class=\"error\" ng-show=\"myForm.lastName.$error.maxlength\">\n             Too long!</span><br>\n         </form>\n         <hr>\n         <tt>user = {{user}}</tt><br/>\n         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>\n         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>\n         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>\n         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\n         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>\n         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>\n       </div>\n      </doc:source>\n      <doc:scenario>\n        it('should initialize to model', function() {\n          expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"visitor\"}');\n          expect(binding('myForm.userName.$valid')).toEqual('true');\n          expect(binding('myForm.$valid')).toEqual('true');\n        });\n\n        it('should be invalid if empty when required', function() {\n          input('user.name').enter('');\n          expect(binding('user')).toEqual('{\"last\":\"visitor\"}');\n          expect(binding('myForm.userName.$valid')).toEqual('false');\n          expect(binding('myForm.$valid')).toEqual('false');\n        });\n\n        it('should be valid if empty when min length is set', function() {\n          input('user.last').enter('');\n          expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"\"}');\n          expect(binding('myForm.lastName.$valid')).toEqual('true');\n          expect(binding('myForm.$valid')).toEqual('true');\n        });\n\n        it('should be invalid if less than required min length', function() {\n          input('user.last').enter('xx');\n          expect(binding('user')).toEqual('{\"name\":\"guest\"}');\n          expect(binding('myForm.lastName.$valid')).toEqual('false');\n          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);\n          expect(binding('myForm.$valid')).toEqual('false');\n        });\n\n        it('should be invalid if longer than max length', function() {\n          input('user.last').enter('some ridiculously long name');\n          expect(binding('user'))\n            .toEqual('{\"name\":\"guest\"}');\n          expect(binding('myForm.lastName.$valid')).toEqual('false');\n          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);\n          expect(binding('myForm.$valid')).toEqual('false');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {\n  return {\n    restrict: 'E',\n    require: '?ngModel',\n    link: function(scope, element, attr, ctrl) {\n      if (ctrl) {\n        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,\n                                                            $browser);\n      }\n    }\n  };\n}];\n\nvar VALID_CLASS = 'ng-valid',\n    INVALID_CLASS = 'ng-invalid',\n    PRISTINE_CLASS = 'ng-pristine',\n    DIRTY_CLASS = 'ng-dirty';\n\n/**\n * @ngdoc object\n * @name ng.directive:ngModel.NgModelController\n *\n * @property {string} $viewValue Actual string value in the view.\n * @property {*} $modelValue The value in the model, that the control is bound to.\n * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever\n       the control reads value from the DOM.  Each function is called, in turn, passing the value\n       through to the next. Used to sanitize / convert the value as well as validation.\n\n       For validation, the parsers should update the validity state using\n       {@link ng.directive:ngModel.NgModelController#$setValidity $setValidity()},\n       and return `undefined` for invalid values.\n *\n * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever\n *     the model value changes. Each function is called, in turn, passing the value through to the\n *     next. Used to format / convert values for display in the control and validation.\n *      <pre>\n *      function formatter(value) {\n *        if (value) {\n *          return value.toUpperCase();\n *        }\n *      }\n *      ngModel.$formatters.push(formatter);\n *      </pre>\n * @property {Object} $error An bject hash with all errors as keys.\n *\n * @property {boolean} $pristine True if user has not interacted with the control yet.\n * @property {boolean} $dirty True if user has already interacted with the control.\n * @property {boolean} $valid True if there is no error.\n * @property {boolean} $invalid True if at least one error on the control.\n *\n * @description\n *\n * `NgModelController` provides API for the `ng-model` directive. The controller contains\n * services for data-binding, validation, CSS update, value formatting and parsing. It\n * specifically does not contain any logic which deals with DOM rendering or listening to\n * DOM events. The `NgModelController` is meant to be extended by other directives where, the\n * directive provides DOM manipulation and the `NgModelController` provides the data-binding.\n * Note that you cannot use `NgModelController` in a directive with an isolated scope,\n * as, in that case, the `ng-model` value gets put into the isolated scope and does not get\n * propogated to the parent scope.\n *\n *\n * This example shows how to use `NgModelController` with a custom control to achieve\n * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)\n * collaborate together to achieve the desired result.\n *\n * <example module=\"customControl\">\n    <file name=\"style.css\">\n      [contenteditable] {\n        border: 1px solid black;\n        background-color: white;\n        min-height: 20px;\n      }\n\n      .ng-invalid {\n        border: 1px solid red;\n      }\n\n    </file>\n    <file name=\"script.js\">\n      angular.module('customControl', []).\n        directive('contenteditable', function() {\n          return {\n            restrict: 'A', // only activate on element attribute\n            require: '?ngModel', // get a hold of NgModelController\n            link: function(scope, element, attrs, ngModel) {\n              if(!ngModel) return; // do nothing if no ng-model\n\n              // Specify how UI should be updated\n              ngModel.$render = function() {\n                element.html(ngModel.$viewValue || '');\n              };\n\n              // Listen for change events to enable binding\n              element.bind('blur keyup change', function() {\n                scope.$apply(read);\n              });\n              read(); // initialize\n\n              // Write data to the model\n              function read() {\n                var html = element.html();\n                // When we clear the content editable the browser leaves a <br> behind\n                // If strip-br attribute is provided then we strip this out\n                if( attrs.stripBr && html == '<br>' ) {\n                  html = '';\n                }\n                ngModel.$setViewValue(html);\n              }\n            }\n          };\n        });\n    </file>\n    <file name=\"index.html\">\n      <form name=\"myForm\">\n       <div contenteditable\n            name=\"myWidget\" ng-model=\"userContent\"\n            strip-br=\"true\"\n            required>Change me!</div>\n        <span ng-show=\"myForm.myWidget.$error.required\">Required!</span>\n       <hr>\n       <textarea ng-model=\"userContent\"></textarea>\n      </form>\n    </file>\n    <file name=\"scenario.js\">\n      it('should data-bind and become invalid', function() {\n        var contentEditable = element('[contenteditable]');\n\n        expect(contentEditable.text()).toEqual('Change me!');\n        input('userContent').enter('');\n        expect(contentEditable.text()).toEqual('');\n        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);\n      });\n    </file>\n * </example>\n *\n */\nvar NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',\n    function($scope, $exceptionHandler, $attr, $element, $parse) {\n  this.$viewValue = Number.NaN;\n  this.$modelValue = Number.NaN;\n  this.$parsers = [];\n  this.$formatters = [];\n  this.$viewChangeListeners = [];\n  this.$pristine = true;\n  this.$dirty = false;\n  this.$valid = true;\n  this.$invalid = false;\n  this.$name = $attr.name;\n\n  var ngModelGet = $parse($attr.ngModel),\n      ngModelSet = ngModelGet.assign;\n\n  if (!ngModelSet) {\n    throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel +\n        ' (' + startingTag($element) + ')');\n  }\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:ngModel.NgModelController#$render\n   * @methodOf ng.directive:ngModel.NgModelController\n   *\n   * @description\n   * Called when the view needs to be updated. It is expected that the user of the ng-model\n   * directive will implement this method.\n   */\n  this.$render = noop;\n\n  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,\n      invalidCount = 0, // used to easily determine if we are valid\n      $error = this.$error = {}; // keep invalid keys here\n\n\n  // Setup initial state of the control\n  $element.addClass(PRISTINE_CLASS);\n  toggleValidCss(true);\n\n  // convenience method for easy toggling of classes\n  function toggleValidCss(isValid, validationErrorKey) {\n    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';\n    $element.\n      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).\n      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);\n  }\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:ngModel.NgModelController#$setValidity\n   * @methodOf ng.directive:ngModel.NgModelController\n   *\n   * @description\n   * Change the validity state, and notifies the form when the control changes validity. (i.e. it\n   * does not notify form if given validator is already marked as invalid).\n   *\n   * This method should be called by validators - i.e. the parser or formatter functions.\n   *\n   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign\n   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.\n   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case\n   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`\n   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .\n   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).\n   */\n  this.$setValidity = function(validationErrorKey, isValid) {\n    if ($error[validationErrorKey] === !isValid) return;\n\n    if (isValid) {\n      if ($error[validationErrorKey]) invalidCount--;\n      if (!invalidCount) {\n        toggleValidCss(true);\n        this.$valid = true;\n        this.$invalid = false;\n      }\n    } else {\n      toggleValidCss(false);\n      this.$invalid = true;\n      this.$valid = false;\n      invalidCount++;\n    }\n\n    $error[validationErrorKey] = !isValid;\n    toggleValidCss(isValid, validationErrorKey);\n\n    parentForm.$setValidity(validationErrorKey, isValid, this);\n  };\n\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:ngModel.NgModelController#$setViewValue\n   * @methodOf ng.directive:ngModel.NgModelController\n   *\n   * @description\n   * Read a value from view.\n   *\n   * This method should be called from within a DOM event handler.\n   * For example {@link ng.directive:input input} or\n   * {@link ng.directive:select select} directives call it.\n   *\n   * It internally calls all `$parsers` (including validators) and updates the `$modelValue` and the actual model path.\n   * Lastly it calls all registered change listeners.\n   *\n   * @param {string} value Value from the view.\n   */\n  this.$setViewValue = function(value) {\n    this.$viewValue = value;\n\n    // change to dirty\n    if (this.$pristine) {\n      this.$dirty = true;\n      this.$pristine = false;\n      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);\n      parentForm.$setDirty();\n    }\n\n    forEach(this.$parsers, function(fn) {\n      value = fn(value);\n    });\n\n    if (this.$modelValue !== value) {\n      this.$modelValue = value;\n      ngModelSet($scope, value);\n      forEach(this.$viewChangeListeners, function(listener) {\n        try {\n          listener();\n        } catch(e) {\n          $exceptionHandler(e);\n        }\n      })\n    }\n  };\n\n  // model -> value\n  var ctrl = this;\n\n  $scope.$watch(function ngModelWatch() {\n    var value = ngModelGet($scope);\n\n    // if scope model value and ngModel value are out of sync\n    if (ctrl.$modelValue !== value) {\n\n      var formatters = ctrl.$formatters,\n          idx = formatters.length;\n\n      ctrl.$modelValue = value;\n      while(idx--) {\n        value = formatters[idx](value);\n      }\n\n      if (ctrl.$viewValue !== value) {\n        ctrl.$viewValue = value;\n        ctrl.$render();\n      }\n    }\n  });\n}];\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngModel\n *\n * @element input\n *\n * @description\n * Is a directive that tells Angular to do two-way data binding. It works together with `input`,\n * `select`, `textarea`. You can easily write your own directives to use `ngModel` as well.\n *\n * `ngModel` is responsible for:\n *\n * - binding the view into the model, which other directives such as `input`, `textarea` or `select`\n *   require,\n * - providing validation behavior (i.e. required, number, email, url),\n * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),\n * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),\n * - register the control with parent {@link ng.directive:form form}.\n *\n * Note: `ngModel` will try to bind to the property given by evaluating the expression on the\n * current scope. If the property doesn't already exist on this scope, it will be created\n * implicitly and added to the scope.\n *\n * For basic examples, how to use `ngModel`, see:\n *\n *  - {@link ng.directive:input input}\n *    - {@link ng.directive:input.text text}\n *    - {@link ng.directive:input.checkbox checkbox}\n *    - {@link ng.directive:input.radio radio}\n *    - {@link ng.directive:input.number number}\n *    - {@link ng.directive:input.email email}\n *    - {@link ng.directive:input.url url}\n *  - {@link ng.directive:select select}\n *  - {@link ng.directive:textarea textarea}\n *\n */\nvar ngModelDirective = function() {\n  return {\n    require: ['ngModel', '^?form'],\n    controller: NgModelController,\n    link: function(scope, element, attr, ctrls) {\n      // notify others, especially parent forms\n\n      var modelCtrl = ctrls[0],\n          formCtrl = ctrls[1] || nullFormCtrl;\n\n      formCtrl.$addControl(modelCtrl);\n\n      element.bind('$destroy', function() {\n        formCtrl.$removeControl(modelCtrl);\n      });\n    }\n  };\n};\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngChange\n * @restrict E\n *\n * @description\n * Evaluate given expression when user changes the input.\n * The expression is not evaluated when the value change is coming from the model.\n *\n * Note, this directive requires `ngModel` to be present.\n *\n * @element input\n *\n * @example\n * <doc:example>\n *   <doc:source>\n *     <script>\n *       function Controller($scope) {\n *         $scope.counter = 0;\n *         $scope.change = function() {\n *           $scope.counter++;\n *         };\n *       }\n *     </script>\n *     <div ng-controller=\"Controller\">\n *       <input type=\"checkbox\" ng-model=\"confirmed\" ng-change=\"change()\" id=\"ng-change-example1\" />\n *       <input type=\"checkbox\" ng-model=\"confirmed\" id=\"ng-change-example2\" />\n *       <label for=\"ng-change-example2\">Confirmed</label><br />\n *       debug = {{confirmed}}<br />\n *       counter = {{counter}}\n *     </div>\n *   </doc:source>\n *   <doc:scenario>\n *     it('should evaluate the expression if changing from view', function() {\n *       expect(binding('counter')).toEqual('0');\n *       element('#ng-change-example1').click();\n *       expect(binding('counter')).toEqual('1');\n *       expect(binding('confirmed')).toEqual('true');\n *     });\n *\n *     it('should not evaluate the expression if changing from model', function() {\n *       element('#ng-change-example2').click();\n *       expect(binding('counter')).toEqual('0');\n *       expect(binding('confirmed')).toEqual('true');\n *     });\n *   </doc:scenario>\n * </doc:example>\n */\nvar ngChangeDirective = valueFn({\n  require: 'ngModel',\n  link: function(scope, element, attr, ctrl) {\n    ctrl.$viewChangeListeners.push(function() {\n      scope.$eval(attr.ngChange);\n    });\n  }\n});\n\n\nvar requiredDirective = function() {\n  return {\n    require: '?ngModel',\n    link: function(scope, elm, attr, ctrl) {\n      if (!ctrl) return;\n      attr.required = true; // force truthy in case we are on non input element\n\n      var validator = function(value) {\n        if (attr.required && (isEmpty(value) || value === false)) {\n          ctrl.$setValidity('required', false);\n          return;\n        } else {\n          ctrl.$setValidity('required', true);\n          return value;\n        }\n      };\n\n      ctrl.$formatters.push(validator);\n      ctrl.$parsers.unshift(validator);\n\n      attr.$observe('required', function() {\n        validator(ctrl.$viewValue);\n      });\n    }\n  };\n};\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngList\n *\n * @description\n * Text input that converts between comma-separated string into an array of strings.\n *\n * @element input\n * @param {string=} ngList optional delimiter that should be used to split the value. If\n *   specified in form `/something/` then the value will be converted into a regular expression.\n *\n * @example\n    <doc:example>\n      <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.names = ['igor', 'misko', 'vojta'];\n         }\n       </script>\n       <form name=\"myForm\" ng-controller=\"Ctrl\">\n         List: <input name=\"namesInput\" ng-model=\"names\" ng-list required>\n         <span class=\"error\" ng-show=\"myForm.namesInput.$error.required\">\n           Required!</span>\n         <br>\n         <tt>names = {{names}}</tt><br/>\n         <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>\n         <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n        </form>\n      </doc:source>\n      <doc:scenario>\n        it('should initialize to model', function() {\n          expect(binding('names')).toEqual('[\"igor\",\"misko\",\"vojta\"]');\n          expect(binding('myForm.namesInput.$valid')).toEqual('true');\n          expect(element('span.error').css('display')).toBe('none');\n        });\n\n        it('should be invalid if empty', function() {\n          input('names').enter('');\n          expect(binding('names')).toEqual('[]');\n          expect(binding('myForm.namesInput.$valid')).toEqual('false');\n          expect(element('span.error').css('display')).not().toBe('none');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar ngListDirective = function() {\n  return {\n    require: 'ngModel',\n    link: function(scope, element, attr, ctrl) {\n      var match = /\\/(.*)\\//.exec(attr.ngList),\n          separator = match && new RegExp(match[1]) || attr.ngList || ',';\n\n      var parse = function(viewValue) {\n        var list = [];\n\n        if (viewValue) {\n          forEach(viewValue.split(separator), function(value) {\n            if (value) list.push(trim(value));\n          });\n        }\n\n        return list;\n      };\n\n      ctrl.$parsers.push(parse);\n      ctrl.$formatters.push(function(value) {\n        if (isArray(value)) {\n          return value.join(', ');\n        }\n\n        return undefined;\n      });\n    }\n  };\n};\n\n\nvar CONSTANT_VALUE_REGEXP = /^(true|false|\\d+)$/;\n\nvar ngValueDirective = function() {\n  return {\n    priority: 100,\n    compile: function(tpl, tplAttr) {\n      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {\n        return function(scope, elm, attr) {\n          attr.$set('value', scope.$eval(attr.ngValue));\n        };\n      } else {\n        return function(scope, elm, attr) {\n          scope.$watch(attr.ngValue, function valueWatchAction(value) {\n            attr.$set('value', value);\n          });\n        };\n      }\n    }\n  };\n};\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngBind\n *\n * @description\n * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element\n * with the value of a given expression, and to update the text content when the value of that\n * expression changes.\n *\n * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like\n * `{{ expression }}` which is similar but less verbose.\n *\n * It is preferrable to use `ngBind` instead of `{{ expression }}` when a template is momentarily \n * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an \n * element attribute, it makes the bindings invisible to the user while the page is loading.\n *\n * An alternative solution to this problem would be using the\n * {@link ng.directive:ngCloak ngCloak} directive.\n *\n *\n * @element ANY\n * @param {expression} ngBind {@link guide/expression Expression} to evaluate.\n *\n * @example\n * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.name = 'Whirled';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         Enter name: <input type=\"text\" ng-model=\"name\"><br>\n         Hello <span ng-bind=\"name\"></span>!\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-bind', function() {\n         expect(using('.doc-example-live').binding('name')).toBe('Whirled');\n         using('.doc-example-live').input('name').enter('world');\n         expect(using('.doc-example-live').binding('name')).toBe('world');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nvar ngBindDirective = ngDirective(function(scope, element, attr) {\n  element.addClass('ng-binding').data('$binding', attr.ngBind);\n  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {\n    element.text(value == undefined ? '' : value);\n  });\n});\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngBindTemplate\n *\n * @description\n * The `ngBindTemplate` directive specifies that the element\n * text content should be replaced with the interpolation of the template\n * in the `ngBindTemplate` attribute.\n * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`\n * expressions. This directive is needed since some HTML elements\n * (such as TITLE and OPTION) cannot contain SPAN elements.\n *\n * @element ANY\n * @param {string} ngBindTemplate template of form\n *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.\n *\n * @example\n * Try it here: enter text in text box and watch the greeting change.\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.salutation = 'Hello';\n           $scope.name = 'World';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n        Salutation: <input type=\"text\" ng-model=\"salutation\"><br>\n        Name: <input type=\"text\" ng-model=\"name\"><br>\n        <pre ng-bind-template=\"{{salutation}} {{name}}!\"></pre>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-bind', function() {\n         expect(using('.doc-example-live').binding('salutation')).\n           toBe('Hello');\n         expect(using('.doc-example-live').binding('name')).\n           toBe('World');\n         using('.doc-example-live').input('salutation').enter('Greetings');\n         using('.doc-example-live').input('name').enter('user');\n         expect(using('.doc-example-live').binding('salutation')).\n           toBe('Greetings');\n         expect(using('.doc-example-live').binding('name')).\n           toBe('user');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nvar ngBindTemplateDirective = ['$interpolate', function($interpolate) {\n  return function(scope, element, attr) {\n    // TODO: move this to scenario runner\n    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));\n    element.addClass('ng-binding').data('$binding', interpolateFn);\n    attr.$observe('ngBindTemplate', function(value) {\n      element.text(value);\n    });\n  }\n}];\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngBindHtmlUnsafe\n *\n * @description\n * Creates a binding that will innerHTML the result of evaluating the `expression` into the current\n * element. *The innerHTML-ed content will not be sanitized!* You should use this directive only if\n * {@link ngSanitize.directive:ngBindHtml ngBindHtml} directive is too\n * restrictive and when you absolutely trust the source of the content you are binding to.\n *\n * See {@link ngSanitize.$sanitize $sanitize} docs for examples.\n *\n * @element ANY\n * @param {expression} ngBindHtmlUnsafe {@link guide/expression Expression} to evaluate.\n */\nvar ngBindHtmlUnsafeDirective = [function() {\n  return function(scope, element, attr) {\n    element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);\n    scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {\n      element.html(value || '');\n    });\n  };\n}];\n\nfunction classDirective(name, selector) {\n  name = 'ngClass' + name;\n  return ngDirective(function(scope, element, attr) {\n    var oldVal = undefined;\n\n    scope.$watch(attr[name], ngClassWatchAction, true);\n\n    attr.$observe('class', function(value) {\n      var ngClass = scope.$eval(attr[name]);\n      ngClassWatchAction(ngClass, ngClass);\n    });\n\n\n    if (name !== 'ngClass') {\n      scope.$watch('$index', function($index, old$index) {\n        var mod = $index & 1;\n        if (mod !== old$index & 1) {\n          if (mod === selector) {\n            addClass(scope.$eval(attr[name]));\n          } else {\n            removeClass(scope.$eval(attr[name]));\n          }\n        }\n      });\n    }\n\n\n    function ngClassWatchAction(newVal) {\n      if (selector === true || scope.$index % 2 === selector) {\n        if (oldVal && !equals(newVal,oldVal)) {\n          removeClass(oldVal);\n        }\n        addClass(newVal);\n      }\n      oldVal = copy(newVal);\n    }\n\n\n    function removeClass(classVal) {\n      if (isObject(classVal) && !isArray(classVal)) {\n        classVal = map(classVal, function(v, k) { if (v) return k });\n      }\n      element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);\n    }\n\n\n    function addClass(classVal) {\n      if (isObject(classVal) && !isArray(classVal)) {\n        classVal = map(classVal, function(v, k) { if (v) return k });\n      }\n      if (classVal) {\n        element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);\n      }\n    }\n  });\n}\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClass\n *\n * @description\n * The `ngClass` allows you to set CSS classes on HTML an element, dynamically, by databinding\n * an expression that represents all classes to be added.\n *\n * The directive won't add duplicate classes if a particular class was already set.\n *\n * When the expression changes, the previously added classes are removed and only then the\n * new classes are added.\n *\n * @element ANY\n * @param {expression} ngClass {@link guide/expression Expression} to eval. The result\n *   of the evaluation can be a string representing space delimited class\n *   names, an array, or a map of class names to boolean values. In the case of a map, the\n *   names of the properties whose values are truthy will be added as css classes to the\n *   element.\n *\n * @example\n   <example>\n     <file name=\"index.html\">\n      <input type=\"button\" value=\"set\" ng-click=\"myVar='my-class'\">\n      <input type=\"button\" value=\"clear\" ng-click=\"myVar=''\">\n      <br>\n      <span ng-class=\"myVar\">Sample Text</span>\n     </file>\n     <file name=\"style.css\">\n       .my-class {\n         color: red;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-class', function() {\n         expect(element('.doc-example-live span').prop('className')).not().\n           toMatch(/my-class/);\n\n         using('.doc-example-live').element(':button:first').click();\n\n         expect(element('.doc-example-live span').prop('className')).\n           toMatch(/my-class/);\n\n         using('.doc-example-live').element(':button:last').click();\n\n         expect(element('.doc-example-live span').prop('className')).not().\n           toMatch(/my-class/);\n       });\n     </file>\n   </example>\n */\nvar ngClassDirective = classDirective('', true);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClassOdd\n *\n * @description\n * The `ngClassOdd` and `ngClassEven` directives work exactly as\n * {@link ng.directive:ngClass ngClass}, except it works in\n * conjunction with `ngRepeat` and takes affect only on odd (even) rows.\n *\n * This directive can be applied only within a scope of an\n * {@link ng.directive:ngRepeat ngRepeat}.\n *\n * @element ANY\n * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result\n *   of the evaluation can be a string representing space delimited class names or an array.\n *\n * @example\n   <example>\n     <file name=\"index.html\">\n        <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\n          <li ng-repeat=\"name in names\">\n           <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\n             {{name}}\n           </span>\n          </li>\n        </ol>\n     </file>\n     <file name=\"style.css\">\n       .odd {\n         color: red;\n       }\n       .even {\n         color: blue;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-class-odd and ng-class-even', function() {\n         expect(element('.doc-example-live li:first span').prop('className')).\n           toMatch(/odd/);\n         expect(element('.doc-example-live li:last span').prop('className')).\n           toMatch(/even/);\n       });\n     </file>\n   </example>\n */\nvar ngClassOddDirective = classDirective('Odd', 0);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClassEven\n *\n * @description\n * The `ngClassOdd` and `ngClassEven` directives work exactly as\n * {@link ng.directive:ngClass ngClass}, except it works in\n * conjunction with `ngRepeat` and takes affect only on odd (even) rows.\n *\n * This directive can be applied only within a scope of an\n * {@link ng.directive:ngRepeat ngRepeat}.\n *\n * @element ANY\n * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The\n *   result of the evaluation can be a string representing space delimited class names or an array.\n *\n * @example\n   <example>\n     <file name=\"index.html\">\n        <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\n          <li ng-repeat=\"name in names\">\n           <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\n             {{name}} &nbsp; &nbsp; &nbsp;\n           </span>\n          </li>\n        </ol>\n     </file>\n     <file name=\"style.css\">\n       .odd {\n         color: red;\n       }\n       .even {\n         color: blue;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-class-odd and ng-class-even', function() {\n         expect(element('.doc-example-live li:first span').prop('className')).\n           toMatch(/odd/);\n         expect(element('.doc-example-live li:last span').prop('className')).\n           toMatch(/even/);\n       });\n     </file>\n   </example>\n */\nvar ngClassEvenDirective = classDirective('Even', 1);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngCloak\n *\n * @description\n * The `ngCloak` directive is used to prevent the Angular html template from being briefly\n * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this\n * directive to avoid the undesirable flicker effect caused by the html template display.\n *\n * The directive can be applied to the `<body>` element, but typically a fine-grained application is\n * prefered in order to benefit from progressive rendering of the browser view.\n *\n * `ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and\n *  `angular.min.js` files. Following is the css rule:\n *\n * <pre>\n * [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {\n *   display: none !important;\n * }\n * </pre>\n *\n * When this css rule is loaded by the browser, all html elements (including their children) that\n * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive\n * during the compilation of the template it deletes the `ngCloak` element attribute, which\n * makes the compiled element visible.\n *\n * For the best result, `angular.js` script must be loaded in the head section of the html file;\n * alternatively, the css rule (above) must be included in the external stylesheet of the\n * application.\n *\n * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they\n * cannot match the `[ng\\:cloak]` selector. To work around this limitation, you must add the css\n * class `ngCloak` in addition to `ngCloak` directive as shown in the example below.\n *\n * @element ANY\n *\n * @example\n   <doc:example>\n     <doc:source>\n        <div id=\"template1\" ng-cloak>{{ 'hello' }}</div>\n        <div id=\"template2\" ng-cloak class=\"ng-cloak\">{{ 'hello IE7' }}</div>\n     </doc:source>\n     <doc:scenario>\n       it('should remove the template directive and css class', function() {\n         expect(element('.doc-example-live #template1').attr('ng-cloak')).\n           not().toBeDefined();\n         expect(element('.doc-example-live #template2').attr('ng-cloak')).\n           not().toBeDefined();\n       });\n     </doc:scenario>\n   </doc:example>\n *\n */\nvar ngCloakDirective = ngDirective({\n  compile: function(element, attr) {\n    attr.$set('ngCloak', undefined);\n    element.removeClass('ng-cloak');\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngController\n *\n * @description\n * The `ngController` directive assigns behavior to a scope. This is a key aspect of how angular\n * supports the principles behind the Model-View-Controller design pattern.\n *\n * MVC components in angular:\n *\n * * Model — The Model is data in scope properties; scopes are attached to the DOM.\n * * View — The template (HTML with data bindings) is rendered into the View.\n * * Controller — The `ngController` directive specifies a Controller class; the class has\n *   methods that typically express the business logic behind the application.\n *\n * Note that an alternative way to define controllers is via the {@link ng.$route $route} service.\n *\n * @element ANY\n * @scope\n * @param {expression} ngController Name of a globally accessible constructor function or an\n *     {@link guide/expression expression} that on the current scope evaluates to a\n *     constructor function.\n *\n * @example\n * Here is a simple form for editing user contact information. Adding, removing, clearing, and\n * greeting are methods declared on the $scope by the controller (see source tab). These methods can\n * easily be called from the angular markup. Notice that any changes to the data are automatically\n * reflected in the View without the need for a manual update.\n   <doc:example>\n     <doc:source>\n      <script>\n        function SettingsController($scope) {\n          $scope.name = \"John Smith\";\n          $scope.contacts = [\n            {type:'phone', value:'408 555 1212'},\n            {type:'email', value:'john.smith@example.org'} ];\n\n          $scope.greet = function() {\n           alert(this.name);\n          };\n\n          $scope.addContact = function() {\n           this.contacts.push({type:'email', value:'yourname@example.org'});\n          };\n\n          $scope.removeContact = function(contactToRemove) {\n           var index = this.contacts.indexOf(contactToRemove);\n           this.contacts.splice(index, 1);\n          };\n\n          $scope.clearContact = function(contact) {\n           contact.type = 'phone';\n           contact.value = '';\n          };\n        }\n      </script>\n      <div ng-controller=\"SettingsController\">\n        Name: <input type=\"text\" ng-model=\"name\"/>\n        [ <a href=\"\" ng-click=\"greet()\">greet</a> ]<br/>\n        Contact:\n        <ul>\n          <li ng-repeat=\"contact in contacts\">\n            <select ng-model=\"contact.type\">\n               <option>phone</option>\n               <option>email</option>\n            </select>\n            <input type=\"text\" ng-model=\"contact.value\"/>\n            [ <a href=\"\" ng-click=\"clearContact(contact)\">clear</a>\n            | <a href=\"\" ng-click=\"removeContact(contact)\">X</a> ]\n          </li>\n          <li>[ <a href=\"\" ng-click=\"addContact()\">add</a> ]</li>\n       </ul>\n      </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check controller', function() {\n         expect(element('.doc-example-live div>:input').val()).toBe('John Smith');\n         expect(element('.doc-example-live li:nth-child(1) input').val())\n           .toBe('408 555 1212');\n         expect(element('.doc-example-live li:nth-child(2) input').val())\n           .toBe('john.smith@example.org');\n\n         element('.doc-example-live li:first a:contains(\"clear\")').click();\n         expect(element('.doc-example-live li:first input').val()).toBe('');\n\n         element('.doc-example-live li:last a:contains(\"add\")').click();\n         expect(element('.doc-example-live li:nth-child(3) input').val())\n           .toBe('yourname@example.org');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nvar ngControllerDirective = [function() {\n  return {\n    scope: true,\n    controller: '@'\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngCsp\n * @priority 1000\n *\n * @element html\n * @description\n * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.\n * \n * This is necessary when developing things like Google Chrome Extensions.\n * \n * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).\n * For us to be compatible, we just need to implement the \"getterFn\" in $parse without violating\n * any of these restrictions.\n * \n * AngularJS uses `Function(string)` generated functions as a speed optimization. By applying `ngCsp`\n * it is be possible to opt into the CSP compatible mode. When this mode is on AngularJS will\n * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will\n * be raised.\n * \n * In order to use this feature put `ngCsp` directive on the root element of the application.\n * \n * @example\n * This example shows how to apply the `ngCsp` directive to the `html` tag.\n   <pre>\n     <!doctype html>\n     <html ng-app ng-csp>\n     ...\n     ...\n     </html>\n   </pre>\n */\n\nvar ngCspDirective = ['$sniffer', function($sniffer) {\n  return {\n    priority: 1000,\n    compile: function() {\n      $sniffer.csp = true;\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClick\n *\n * @description\n * The ngClick allows you to specify custom behavior when\n * element is clicked.\n *\n * @element ANY\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon\n * click. (Event object is available as `$event`)\n *\n * @example\n   <doc:example>\n     <doc:source>\n      <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\n        Increment\n      </button>\n      count: {{count}}\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-click', function() {\n         expect(binding('count')).toBe('0');\n         element('.doc-example-live :button').click();\n         expect(binding('count')).toBe('1');\n       });\n     </doc:scenario>\n   </doc:example>\n */\n/*\n * A directive that allows creation of custom onclick handlers that are defined as angular\n * expressions and are compiled and executed within the current scope.\n *\n * Events that are handled via these handler are always configured not to propagate further.\n */\nvar ngEventDirectives = {};\nforEach(\n  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave submit'.split(' '),\n  function(name) {\n    var directiveName = directiveNormalize('ng-' + name);\n    ngEventDirectives[directiveName] = ['$parse', function($parse) {\n      return function(scope, element, attr) {\n        var fn = $parse(attr[directiveName]);\n        element.bind(lowercase(name), function(event) {\n          scope.$apply(function() {\n            fn(scope, {$event:event});\n          });\n        });\n      };\n    }];\n  }\n);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngDblclick\n *\n * @description\n * The `ngDblclick` directive allows you to specify custom behavior on dblclick event.\n *\n * @element ANY\n * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon\n * dblclick. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMousedown\n *\n * @description\n * The ngMousedown directive allows you to specify custom behavior on mousedown event.\n *\n * @element ANY\n * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon\n * mousedown. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseup\n *\n * @description\n * Specify custom behavior on mouseup event.\n *\n * @element ANY\n * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon\n * mouseup. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseover\n *\n * @description\n * Specify custom behavior on mouseover event.\n *\n * @element ANY\n * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon\n * mouseover. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseenter\n *\n * @description\n * Specify custom behavior on mouseenter event.\n *\n * @element ANY\n * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon\n * mouseenter. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseleave\n *\n * @description\n * Specify custom behavior on mouseleave event.\n *\n * @element ANY\n * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon\n * mouseleave. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMousemove\n *\n * @description\n * Specify custom behavior on mousemove event.\n *\n * @element ANY\n * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon\n * mousemove. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngKeydown\n *\n * @description\n * Specify custom behavior on keydown event.\n *\n * @element ANY\n * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon\n * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngKeyup\n *\n * @description\n * Specify custom behavior on keyup event.\n *\n * @element ANY\n * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon\n * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngKeypress\n *\n * @description\n * Specify custom behavior on keypress event.\n *\n * @element ANY\n * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon\n * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSubmit\n *\n * @description\n * Enables binding angular expressions to onsubmit events.\n *\n * Additionally it prevents the default action (which for form means sending the request to the\n * server and reloading the current page) **but only if the form does not contain an `action`\n * attribute**.\n *\n * @element form\n * @param {expression} ngSubmit {@link guide/expression Expression} to eval. (Event object is available as `$event`)\n *\n * @example\n   <doc:example>\n     <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.list = [];\n          $scope.text = 'hello';\n          $scope.submit = function() {\n            if (this.text) {\n              this.list.push(this.text);\n              this.text = '';\n            }\n          };\n        }\n      </script>\n      <form ng-submit=\"submit()\" ng-controller=\"Ctrl\">\n        Enter text and hit enter:\n        <input type=\"text\" ng-model=\"text\" name=\"text\" />\n        <input type=\"submit\" id=\"submit\" value=\"Submit\" />\n        <pre>list={{list}}</pre>\n      </form>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-submit', function() {\n         expect(binding('list')).toBe('[]');\n         element('.doc-example-live #submit').click();\n         expect(binding('list')).toBe('[\"hello\"]');\n         expect(input('text').val()).toBe('');\n       });\n       it('should ignore empty strings', function() {\n         expect(binding('list')).toBe('[]');\n         element('.doc-example-live #submit').click();\n         element('.doc-example-live #submit').click();\n         expect(binding('list')).toBe('[\"hello\"]');\n       });\n     </doc:scenario>\n   </doc:example>\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngInclude\n * @restrict ECA\n *\n * @description\n * Fetches, compiles and includes an external HTML fragment.\n *\n * Keep in mind that Same Origin Policy applies to included resources\n * (e.g. ngInclude won't work for cross-domain requests on all browsers and for\n *  file:// access on some browsers).\n *\n * @scope\n *\n * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,\n *                 make sure you wrap it in quotes, e.g. `src=\"'myPartialTemplate.html'\"`.\n * @param {string=} onload Expression to evaluate when a new partial is loaded.\n *\n * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the content is loaded.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.\n *\n * @example\n  <example>\n    <file name=\"index.html\">\n     <div ng-controller=\"Ctrl\">\n       <select ng-model=\"template\" ng-options=\"t.name for t in templates\">\n        <option value=\"\">(blank)</option>\n       </select>\n       url of the template: <tt>{{template.url}}</tt>\n       <hr/>\n       <div ng-include src=\"template.url\"></div>\n     </div>\n    </file>\n    <file name=\"script.js\">\n      function Ctrl($scope) {\n        $scope.templates =\n          [ { name: 'template1.html', url: 'template1.html'}\n          , { name: 'template2.html', url: 'template2.html'} ];\n        $scope.template = $scope.templates[0];\n      }\n     </file>\n    <file name=\"template1.html\">\n      Content of template1.html\n    </file>\n    <file name=\"template2.html\">\n      Content of template2.html\n    </file>\n    <file name=\"scenario.js\">\n      it('should load template1.html', function() {\n       expect(element('.doc-example-live [ng-include]').text()).\n         toMatch(/Content of template1.html/);\n      });\n      it('should load template2.html', function() {\n       select('template').option('1');\n       expect(element('.doc-example-live [ng-include]').text()).\n         toMatch(/Content of template2.html/);\n      });\n      it('should change to blank', function() {\n       select('template').option('');\n       expect(element('.doc-example-live [ng-include]').text()).toEqual('');\n      });\n    </file>\n  </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ng.directive:ngInclude#$includeContentLoaded\n * @eventOf ng.directive:ngInclude\n * @eventType emit on the current ngInclude scope\n * @description\n * Emitted every time the ngInclude content is reloaded.\n */\nvar ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile',\n                  function($http,   $templateCache,   $anchorScroll,   $compile) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    compile: function(element, attr) {\n      var srcExp = attr.ngInclude || attr.src,\n          onloadExp = attr.onload || '',\n          autoScrollExp = attr.autoscroll;\n\n      return function(scope, element) {\n        var changeCounter = 0,\n            childScope;\n\n        var clearContent = function() {\n          if (childScope) {\n            childScope.$destroy();\n            childScope = null;\n          }\n\n          element.html('');\n        };\n\n        scope.$watch(srcExp, function ngIncludeWatchAction(src) {\n          var thisChangeId = ++changeCounter;\n\n          if (src) {\n            $http.get(src, {cache: $templateCache}).success(function(response) {\n              if (thisChangeId !== changeCounter) return;\n\n              if (childScope) childScope.$destroy();\n              childScope = scope.$new();\n\n              element.html(response);\n              $compile(element.contents())(childScope);\n\n              if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                $anchorScroll();\n              }\n\n              childScope.$emit('$includeContentLoaded');\n              scope.$eval(onloadExp);\n            }).error(function() {\n              if (thisChangeId === changeCounter) clearContent();\n            });\n          } else clearContent();\n        });\n      };\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngInit\n *\n * @description\n * The `ngInit` directive specifies initialization tasks to be executed\n *  before the template enters execution mode during bootstrap.\n *\n * @element ANY\n * @param {expression} ngInit {@link guide/expression Expression} to eval.\n *\n * @example\n   <doc:example>\n     <doc:source>\n    <div ng-init=\"greeting='Hello'; person='World'\">\n      {{greeting}} {{person}}!\n    </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check greeting', function() {\n         expect(binding('greeting')).toBe('Hello');\n         expect(binding('person')).toBe('World');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nvar ngInitDirective = ngDirective({\n  compile: function() {\n    return {\n      pre: function(scope, element, attrs) {\n        scope.$eval(attrs.ngInit);\n      }\n    }\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngNonBindable\n * @priority 1000\n *\n * @description\n * Sometimes it is necessary to write code which looks like bindings but which should be left alone\n * by angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.\n *\n * @element ANY\n *\n * @example\n * In this example there are two location where a simple binding (`{{}}`) is present, but the one\n * wrapped in `ngNonBindable` is left alone.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        <div>Normal: {{1 + 2}}</div>\n        <div ng-non-bindable>Ignored: {{1 + 2}}</div>\n      </doc:source>\n      <doc:scenario>\n       it('should check ng-non-bindable', function() {\n         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');\n         expect(using('.doc-example-live').element('div:last').text()).\n           toMatch(/1 \\+ 2/);\n       });\n      </doc:scenario>\n    </doc:example>\n */\nvar ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngPluralize\n * @restrict EA\n *\n * @description\n * # Overview\n * `ngPluralize` is a directive that displays messages according to en-US localization rules.\n * These rules are bundled with angular.js, but can be overridden\n * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive\n * by specifying the mappings between\n * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\n * plural categories} and the strings to be displayed.\n *\n * # Plural categories and explicit number rules\n * There are two\n * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\n * plural categories} in Angular's default en-US locale: \"one\" and \"other\".\n *\n * While a pural category may match many numbers (for example, in en-US locale, \"other\" can match\n * any number that is not 1), an explicit number rule can only match one number. For example, the\n * explicit number rule for \"3\" matches the number 3. There are examples of plural categories\n * and explicit number rules throughout the rest of this documentation.\n *\n * # Configuring ngPluralize\n * You configure ngPluralize by providing 2 attributes: `count` and `when`.\n * You can also provide an optional attribute, `offset`.\n *\n * The value of the `count` attribute can be either a string or an {@link guide/expression\n * Angular expression}; these are evaluated on the current scope for its bound value.\n *\n * The `when` attribute specifies the mappings between plural categories and the actual\n * string to be displayed. The value of the attribute should be a JSON object.\n *\n * The following example shows how to configure ngPluralize:\n *\n * <pre>\n * <ng-pluralize count=\"personCount\"\n                 when=\"{'0': 'Nobody is viewing.',\n *                      'one': '1 person is viewing.',\n *                      'other': '{} people are viewing.'}\">\n * </ng-pluralize>\n *</pre>\n *\n * In the example, `\"0: Nobody is viewing.\"` is an explicit number rule. If you did not\n * specify this rule, 0 would be matched to the \"other\" category and \"0 people are viewing\"\n * would be shown instead of \"Nobody is viewing\". You can specify an explicit number rule for\n * other numbers, for example 12, so that instead of showing \"12 people are viewing\", you can\n * show \"a dozen people are viewing\".\n *\n * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted\n * into pluralized strings. In the previous example, Angular will replace `{}` with\n * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder\n * for <span ng-non-bindable>{{numberExpression}}</span>.\n *\n * # Configuring ngPluralize with offset\n * The `offset` attribute allows further customization of pluralized text, which can result in\n * a better user experience. For example, instead of the message \"4 people are viewing this document\",\n * you might display \"John, Kate and 2 others are viewing this document\".\n * The offset attribute allows you to offset a number by any desired value.\n * Let's take a look at an example:\n *\n * <pre>\n * <ng-pluralize count=\"personCount\" offset=2\n *               when=\"{'0': 'Nobody is viewing.',\n *                      '1': '{{person1}} is viewing.',\n *                      '2': '{{person1}} and {{person2}} are viewing.',\n *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',\n *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\n * </ng-pluralize>\n * </pre>\n *\n * Notice that we are still using two plural categories(one, other), but we added\n * three explicit number rules 0, 1 and 2.\n * When one person, perhaps John, views the document, \"John is viewing\" will be shown.\n * When three people view the document, no explicit number rule is found, so\n * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.\n * In this case, plural category 'one' is matched and \"John, Marry and one other person are viewing\"\n * is shown.\n *\n * Note that when you specify offsets, you must provide explicit number rules for\n * numbers from 0 up to and including the offset. If you use an offset of 3, for example,\n * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for\n * plural categories \"one\" and \"other\".\n *\n * @param {string|expression} count The variable to be bounded to.\n * @param {string} when The mapping between plural category to its correspoding strings.\n * @param {number=} offset Offset to deduct from the total number.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.person1 = 'Igor';\n            $scope.person2 = 'Misko';\n            $scope.personCount = 1;\n          }\n        </script>\n        <div ng-controller=\"Ctrl\">\n          Person 1:<input type=\"text\" ng-model=\"person1\" value=\"Igor\" /><br/>\n          Person 2:<input type=\"text\" ng-model=\"person2\" value=\"Misko\" /><br/>\n          Number of People:<input type=\"text\" ng-model=\"personCount\" value=\"1\" /><br/>\n\n          <!--- Example with simple pluralization rules for en locale --->\n          Without Offset:\n          <ng-pluralize count=\"personCount\"\n                        when=\"{'0': 'Nobody is viewing.',\n                               'one': '1 person is viewing.',\n                               'other': '{} people are viewing.'}\">\n          </ng-pluralize><br>\n\n          <!--- Example with offset --->\n          With Offset(2):\n          <ng-pluralize count=\"personCount\" offset=2\n                        when=\"{'0': 'Nobody is viewing.',\n                               '1': '{{person1}} is viewing.',\n                               '2': '{{person1}} and {{person2}} are viewing.',\n                               'one': '{{person1}}, {{person2}} and one other person are viewing.',\n                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\n          </ng-pluralize>\n        </div>\n      </doc:source>\n      <doc:scenario>\n        it('should show correct pluralized string', function() {\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                             toBe('1 person is viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                                                toBe('Igor is viewing.');\n\n          using('.doc-example-live').input('personCount').enter('0');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                               toBe('Nobody is viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                                              toBe('Nobody is viewing.');\n\n          using('.doc-example-live').input('personCount').enter('2');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                            toBe('2 people are viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                              toBe('Igor and Misko are viewing.');\n\n          using('.doc-example-live').input('personCount').enter('3');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                            toBe('3 people are viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                              toBe('Igor, Misko and one other person are viewing.');\n\n          using('.doc-example-live').input('personCount').enter('4');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                            toBe('4 people are viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                              toBe('Igor, Misko and 2 other people are viewing.');\n        });\n\n        it('should show data-binded names', function() {\n          using('.doc-example-live').input('personCount').enter('4');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n              toBe('Igor, Misko and 2 other people are viewing.');\n\n          using('.doc-example-live').input('person1').enter('Di');\n          using('.doc-example-live').input('person2').enter('Vojta');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n              toBe('Di, Vojta and 2 other people are viewing.');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {\n  var BRACE = /{}/g;\n  return {\n    restrict: 'EA',\n    link: function(scope, element, attr) {\n      var numberExp = attr.count,\n          whenExp = element.attr(attr.$attr.when), // this is because we have {{}} in attrs\n          offset = attr.offset || 0,\n          whens = scope.$eval(whenExp),\n          whensExpFns = {},\n          startSymbol = $interpolate.startSymbol(),\n          endSymbol = $interpolate.endSymbol();\n\n      forEach(whens, function(expression, key) {\n        whensExpFns[key] =\n          $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +\n            offset + endSymbol));\n      });\n\n      scope.$watch(function ngPluralizeWatch() {\n        var value = parseFloat(scope.$eval(numberExp));\n\n        if (!isNaN(value)) {\n          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,\n          //check it against pluralization rules in $locale service\n          if (!(value in whens)) value = $locale.pluralCat(value - offset);\n           return whensExpFns[value](scope, element, true);\n        } else {\n          return '';\n        }\n      }, function ngPluralizeWatchAction(newVal) {\n        element.text(newVal);\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngRepeat\n *\n * @description\n * The `ngRepeat` directive instantiates a template once per item from a collection. Each template\n * instance gets its own scope, where the given loop variable is set to the current collection item,\n * and `$index` is set to the item index or key.\n *\n * Special properties are exposed on the local scope of each template instance, including:\n *\n *   * `$index` – `{number}` – iterator offset of the repeated element (0..length-1)\n *   * `$first` – `{boolean}` – true if the repeated element is first in the iterator.\n *   * `$middle` – `{boolean}` – true if the repeated element is between the first and last in the iterator.\n *   * `$last` – `{boolean}` – true if the repeated element is last in the iterator.\n *\n *\n * @element ANY\n * @scope\n * @priority 1000\n * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. Two\n *   formats are currently supported:\n *\n *   * `variable in expression` – where variable is the user defined loop variable and `expression`\n *     is a scope expression giving the collection to enumerate.\n *\n *     For example: `track in cd.tracks`.\n *\n *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,\n *     and `expression` is the scope expression giving the collection to enumerate.\n *\n *     For example: `(name, age) in {'adam':10, 'amalie':12}`.\n *\n * @example\n * This example initializes the scope to a list of names and\n * then uses `ngRepeat` to display every person:\n    <doc:example>\n      <doc:source>\n        <div ng-init=\"friends = [{name:'John', age:25}, {name:'Mary', age:28}]\">\n          I have {{friends.length}} friends. They are:\n          <ul>\n            <li ng-repeat=\"friend in friends\">\n              [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.\n            </li>\n          </ul>\n        </div>\n      </doc:source>\n      <doc:scenario>\n         it('should check ng-repeat', function() {\n           var r = using('.doc-example-live').repeater('ul li');\n           expect(r.count()).toBe(2);\n           expect(r.row(0)).toEqual([\"1\",\"John\",\"25\"]);\n           expect(r.row(1)).toEqual([\"2\",\"Mary\",\"28\"]);\n         });\n      </doc:scenario>\n    </doc:example>\n */\nvar ngRepeatDirective = ngDirective({\n  transclude: 'element',\n  priority: 1000,\n  terminal: true,\n  compile: function(element, attr, linker) {\n    return function(scope, iterStartElement, attr){\n      var expression = attr.ngRepeat;\n      var match = expression.match(/^\\s*(.+)\\s+in\\s+(.*)\\s*$/),\n        lhs, rhs, valueIdent, keyIdent;\n      if (! match) {\n        throw Error(\"Expected ngRepeat in form of '_item_ in _collection_' but got '\" +\n          expression + \"'.\");\n      }\n      lhs = match[1];\n      rhs = match[2];\n      match = lhs.match(/^(?:([\\$\\w]+)|\\(([\\$\\w]+)\\s*,\\s*([\\$\\w]+)\\))$/);\n      if (!match) {\n        throw Error(\"'item' in 'item in collection' should be identifier or (key, value) but got '\" +\n            lhs + \"'.\");\n      }\n      valueIdent = match[3] || match[1];\n      keyIdent = match[2];\n\n      // Store a list of elements from previous run. This is a hash where key is the item from the\n      // iterator, and the value is an array of objects with following properties.\n      //   - scope: bound scope\n      //   - element: previous element.\n      //   - index: position\n      // We need an array of these objects since the same object can be returned from the iterator.\n      // We expect this to be a rare case.\n      var lastOrder = new HashQueueMap();\n\n      scope.$watch(function ngRepeatWatch(scope){\n        var index, length,\n            collection = scope.$eval(rhs),\n            cursor = iterStartElement,     // current position of the node\n            // Same as lastOrder but it has the current state. It will become the\n            // lastOrder on the next iteration.\n            nextOrder = new HashQueueMap(),\n            arrayBound,\n            childScope,\n            key, value, // key/value of iteration\n            array,\n            last;       // last object information {scope, element, index}\n\n\n\n        if (!isArray(collection)) {\n          // if object, extract keys, sort them and use to determine order of iteration over obj props\n          array = [];\n          for(key in collection) {\n            if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {\n              array.push(key);\n            }\n          }\n          array.sort();\n        } else {\n          array = collection || [];\n        }\n\n        arrayBound = array.length-1;\n\n        // we are not using forEach for perf reasons (trying to avoid #call)\n        for (index = 0, length = array.length; index < length; index++) {\n          key = (collection === array) ? index : array[index];\n          value = collection[key];\n\n          last = lastOrder.shift(value);\n\n          if (last) {\n            // if we have already seen this object, then we need to reuse the\n            // associated scope/element\n            childScope = last.scope;\n            nextOrder.push(value, last);\n\n            if (index === last.index) {\n              // do nothing\n              cursor = last.element;\n            } else {\n              // existing item which got moved\n              last.index = index;\n              // This may be a noop, if the element is next, but I don't know of a good way to\n              // figure this out,  since it would require extra DOM access, so let's just hope that\n              // the browsers realizes that it is noop, and treats it as such.\n              cursor.after(last.element);\n              cursor = last.element;\n            }\n          } else {\n            // new item which we don't know about\n            childScope = scope.$new();\n          }\n\n          childScope[valueIdent] = value;\n          if (keyIdent) childScope[keyIdent] = key;\n          childScope.$index = index;\n\n          childScope.$first = (index === 0);\n          childScope.$last = (index === arrayBound);\n          childScope.$middle = !(childScope.$first || childScope.$last);\n\n          if (!last) {\n            linker(childScope, function(clone){\n              cursor.after(clone);\n              last = {\n                  scope: childScope,\n                  element: (cursor = clone),\n                  index: index\n                };\n              nextOrder.push(value, last);\n            });\n          }\n        }\n\n        //shrink children\n        for (key in lastOrder) {\n          if (lastOrder.hasOwnProperty(key)) {\n            array = lastOrder[key];\n            while(array.length) {\n              value = array.pop();\n              value.element.remove();\n              value.scope.$destroy();\n            }\n          }\n        }\n\n        lastOrder = nextOrder;\n      });\n    };\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngShow\n *\n * @description\n * The `ngShow` and `ngHide` directives show or hide a portion of the DOM tree (HTML)\n * conditionally.\n *\n * @element ANY\n * @param {expression} ngShow If the {@link guide/expression expression} is truthy\n *     then the element is shown or hidden respectively.\n *\n * @example\n   <doc:example>\n     <doc:source>\n        Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n        Show: <span ng-show=\"checked\">I show up when your checkbox is checked.</span> <br/>\n        Hide: <span ng-hide=\"checked\">I hide when your checkbox is checked.</span>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-show / ng-hide', function() {\n         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);\n         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);\n\n         input('checked').check();\n\n         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);\n         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);\n       });\n     </doc:scenario>\n   </doc:example>\n */\n//TODO(misko): refactor to remove element from the DOM\nvar ngShowDirective = ngDirective(function(scope, element, attr){\n  scope.$watch(attr.ngShow, function ngShowWatchAction(value){\n    element.css('display', toBoolean(value) ? '' : 'none');\n  });\n});\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngHide\n *\n * @description\n * The `ngHide` and `ngShow` directives hide or show a portion of the DOM tree (HTML)\n * conditionally.\n *\n * @element ANY\n * @param {expression} ngHide If the {@link guide/expression expression} is truthy then\n *     the element is shown or hidden respectively.\n *\n * @example\n   <doc:example>\n     <doc:source>\n        Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n        Show: <span ng-show=\"checked\">I show up when you checkbox is checked?</span> <br/>\n        Hide: <span ng-hide=\"checked\">I hide when you checkbox is checked?</span>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-show / ng-hide', function() {\n         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);\n         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);\n\n         input('checked').check();\n\n         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);\n         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);\n       });\n     </doc:scenario>\n   </doc:example>\n */\n//TODO(misko): refactor to remove element from the DOM\nvar ngHideDirective = ngDirective(function(scope, element, attr){\n  scope.$watch(attr.ngHide, function ngHideWatchAction(value){\n    element.css('display', toBoolean(value) ? 'none' : '');\n  });\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngStyle\n *\n * @description\n * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.\n *\n * @element ANY\n * @param {expression} ngStyle {@link guide/expression Expression} which evals to an\n *      object whose keys are CSS style names and values are corresponding values for those CSS\n *      keys.\n *\n * @example\n   <example>\n     <file name=\"index.html\">\n        <input type=\"button\" value=\"set\" ng-click=\"myStyle={color:'red'}\">\n        <input type=\"button\" value=\"clear\" ng-click=\"myStyle={}\">\n        <br/>\n        <span ng-style=\"myStyle\">Sample Text</span>\n        <pre>myStyle={{myStyle}}</pre>\n     </file>\n     <file name=\"style.css\">\n       span {\n         color: black;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-style', function() {\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\n         element('.doc-example-live :button[value=set]').click();\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');\n         element('.doc-example-live :button[value=clear]').click();\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\n       });\n     </file>\n   </example>\n */\nvar ngStyleDirective = ngDirective(function(scope, element, attr) {\n  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {\n    if (oldStyles && (newStyles !== oldStyles)) {\n      forEach(oldStyles, function(val, style) { element.css(style, '');});\n    }\n    if (newStyles) element.css(newStyles);\n  }, true);\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSwitch\n * @restrict EA\n *\n * @description\n * Conditionally change the DOM structure.\n *\n * @usage\n * <ANY ng-switch=\"expression\">\n *   <ANY ng-switch-when=\"matchValue1\">...</ANY>\n *   <ANY ng-switch-when=\"matchValue2\">...</ANY>\n *   ...\n *   <ANY ng-switch-default>...</ANY>\n * </ANY>\n *\n * @scope\n * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.\n * @paramDescription\n * On child elments add:\n *\n * * `ngSwitchWhen`: the case statement to match against. If match then this\n *   case will be displayed.\n * * `ngSwitchDefault`: the default case when no other casses match.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.items = ['settings', 'home', 'other'];\n            $scope.selection = $scope.items[0];\n          }\n        </script>\n        <div ng-controller=\"Ctrl\">\n          <select ng-model=\"selection\" ng-options=\"item for item in items\">\n          </select>\n          <tt>selection={{selection}}</tt>\n          <hr/>\n          <div ng-switch on=\"selection\" >\n            <div ng-switch-when=\"settings\">Settings Div</div>\n            <span ng-switch-when=\"home\">Home Span</span>\n            <span ng-switch-default>default</span>\n          </div>\n        </div>\n      </doc:source>\n      <doc:scenario>\n        it('should start in settings', function() {\n         expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);\n        });\n        it('should change to home', function() {\n         select('selection').option('home');\n         expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);\n        });\n        it('should select deafault', function() {\n         select('selection').option('other');\n         expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar NG_SWITCH = 'ng-switch';\nvar ngSwitchDirective = valueFn({\n  restrict: 'EA',\n  require: 'ngSwitch',\n  // asks for $scope to fool the BC controller module\n  controller: ['$scope', function ngSwitchController() {\n    this.cases = {};\n  }],\n  link: function(scope, element, attr, ctrl) {\n    var watchExpr = attr.ngSwitch || attr.on,\n        selectedTransclude,\n        selectedElement,\n        selectedScope;\n\n    scope.$watch(watchExpr, function ngSwitchWatchAction(value) {\n      if (selectedElement) {\n        selectedScope.$destroy();\n        selectedElement.remove();\n        selectedElement = selectedScope = null;\n      }\n      if ((selectedTransclude = ctrl.cases['!' + value] || ctrl.cases['?'])) {\n        scope.$eval(attr.change);\n        selectedScope = scope.$new();\n        selectedTransclude(selectedScope, function(caseElement) {\n          selectedElement = caseElement;\n          element.append(caseElement);\n        });\n      }\n    });\n  }\n});\n\nvar ngSwitchWhenDirective = ngDirective({\n  transclude: 'element',\n  priority: 500,\n  require: '^ngSwitch',\n  compile: function(element, attrs, transclude) {\n    return function(scope, element, attr, ctrl) {\n      ctrl.cases['!' + attrs.ngSwitchWhen] = transclude;\n    };\n  }\n});\n\nvar ngSwitchDefaultDirective = ngDirective({\n  transclude: 'element',\n  priority: 500,\n  require: '^ngSwitch',\n  compile: function(element, attrs, transclude) {\n    return function(scope, element, attr, ctrl) {\n      ctrl.cases['?'] = transclude;\n    };\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngTransclude\n *\n * @description\n * Insert the transcluded DOM here.\n *\n * @element ANY\n *\n * @example\n   <doc:example module=\"transclude\">\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.title = 'Lorem Ipsum';\n           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';\n         }\n\n         angular.module('transclude', [])\n          .directive('pane', function(){\n             return {\n               restrict: 'E',\n               transclude: true,\n               scope: { title:'@' },\n               template: '<div style=\"border: 1px solid black;\">' +\n                           '<div style=\"background-color: gray\">{{title}}</div>' +\n                           '<div ng-transclude></div>' +\n                         '</div>'\n             };\n         });\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <input ng-model=\"title\"><br>\n         <textarea ng-model=\"text\"></textarea> <br/>\n         <pane title=\"{{title}}\">{{text}}</pane>\n       </div>\n     </doc:source>\n     <doc:scenario>\n        it('should have transcluded', function() {\n          input('title').enter('TITLE');\n          input('text').enter('TEXT');\n          expect(binding('title')).toEqual('TITLE');\n          expect(binding('text')).toEqual('TEXT');\n        });\n     </doc:scenario>\n   </doc:example>\n *\n */\nvar ngTranscludeDirective = ngDirective({\n  controller: ['$transclude', '$element', function($transclude, $element) {\n    $transclude(function(clone) {\n      $element.append(clone);\n    });\n  }]\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngView\n * @restrict ECA\n *\n * @description\n * # Overview\n * `ngView` is a directive that complements the {@link ng.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * @scope\n * @example\n    <example module=\"ngView\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCntl\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div ng-view></div>\n          <hr />\n\n          <pre>$location.path() = {{$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{$route.current.params}}</pre>\n          <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n          <pre>$routeParams = {{$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        controller: {{name}}<br />\n        Book Id: {{params.bookId}}<br />\n      </file>\n\n      <file name=\"chapter.html\">\n        controller: {{name}}<br />\n        Book Id: {{params.bookId}}<br />\n        Chapter Id: {{params.chapterId}}\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngView', [], function($routeProvider, $locationProvider) {\n          $routeProvider.when('/Book/:bookId', {\n            templateUrl: 'book.html',\n            controller: BookCntl\n          });\n          $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n            templateUrl: 'chapter.html',\n            controller: ChapterCntl\n          });\n\n          // configure html5 to get links working on jsfiddle\n          $locationProvider.html5Mode(true);\n        });\n\n        function MainCntl($scope, $route, $routeParams, $location) {\n          $scope.$route = $route;\n          $scope.$location = $location;\n          $scope.$routeParams = $routeParams;\n        }\n\n        function BookCntl($scope, $routeParams) {\n          $scope.name = \"BookCntl\";\n          $scope.params = $routeParams;\n        }\n\n        function ChapterCntl($scope, $routeParams) {\n          $scope.name = \"ChapterCntl\";\n          $scope.params = $routeParams;\n        }\n      </file>\n\n      <file name=\"scenario.js\">\n        it('should load and compile correct template', function() {\n          element('a:contains(\"Moby: Ch1\")').click();\n          var content = element('.doc-example-live [ng-view]').text();\n          expect(content).toMatch(/controller\\: ChapterCntl/);\n          expect(content).toMatch(/Book Id\\: Moby/);\n          expect(content).toMatch(/Chapter Id\\: 1/);\n\n          element('a:contains(\"Scarlet\")').click();\n          content = element('.doc-example-live [ng-view]').text();\n          expect(content).toMatch(/controller\\: BookCntl/);\n          expect(content).toMatch(/Book Id\\: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ng.directive:ngView#$viewContentLoaded\n * @eventOf ng.directive:ngView\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nvar ngViewDirective = ['$http', '$templateCache', '$route', '$anchorScroll', '$compile',\n                       '$controller',\n               function($http,   $templateCache,   $route,   $anchorScroll,   $compile,\n                        $controller) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    link: function(scope, element, attr) {\n      var lastScope,\n          onloadExp = attr.onload || '';\n\n      scope.$on('$routeChangeSuccess', update);\n      update();\n\n\n      function destroyLastScope() {\n        if (lastScope) {\n          lastScope.$destroy();\n          lastScope = null;\n        }\n      }\n\n      function clearContent() {\n        element.html('');\n        destroyLastScope();\n      }\n\n      function update() {\n        var locals = $route.current && $route.current.locals,\n            template = locals && locals.$template;\n\n        if (template) {\n          element.html(template);\n          destroyLastScope();\n\n          var link = $compile(element.contents()),\n              current = $route.current,\n              controller;\n\n          lastScope = current.scope = scope.$new();\n          if (current.controller) {\n            locals.$scope = lastScope;\n            controller = $controller(current.controller, locals);\n            element.children().data('$ngControllerController', controller);\n          }\n\n          link(lastScope);\n          lastScope.$emit('$viewContentLoaded');\n          lastScope.$eval(onloadExp);\n\n          // $anchorScroll might listen on event...\n          $anchorScroll();\n        } else {\n          clearContent();\n        }\n      }\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:script\n *\n * @description\n * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the\n * template can be used by `ngInclude`, `ngView` or directive templates.\n *\n * @restrict E\n * @param {'text/ng-template'} type must be set to `'text/ng-template'`\n *\n * @example\n  <doc:example>\n    <doc:source>\n      <script type=\"text/ng-template\" id=\"/tpl.html\">\n        Content of the template.\n      </script>\n\n      <a ng-click=\"currentTpl='/tpl.html'\" id=\"tpl-link\">Load inlined template</a>\n      <div id=\"tpl-content\" ng-include src=\"currentTpl\"></div>\n    </doc:source>\n    <doc:scenario>\n      it('should load template defined inside script tag', function() {\n        element('#tpl-link').click();\n        expect(element('#tpl-content').text()).toMatch(/Content of the template/);\n      });\n    </doc:scenario>\n  </doc:example>\n */\nvar scriptDirective = ['$templateCache', function($templateCache) {\n  return {\n    restrict: 'E',\n    terminal: true,\n    compile: function(element, attr) {\n      if (attr.type == 'text/ng-template') {\n        var templateUrl = attr.id,\n            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent\n            text = element[0].text;\n\n        $templateCache.put(templateUrl, text);\n      }\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:select\n * @restrict E\n *\n * @description\n * HTML `SELECT` element with angular data-binding.\n *\n * # `ngOptions`\n *\n * Optionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`\n * elements for a `<select>` element using an array or an object obtained by evaluating the\n * `ngOptions` expression.\n *\n * When an item in the `<select>` menu is selected, the value of array element or object property\n * represented by the selected option will be bound to the model identified by the `ngModel`\n * directive of the parent select element.\n *\n * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can\n * be nested into the `<select>` element. This element will then represent `null` or \"not selected\"\n * option. See example below for demonstration.\n *\n * Note: `ngOptions` provides iterator facility for `<option>` element which should be used instead\n * of {@link ng.directive:ngRepeat ngRepeat} when you want the\n * `select` model to be bound to a non-string value. This is because an option element can currently\n * be bound to string values only.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} required The control is considered valid only if value is entered.\n * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n *    `required` when you want to data-bind to the `required` attribute.\n * @param {comprehension_expression=} ngOptions in one of the following forms:\n *\n *   * for array data sources:\n *     * `label` **`for`** `value` **`in`** `array`\n *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`\n *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`\n *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array`\n *   * for object data sources:\n *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\n *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\n *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`\n *     * `select` **`as`** `label` **`group by`** `group`\n *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`\n *\n * Where:\n *\n *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.\n *   * `value`: local variable which will refer to each item in the `array` or each property value\n *      of `object` during iteration.\n *   * `key`: local variable which will refer to a property name in `object` during iteration.\n *   * `label`: The result of this expression will be the label for `<option>` element. The\n *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).\n *   * `select`: The result of this expression will be bound to the model of the parent `<select>`\n *      element. If not specified, `select` expression will default to `value`.\n *   * `group`: The result of this expression will be used to group options using the `<optgroup>`\n *      DOM element.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        <script>\n        function MyCntrl($scope) {\n          $scope.colors = [\n            {name:'black', shade:'dark'},\n            {name:'white', shade:'light'},\n            {name:'red', shade:'dark'},\n            {name:'blue', shade:'dark'},\n            {name:'yellow', shade:'light'}\n          ];\n          $scope.color = $scope.colors[2]; // red\n        }\n        </script>\n        <div ng-controller=\"MyCntrl\">\n          <ul>\n            <li ng-repeat=\"color in colors\">\n              Name: <input ng-model=\"color.name\">\n              [<a href ng-click=\"colors.splice($index, 1)\">X</a>]\n            </li>\n            <li>\n              [<a href ng-click=\"colors.push({})\">add</a>]\n            </li>\n          </ul>\n          <hr/>\n          Color (null not allowed):\n          <select ng-model=\"color\" ng-options=\"c.name for c in colors\"></select><br>\n\n          Color (null allowed):\n          <span  class=\"nullable\">\n            <select ng-model=\"color\" ng-options=\"c.name for c in colors\">\n              <option value=\"\">-- chose color --</option>\n            </select>\n          </span><br/>\n\n          Color grouped by shade:\n          <select ng-model=\"color\" ng-options=\"c.name group by c.shade for c in colors\">\n          </select><br/>\n\n\n          Select <a href ng-click=\"color={name:'not in list'}\">bogus</a>.<br>\n          <hr/>\n          Currently selected: {{ {selected_color:color}  }}\n          <div style=\"border:solid 1px black; height:20px\"\n               ng-style=\"{'background-color':color.name}\">\n          </div>\n        </div>\n      </doc:source>\n      <doc:scenario>\n         it('should check ng-options', function() {\n           expect(binding('{selected_color:color}')).toMatch('red');\n           select('color').option('0');\n           expect(binding('{selected_color:color}')).toMatch('black');\n           using('.nullable').select('color').option('');\n           expect(binding('{selected_color:color}')).toMatch('null');\n         });\n      </doc:scenario>\n    </doc:example>\n */\n\nvar ngOptionsDirective = valueFn({ terminal: true });\nvar selectDirective = ['$compile', '$parse', function($compile,   $parse) {\n                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444440000000005555555555555555500000006666666666666666600000000000000077770\n  var NG_OPTIONS_REGEXP = /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*)|(?:\\(\\s*([\\$\\w][\\$\\w\\d]*)\\s*,\\s*([\\$\\w][\\$\\w\\d]*)\\s*\\)))\\s+in\\s+(.*)$/,\n      nullModelCtrl = {$setViewValue: noop};\n\n  return {\n    restrict: 'E',\n    require: ['select', '?ngModel'],\n    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {\n      var self = this,\n          optionsMap = {},\n          ngModelCtrl = nullModelCtrl,\n          nullOption,\n          unknownOption;\n\n\n      self.databound = $attrs.ngModel;\n\n\n      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {\n        ngModelCtrl = ngModelCtrl_;\n        nullOption = nullOption_;\n        unknownOption = unknownOption_;\n      }\n\n\n      self.addOption = function(value) {\n        optionsMap[value] = true;\n\n        if (ngModelCtrl.$viewValue == value) {\n          $element.val(value);\n          if (unknownOption.parent()) unknownOption.remove();\n        }\n      };\n\n\n      self.removeOption = function(value) {\n        if (this.hasOption(value)) {\n          delete optionsMap[value];\n          if (ngModelCtrl.$viewValue == value) {\n            this.renderUnknownOption(value);\n          }\n        }\n      };\n\n\n      self.renderUnknownOption = function(val) {\n        var unknownVal = '? ' + hashKey(val) + ' ?';\n        unknownOption.val(unknownVal);\n        $element.prepend(unknownOption);\n        $element.val(unknownVal);\n        unknownOption.prop('selected', true); // needed for IE\n      }\n\n\n      self.hasOption = function(value) {\n        return optionsMap.hasOwnProperty(value);\n      }\n\n      $scope.$on('$destroy', function() {\n        // disable unknown option so that we don't do work when the whole select is being destroyed\n        self.renderUnknownOption = noop;\n      });\n    }],\n\n    link: function(scope, element, attr, ctrls) {\n      // if ngModel is not defined, we don't need to do anything\n      if (!ctrls[1]) return;\n\n      var selectCtrl = ctrls[0],\n          ngModelCtrl = ctrls[1],\n          multiple = attr.multiple,\n          optionsExp = attr.ngOptions,\n          nullOption = false, // if false, user will not be able to select it (used by ngOptions)\n          emptyOption,\n          // we can't just jqLite('<option>') since jqLite is not smart enough\n          // to create it in <select> and IE barfs otherwise.\n          optionTemplate = jqLite(document.createElement('option')),\n          optGroupTemplate =jqLite(document.createElement('optgroup')),\n          unknownOption = optionTemplate.clone();\n\n      // find \"null\" option\n      for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {\n        if (children[i].value == '') {\n          emptyOption = nullOption = children.eq(i);\n          break;\n        }\n      }\n\n      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);\n\n      // required validator\n      if (multiple && (attr.required || attr.ngRequired)) {\n        var requiredValidator = function(value) {\n          ngModelCtrl.$setValidity('required', !attr.required || (value && value.length));\n          return value;\n        };\n\n        ngModelCtrl.$parsers.push(requiredValidator);\n        ngModelCtrl.$formatters.unshift(requiredValidator);\n\n        attr.$observe('required', function() {\n          requiredValidator(ngModelCtrl.$viewValue);\n        });\n      }\n\n      if (optionsExp) Options(scope, element, ngModelCtrl);\n      else if (multiple) Multiple(scope, element, ngModelCtrl);\n      else Single(scope, element, ngModelCtrl, selectCtrl);\n\n\n      ////////////////////////////\n\n\n\n      function Single(scope, selectElement, ngModelCtrl, selectCtrl) {\n        ngModelCtrl.$render = function() {\n          var viewValue = ngModelCtrl.$viewValue;\n\n          if (selectCtrl.hasOption(viewValue)) {\n            if (unknownOption.parent()) unknownOption.remove();\n            selectElement.val(viewValue);\n            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy\n          } else {\n            if (isUndefined(viewValue) && emptyOption) {\n              selectElement.val('');\n            } else {\n              selectCtrl.renderUnknownOption(viewValue);\n            }\n          }\n        };\n\n        selectElement.bind('change', function() {\n          scope.$apply(function() {\n            if (unknownOption.parent()) unknownOption.remove();\n            ngModelCtrl.$setViewValue(selectElement.val());\n          });\n        });\n      }\n\n      function Multiple(scope, selectElement, ctrl) {\n        var lastView;\n        ctrl.$render = function() {\n          var items = new HashMap(ctrl.$viewValue);\n          forEach(selectElement.find('option'), function(option) {\n            option.selected = isDefined(items.get(option.value));\n          });\n        };\n\n        // we have to do it on each watch since ngModel watches reference, but\n        // we need to work of an array, so we need to see if anything was inserted/removed\n        scope.$watch(function selectMultipleWatch() {\n          if (!equals(lastView, ctrl.$viewValue)) {\n            lastView = copy(ctrl.$viewValue);\n            ctrl.$render();\n          }\n        });\n\n        selectElement.bind('change', function() {\n          scope.$apply(function() {\n            var array = [];\n            forEach(selectElement.find('option'), function(option) {\n              if (option.selected) {\n                array.push(option.value);\n              }\n            });\n            ctrl.$setViewValue(array);\n          });\n        });\n      }\n\n      function Options(scope, selectElement, ctrl) {\n        var match;\n\n        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {\n          throw Error(\n            \"Expected ngOptions in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_'\" +\n            \" but got '\" + optionsExp + \"'.\");\n        }\n\n        var displayFn = $parse(match[2] || match[1]),\n            valueName = match[4] || match[6],\n            keyName = match[5],\n            groupByFn = $parse(match[3] || ''),\n            valueFn = $parse(match[2] ? match[1] : valueName),\n            valuesFn = $parse(match[7]),\n            // This is an array of array of existing option groups in DOM. We try to reuse these if possible\n            // optionGroupsCache[0] is the options with no option group\n            // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element\n            optionGroupsCache = [[{element: selectElement, label:''}]];\n\n        if (nullOption) {\n          // compile the element since there might be bindings in it\n          $compile(nullOption)(scope);\n\n          // remove the class, which is added automatically because we recompile the element and it\n          // becomes the compilation root\n          nullOption.removeClass('ng-scope');\n\n          // we need to remove it before calling selectElement.html('') because otherwise IE will\n          // remove the label from the element. wtf?\n          nullOption.remove();\n        }\n\n        // clear contents, we'll add what's needed based on the model\n        selectElement.html('');\n\n        selectElement.bind('change', function() {\n          scope.$apply(function() {\n            var optionGroup,\n                collection = valuesFn(scope) || [],\n                locals = {},\n                key, value, optionElement, index, groupIndex, length, groupLength;\n\n            if (multiple) {\n              value = [];\n              for (groupIndex = 0, groupLength = optionGroupsCache.length;\n                   groupIndex < groupLength;\n                   groupIndex++) {\n                // list of options for that group. (first item has the parent)\n                optionGroup = optionGroupsCache[groupIndex];\n\n                for(index = 1, length = optionGroup.length; index < length; index++) {\n                  if ((optionElement = optionGroup[index].element)[0].selected) {\n                    key = optionElement.val();\n                    if (keyName) locals[keyName] = key;\n                    locals[valueName] = collection[key];\n                    value.push(valueFn(scope, locals));\n                  }\n                }\n              }\n            } else {\n              key = selectElement.val();\n              if (key == '?') {\n                value = undefined;\n              } else if (key == ''){\n                value = null;\n              } else {\n                locals[valueName] = collection[key];\n                if (keyName) locals[keyName] = key;\n                value = valueFn(scope, locals);\n              }\n            }\n            ctrl.$setViewValue(value);\n          });\n        });\n\n        ctrl.$render = render;\n\n        // TODO(vojta): can't we optimize this ?\n        scope.$watch(render);\n\n        function render() {\n          var optionGroups = {'':[]}, // Temporary location for the option groups before we render them\n              optionGroupNames = [''],\n              optionGroupName,\n              optionGroup,\n              option,\n              existingParent, existingOptions, existingOption,\n              modelValue = ctrl.$modelValue,\n              values = valuesFn(scope) || [],\n              keys = keyName ? sortedKeys(values) : values,\n              groupLength, length,\n              groupIndex, index,\n              locals = {},\n              selected,\n              selectedSet = false, // nothing is selected yet\n              lastElement,\n              element,\n              label;\n\n          if (multiple) {\n            selectedSet = new HashMap(modelValue);\n          }\n\n          // We now build up the list of options we need (we merge later)\n          for (index = 0; length = keys.length, index < length; index++) {\n               locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];\n               optionGroupName = groupByFn(scope, locals) || '';\n            if (!(optionGroup = optionGroups[optionGroupName])) {\n              optionGroup = optionGroups[optionGroupName] = [];\n              optionGroupNames.push(optionGroupName);\n            }\n            if (multiple) {\n              selected = selectedSet.remove(valueFn(scope, locals)) != undefined;\n            } else {\n              selected = modelValue === valueFn(scope, locals);\n              selectedSet = selectedSet || selected; // see if at least one item is selected\n            }\n            label = displayFn(scope, locals); // what will be seen by the user\n            label = label === undefined ? '' : label; // doing displayFn(scope, locals) || '' overwrites zero values\n            optionGroup.push({\n              id: keyName ? keys[index] : index,   // either the index into array or key from object\n              label: label,\n              selected: selected                   // determine if we should be selected\n            });\n          }\n          if (!multiple) {\n            if (nullOption || modelValue === null) {\n              // insert null option if we have a placeholder, or the model is null\n              optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});\n            } else if (!selectedSet) {\n              // option could not be found, we have to insert the undefined item\n              optionGroups[''].unshift({id:'?', label:'', selected:true});\n            }\n          }\n\n          // Now we need to update the list of DOM nodes to match the optionGroups we computed above\n          for (groupIndex = 0, groupLength = optionGroupNames.length;\n               groupIndex < groupLength;\n               groupIndex++) {\n            // current option group name or '' if no group\n            optionGroupName = optionGroupNames[groupIndex];\n\n            // list of options for that group. (first item has the parent)\n            optionGroup = optionGroups[optionGroupName];\n\n            if (optionGroupsCache.length <= groupIndex) {\n              // we need to grow the optionGroups\n              existingParent = {\n                element: optGroupTemplate.clone().attr('label', optionGroupName),\n                label: optionGroup.label\n              };\n              existingOptions = [existingParent];\n              optionGroupsCache.push(existingOptions);\n              selectElement.append(existingParent.element);\n            } else {\n              existingOptions = optionGroupsCache[groupIndex];\n              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element\n\n              // update the OPTGROUP label if not the same.\n              if (existingParent.label != optionGroupName) {\n                existingParent.element.attr('label', existingParent.label = optionGroupName);\n              }\n            }\n\n            lastElement = null;  // start at the beginning\n            for(index = 0, length = optionGroup.length; index < length; index++) {\n              option = optionGroup[index];\n              if ((existingOption = existingOptions[index+1])) {\n                // reuse elements\n                lastElement = existingOption.element;\n                if (existingOption.label !== option.label) {\n                  lastElement.text(existingOption.label = option.label);\n                }\n                if (existingOption.id !== option.id) {\n                  lastElement.val(existingOption.id = option.id);\n                }\n                // lastElement.prop('selected') provided by jQuery has side-effects\n                if (lastElement[0].selected !== option.selected) {\n                  lastElement.prop('selected', (existingOption.selected = option.selected));\n                }\n              } else {\n                // grow elements\n\n                // if it's a null option\n                if (option.id === '' && nullOption) {\n                  // put back the pre-compiled element\n                  element = nullOption;\n                } else {\n                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but\n                  // in this version of jQuery on some browser the .text() returns a string\n                  // rather then the element.\n                  (element = optionTemplate.clone())\n                      .val(option.id)\n                      .attr('selected', option.selected)\n                      .text(option.label);\n                }\n\n                existingOptions.push(existingOption = {\n                    element: element,\n                    label: option.label,\n                    id: option.id,\n                    selected: option.selected\n                });\n                if (lastElement) {\n                  lastElement.after(element);\n                } else {\n                  existingParent.element.append(element);\n                }\n                lastElement = element;\n              }\n            }\n            // remove any excessive OPTIONs in a group\n            index++; // increment since the existingOptions[0] is parent element not OPTION\n            while(existingOptions.length > index) {\n              existingOptions.pop().element.remove();\n            }\n          }\n          // remove any excessive OPTGROUPs from select\n          while(optionGroupsCache.length > groupIndex) {\n            optionGroupsCache.pop()[0].element.remove();\n          }\n        }\n      }\n    }\n  }\n}];\n\nvar optionDirective = ['$interpolate', function($interpolate) {\n  var nullSelectCtrl = {\n    addOption: noop,\n    removeOption: noop\n  };\n\n  return {\n    restrict: 'E',\n    priority: 100,\n    compile: function(element, attr) {\n      if (isUndefined(attr.value)) {\n        var interpolateFn = $interpolate(element.text(), true);\n        if (!interpolateFn) {\n          attr.$set('value', element.text());\n        }\n      }\n\n      return function (scope, element, attr) {\n        var selectCtrlName = '$selectController',\n            parent = element.parent(),\n            selectCtrl = parent.data(selectCtrlName) ||\n              parent.parent().data(selectCtrlName); // in case we are in optgroup\n\n        if (selectCtrl && selectCtrl.databound) {\n          // For some reason Opera defaults to true and if not overridden this messes up the repeater.\n          // We don't want the view to drive the initialization of the model anyway.\n          element.prop('selected', false);\n        } else {\n          selectCtrl = nullSelectCtrl;\n        }\n\n        if (interpolateFn) {\n          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {\n            attr.$set('value', newVal);\n            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);\n            selectCtrl.addOption(newVal);\n          });\n        } else {\n          selectCtrl.addOption(attr.value);\n        }\n\n        element.bind('$destroy', function() {\n          selectCtrl.removeOption(attr.value);\n        });\n      };\n    }\n  }\n}];\n\nvar styleDirective = valueFn({\n  restrict: 'E',\n  terminal: true\n});\n\n  //try to bind to jquery now so that one can write angular.element().read()\n  //but we will rebind on bootstrap again.\n  bindJQuery();\n\n  publishExternalAPI(angular);\n\n  jqLite(document).ready(function() {\n    angularInit(document, bootstrap);\n  });\n\n})(window, document);\nangular.element(document).find('head').append('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none !important;}ng\\\\:form{display:block;}</style>');","/*! angular-natural-language 2013-08-21 */\nangular.module(\"vr.directives.nlForm\",[\"vr.directives.nlForm.select\",\"vr.directives.nlForm.text\"]),angular.module(\"vr.directives.nlForm.select\",[]).directive(\"nlSelect\",function(){return{restrict:\"EA\",replace:!0,scope:{value:\"=\",options:\"=\"},controller:\"nlSelectCtrl\",template:\"<div ng-form='nlSelect' class='nl-field nl-dd' ng-class=\\\"{'nl-field-open': opened}\\\"><a class='nl-field-toggle' ng-click='open($event)' ng-bind='getSelected()'></a><ul><li ng-repeat='label in getLabels()' ng-class=\\\"{'nl-dd-checked': isSelected(label)}\\\" ng-click='select(label)' ng-bind='label'></li></ul></div>\",link:function(a,b,c){a.required=!angular.isUndefined(c.required),a.multiple=!angular.isUndefined(c.multiple),a.conjunction=a.multiple&&\"\"!=c.multiple?c.multiple:\"and\",a.none=angular.isUndefined(c.empty)?\"none\":c.empty,a.multiple&&!angular.isArray(a.value)&&(a.value=[a.value]);var d=!1;angular.forEach(b.parent().children(),function(a){a=angular.element(a),a.hasClass(\"nl-overlay\")&&(d=a)}),d||(d=angular.element('<div class=\"nl-overlay\"></div>'),b.parent().append(d)),d.bind(\"click\",function(){a.$apply(a.close)})}}}).controller(\"nlSelectCtrl\",[\"$scope\",function(a){function b(b){var c=!1;return angular.forEach(a.options,function(d){switch(a.optionType){case h:case j:b==d&&(c=!0);break;case i:case k:b==d.value&&(c=!0)}}),c}function c(){switch(a.optionType){case h:case i:return a.options.length;case k:case j:var b=0;return angular.forEach(a.options,function(){b++}),b}return 0}function d(b){if(b<c()&&b>=0)switch(a.optionType){case h:return{value:a.options[0],label:a.options[0]};case i:return a.options[0];case j:case k:var d=null,e=0;return angular.forEach(a.options,function(c,f){e==b&&(d=a.optionType==j?{value:c,label:f}:c),e++}),d}return{value:\"\",label:\"\"}}function e(b){var c=b;switch(a.optionType){case i:case k:angular.forEach(a.options,function(a){a.value==b&&(c=a.label)});break;case h:break;case j:angular.forEach(a.options,function(a,d){b==a&&(c=d)})}return c}function f(b){var c=b;switch(a.optionType){case h:break;case i:angular.forEach(a.options,function(a){a.label==b&&(c=a.value)});break;case j:c=a.options[b];break;case k:c=a.options[b].value}return c}function g(){if(a.multiple){var c=[];angular.forEach(a.value,function(a){b(a)&&c.push(a)}),a.value=c}else b(a.value)||(a.value=d(0).value)}var h=1,i=2,j=3,k=4;a.opened=!1,a.open=function(b){b.stopPropagation(),a.opened=!0},a.close=function(){a.opened=!1},a.select=function(b){a.setValue(b),a.close()},a.setValue=function(b){var c=f(b);if(a.multiple){var d=a.value.indexOf(c);-1==d?a.value.push(c):a.value.splice(d,1),a.required&&(0==a.value.length?a.nlSelect.$setValidity(\"required\",!1):a.nlSelect.$setValidity(\"required\",!0))}else a.value=c},a.getLabels=function(){switch(a.optionType){case h:return a.options;case i:return a.options.map(function(a){return a.label});case j:case k:var b=[];return angular.forEach(a.options,function(c,d){a.optionType==j?b.push(d):b.push(c.label)}),b}return[]},a.getSelected=function(){if(a.multiple){var b=\"\";if(a.value.length>0){var c=\"\",d=1;angular.forEach(a.value,function(f){b+=c+e(f),d++,c=a.value.length>2?\", \":\" \",d==a.value.length&&(c+=a.conjunction+\" \")})}else b=a.none;return b}return e(a.value)},a.isSelected=function(b){return a.multiple?a.value.indexOf(f(b))>-1:a.value==f(b)},a.$watch(\"options\",function(){if(a.optionType=null,angular.isArray(a.options))a.optionType=angular.isObject(a.options[0])?i:h;else if(angular.isObject(a.options))for(var b in a.options)if(a.options.hasOwnProperty(b)){a.optionType=angular.isObject(a.options[b])?k:j;break}g()},!0)}]),angular.module(\"vr.directives.nlForm.text\",[]).directive(\"nlText\",function(){return{restrict:\"EA\",replace:!0,scope:{placeholder:\"@\",subline:\"@\",name:\"@\",value:\"=\"},template:'<div ng-form class=\"nl-field nl-ti-text\" ng-class=\"{\\'nl-field-open\\': opened}\"><a class=\"nl-field-toggle\" ng-click=\"open($event)\" ng-bind=\"viewValue()\"></a><ul><li class=\"nl-ti-input\"><input type=\"text\" placeholder=\"{{ placeholder }}\" name=\"{{ name }}\" ng-model=\"value\" ng-click=\"$event.stopPropagation()\" ng-required=\"required\"/><button class=\"nl-field-go\" ng-click=\"close()\">Go</button></li><li class=\"nl-ti-example\" ng-show=\"showSubline()\" ng-bind-html-unsafe=\"subline\"></li></ul></div>',controller:\"nlTextCtrl\",link:function(a,b,c){a.required=!angular.isUndefined(c.required);var d=!1;angular.forEach(b.parent().children(),function(a){a=angular.element(a),a.hasClass(\"nl-overlay\")&&(d=a)}),d||(d=angular.element('<div class=\"nl-overlay\"></div>'),b.parent().append(d)),d.bind(\"click\",function(){a.$apply(a.close)})}}}).controller(\"nlTextCtrl\",[\"$scope\",function(a){a.opened=!1,a.open=function(b){b.stopPropagation(),a.opened=!0},a.close=function(){a.opened=!1},a.viewValue=function(){return\"\"==a.value?a.placeholder:a.value},a.showSubline=function(){return angular.isString(a.subline)&&\"\"!=a.subline}}]);","/* ========================================================================\n * DOM-based Routing\n * Based on http://goo.gl/EUTi53 by Paul Irish\n *\n * Only fires on body classes that match. If a body class contains a dash,\n * replace the dash with an underscore when adding it to the object below.\n *\n * .noConflict()\n * The routing is enclosed within an anonymous function so that you can\n * always reference jQuery with $, even when in .noConflict() mode.\n *\n * Google CDN, Latest jQuery\n * To use the default WordPress version of jQuery, go to lib/config.php and\n * remove or comment out: add_theme_support('jquery-cdn');\n * ======================================================================== */\n\n(function($) {\n\n  // Use this variable to set up the common and page specific functions. If you\n  // rename this variable, you will also need to rename the namespace below.\n  var Sage = {\n    // All pages\n    'common': {\n      init: function() {\n        // JavaScript to be fired on all pages\n      },\n      finalize: function() {\n        // JavaScript to be fired on all pages, after page specific JS is fired\n      }\n    },\n    // Home page\n    'home': {\n      init: function() {\n        // JavaScript to be fired on the home page\n      },\n      finalize: function() {\n        // JavaScript to be fired on the home page, after the init JS\n      }\n    },\n    // About us page, note the change from about-us to about_us.\n    'about_us': {\n      init: function() {\n        // JavaScript to be fired on the about us page\n      }\n    }\n  };\n\n  // The routing fires all common scripts, followed by the page specific scripts.\n  // Add additional events for more control over timing e.g. a finalize event\n  var UTIL = {\n    fire: function(func, funcname, args) {\n      var fire;\n      var namespace = Sage;\n      funcname = (funcname === undefined) ? 'init' : funcname;\n      fire = func !== '';\n      fire = fire && namespace[func];\n      fire = fire && typeof namespace[func][funcname] === 'function';\n\n      if (fire) {\n        namespace[func][funcname](args);\n      }\n    },\n    loadEvents: function() {\n      // Fire common init JS\n      UTIL.fire('common');\n\n      // Fire page-specific init JS, and then finalize JS\n      $.each(document.body.className.replace(/-/g, '_').split(/\\s+/), function(i, classnm) {\n        UTIL.fire(classnm);\n        UTIL.fire(classnm, 'finalize');\n      });\n\n      // Fire common finalize JS\n      UTIL.fire('common', 'finalize');\n    }\n  };\n\n  // Load Events\n  $(document).ready(UTIL.loadEvents);\n\n})(jQuery); // Fully reference jQuery after this point.\n"],"sourceRoot":"/source/"}